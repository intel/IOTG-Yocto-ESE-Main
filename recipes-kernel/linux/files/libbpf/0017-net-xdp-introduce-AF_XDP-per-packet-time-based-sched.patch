From 1a75c46f10a9ce11af66b6bcc1a1ab911239b2a2 Mon Sep 17 00:00:00 2001
From: "Wong, Vincent Por Yin" <vincent.por.yin.wong@intel.com>
Date: Mon, 14 Oct 2019 14:24:43 +0800
Subject: [PATCH 17/17] net: xdp: introduce AF_XDP per-packet time-based
 scheduling

Introduce per-packet time-based scheduling via the xdp descriptor. Users
specify per-packet transmit time via the xdp descriptor's txtime field.
Users are expected to specify the transmit time sufficiently ahead of
time based on their system's scheduling latency. Driver is reponsible to
either drop or transmit already late packets.

Signed-off-by: Wong, Vincent Por Yin <vincent.por.yin.wong@intel.com>
---
 .../net/ethernet/stmicro/stmmac/stmmac_xsk.c  |  8 +++++
 include/uapi/linux/if_xdp.h                   |  1 +
 samples/bpf/xdpsock_user.c                    | 36 ++++++++++++++++++-
 3 files changed, 44 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
index 438b18d63ccf..f872981b67fe 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
@@ -733,6 +733,14 @@ static bool stmmac_xmit_zc(struct stmmac_tx_queue *xdp_q, unsigned int budget)
 
 		stmmac_set_desc_addr(priv, tx_desc, dma);
 
+		if (stmmac_enabled_xdp(priv) && desc.txtime > 0) {
+			if (stmmac_set_tbs_launchtime(priv, tx_desc,
+						      desc.txtime)) {
+				netdev_warn(priv->dev, "Launch time setting"
+						       "failed\n");
+			}
+		}
+
 		stmmac_prepare_tx_desc(priv, tx_desc, /* Tx descriptor */
 				       1, /* is first descriptor */
 				       desc.len,
diff --git a/include/uapi/linux/if_xdp.h b/include/uapi/linux/if_xdp.h
index faaa5ca2a117..8457121f0f99 100644
--- a/include/uapi/linux/if_xdp.h
+++ b/include/uapi/linux/if_xdp.h
@@ -79,6 +79,7 @@ struct xdp_desc {
 	__u64 addr;
 	__u32 len;
 	__u32 options;
+	__u64 txtime;
 };
 
 /* UMEM descriptor is __u64 */
diff --git a/samples/bpf/xdpsock_user.c b/samples/bpf/xdpsock_user.c
index 93eaaf7239b2..77f4f6ef8813 100644
--- a/samples/bpf/xdpsock_user.c
+++ b/samples/bpf/xdpsock_user.c
@@ -49,6 +49,8 @@
 #define DEBUG_HEXDUMP 0
 #define MAX_SOCKS 8
 
+#define TXTIME_PERIOD_NS 1000000	//1ms
+
 typedef __u64 u64;
 typedef __u32 u32;
 
@@ -67,6 +69,8 @@ static int opt_ifindex;
 static int opt_queue;
 static int opt_poll;
 static int opt_interval = 1;
+static int opt_txtime;
+static int opt_period_ns = TXTIME_PERIOD_NS;
 static u32 opt_xdp_bind_flags;
 static int opt_xsk_frame_size = XSK_UMEM__DEFAULT_FRAME_SIZE;
 static __u32 prog_id;
@@ -384,7 +388,7 @@ static void parse_command_line(int argc, char **argv)
 	opterr = 0;
 
 	for (;;) {
-		c = getopt_long(argc, argv, "Frtli:q:psSNn:czf:", long_options,
+		c = getopt_long(argc, argv, "Frtli:q:psSNn:czf:TP", long_options,
 				&option_index);
 		if (c == -1)
 			break;
@@ -430,6 +434,12 @@ static void parse_command_line(int argc, char **argv)
 		case 'f':
 			opt_xsk_frame_size = atoi(optarg);
 			break;
+		case 'T':
+			opt_txtime = 1;
+			break;
+		case 'P':
+			opt_period_ns = atoi(optarg);
+			break;
 		default:
 			usage(basename(argv[0]));
 		}
@@ -571,17 +581,32 @@ static void rx_drop_all(void)
 	}
 }
 
+/* Get the current time in seconds */
+static u64 get_time_sec(clockid_t clkid)
+{
+	struct timespec now;
+
+	clock_gettime(clkid, &now);
+	return now.tv_sec * 1000000000;
+}
+
 static void tx_only(struct xsk_socket_info *xsk)
 {
 	int timeout, ret, nfds = 1;
 	struct pollfd fds[nfds + 1];
 	u32 idx, frame_nb = 0;
+	u64 tx_timestamp= 0;
 
 	memset(fds, 0, sizeof(fds));
 	fds[0].fd = xsk_socket__fd(xsk->xsk);
 	fds[0].events = POLLOUT;
 	timeout = 1000; /* 1sn */
 
+	if (opt_txtime) {
+		/* Initialize the first packet to the next second */
+		tx_timestamp = get_time_sec(CLOCK_TAI) + 1000000000;
+	}
+
 	for (;;) {
 		if (opt_poll) {
 			ret = poll(fds, nfds, timeout);
@@ -601,6 +626,15 @@ static void tx_only(struct xsk_socket_info *xsk)
 					= (frame_nb + i) * opt_xsk_frame_size;
 				xsk_ring_prod__tx_desc(&xsk->tx, idx + i)->len =
 					sizeof(pkt_data) - 1;
+
+				if (opt_txtime) {
+					tx_timestamp += opt_period_ns;
+					xsk_ring_prod__tx_desc(&xsk->tx, idx + i)
+						->txtime = tx_timestamp;
+				} else {
+					xsk_ring_prod__tx_desc(&xsk->tx, idx + i)
+						->txtime = 0;
+				}
 			}
 
 			xsk_ring_prod__submit(&xsk->tx, BATCH_SIZE);
-- 
2.17.0

