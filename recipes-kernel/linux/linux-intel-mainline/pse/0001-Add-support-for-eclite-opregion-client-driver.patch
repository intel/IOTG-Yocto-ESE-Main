From 7bd0b55871be9b9bdf287ce685cccd50d5b4a18e Mon Sep 17 00:00:00 2001
From: "K Naduvalath, Sumesh" <sumesh.k.naduvalath@intel.com>
Date: Mon, 19 Aug 2019 02:14:15 +0530
Subject: [PATCH] Add support for eclite opregion client driver

Description:
This driver probed by eclite client guid and installs opregion handlers
for communication to ACPI nodes via BIOS.

Change-Id: I7ec470850753579825b9193726250d01b781a9a5
Signed-off-by: K Naduvalath, Sumesh <sumesh.k.naduvalath@intel.com>
---
 drivers/hid/intel-ish-hid/Kconfig             |  10 +
 drivers/hid/intel-ish-hid/Makefile            |   1 +
 .../hid/intel-ish-hid/intel-ishtp-eclite.c    | 665 ++++++++++++++++++
 .../hid/intel-ish-hid/intel-ishtp-eclite.h    |  80 +++
 4 files changed, 756 insertions(+)
 create mode 100644 drivers/hid/intel-ish-hid/intel-ishtp-eclite.c
 create mode 100644 drivers/hid/intel-ish-hid/intel-ishtp-eclite.h

diff --git a/drivers/hid/intel-ish-hid/Kconfig b/drivers/hid/intel-ish-hid/Kconfig
index c6c9cfe2475e..d0598ed4dcca 100644
--- a/drivers/hid/intel-ish-hid/Kconfig
+++ b/drivers/hid/intel-ish-hid/Kconfig
@@ -30,4 +30,14 @@ config INTEL_ISH_FIRMWARE_DOWNLOADER
 
 	  Say M here if you want to support Host Firmware Loading feature
 	  for Intel ISH. If unsure, say N.
+
+config INTEL_ISH_ECLITE
+       tristate "Intel ISH eclite client"
+       default n
+       depends on INTEL_ISH_HID
+       help
+         The ish eclite client enables the communication between eclite fw on
+         the dedicated low power chip and the host. The driver also acts as an
+         operation region driver.
+
 endmenu
diff --git a/drivers/hid/intel-ish-hid/Makefile b/drivers/hid/intel-ish-hid/Makefile
index f0a82b1c7cb9..798188d035e9 100644
--- a/drivers/hid/intel-ish-hid/Makefile
+++ b/drivers/hid/intel-ish-hid/Makefile
@@ -22,5 +22,6 @@ intel-ishtp-hid-objs += ishtp-hid-client.o
 
 obj-$(CONFIG_INTEL_ISH_FIRMWARE_DOWNLOADER) += intel-ishtp-loader.o
 intel-ishtp-loader-objs += ishtp-fw-loader.o
+obj-$(CONFIG_INTEL_ISH_ECLITE) += intel-ishtp-eclite.o
 
 ccflags-y += -I $(srctree)/$(src)/ishtp
diff --git a/drivers/hid/intel-ish-hid/intel-ishtp-eclite.c b/drivers/hid/intel-ish-hid/intel-ishtp-eclite.c
new file mode 100644
index 000000000000..e6231bff5ddf
--- /dev/null
+++ b/drivers/hid/intel-ish-hid/intel-ishtp-eclite.c
@@ -0,0 +1,665 @@
+/*
+ * Intel ECLite opregion driver
+ *
+ * Copyright (c) 2019, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+/* This opregion driver has two interfaces
+ * 1. ishtp interface
+ * 2. ACPI interface
+ *
+ * TODO:
+ * Split the interfaces into two independent drivers and connect them
+ * using MFD drivers.
+ */
+
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/uuid.h>
+#include <linux/uaccess.h>
+
+#include <linux/acpi.h>
+#include <acpi/actypes.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+#include "ishtp/client.h"
+#include "ishtp/ishtp-dev.h"
+#include "intel-ishtp-eclite.h"
+
+static acpi_status ecl_acpi_scan(acpi_handle handle, u32 level, void *context,
+		void **retval)
+{
+	struct acpi_device *dev;
+
+	if (acpi_bus_get_device(handle, &dev))
+		return AE_OK;
+	if (strcmp(ECLITE_OPREGION_HID, acpi_device_hid(dev)))
+		return AE_OK;
+
+	ecl_log("[SCAN_ACPI] ACPI device %s found\n",(char *) context);
+	*(acpi_handle *)retval = handle;
+
+	return AE_CTRL_TERMINATE;
+}
+
+static acpi_status ecl_acpi_get_handle(const char *hid, acpi_handle *handle)
+{
+	acpi_status status;
+
+	status = acpi_get_devices(hid, ecl_acpi_scan,(void *)hid, handle);
+	if (ACPI_FAILURE(status)) {
+		return -ENODEV;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/**
+ * @ecl_ish_cl_read() - Read data from eclite FW
+ *
+ * @opr_dev - pointer to opregion device
+ *
+ * @This function issues a read request to eclite FW and waits until it
+ * receives a response. When response is received the read data is copied to
+ * opregion buffer.
+ */
+static int ecl_ish_cl_read(struct ishtp_opregion_dev *opr_dev)
+{
+	struct ishtp_cl *cl;
+	struct ecl_message_header header;
+	int len, ret;
+
+	header.version = ECL_ISH_HEADER_VERSION;
+	header.data_type = ECL_MSG_DATA;
+	header.request_type = ECL_ISH_READ;
+	header.offset = opr_dev->opr_context.cmd_area.offset;
+	header.data_len = opr_dev->opr_context.cmd_area.length;
+	header.event = opr_dev->opr_context.cmd_area.event_id;
+	len = sizeof(header);
+
+	cl = opr_dev->ecl_ishtp_cl;
+
+	if (!cl || !cl->dev) {
+		ret = -ENODEV;
+		goto err_exit;
+	}
+
+	if (cl->dev->dev_state != ISHTP_DEV_ENABLED) {
+		ret = -ENODEV;
+		goto err_exit;
+	}
+
+	if (cl->state != ISHTP_CL_CONNECTED)
+	{
+		ecl_log("[ERROR][ISH_READ] host client = %d not connected to FW client = %d\n",
+				cl->host_client_id, cl->fw_client_id);
+		ret = -ENODEV;
+		goto err_exit;
+	}
+
+	if (len <= 0 || len > cl->device->fw_client->props.max_msg_length) {
+		ret = -EMSGSIZE;
+		goto err_exit;
+	}
+
+	ecl_log("[ISH_READ]         %8s%8s%8s%8s%8s%8s\n", "ver", "d_t",
+			"rq_t", "offset", "len", "event");
+	ecl_log("[ISH_READ][ RQST ] %8x%8x%8x%8x%8x%8x\n", header.version,
+			header.data_type, header.request_type, header.offset,
+			header.data_len, header.event);
+
+	ret = ishtp_cl_send(cl, (void *)&header, len);
+	if(ret){
+		ecl_log("[ERROR][ISH_READ] send failed \n");
+		goto err_exit;
+	}
+
+	wait_event_interruptible(opr_dev->read_wait, (opr_dev->rb !=NULL));
+
+	opr_dev->rb = NULL;
+err_exit:
+
+	return ret;
+}
+
+/**
+ * @ecl_ish_cl_write() - This function writes date to eclite FW.
+ *
+ * @opr_dev - pointer to opregion device
+ *
+ * This function writes data to eclite FW.
+ */
+static int ecl_ish_cl_write(struct ishtp_opregion_dev *opr_dev)
+{
+	struct ishtp_cl *cl;
+	struct ecl_message message;
+	int len, ret;
+
+	message.header.version = ECL_ISH_HEADER_VERSION;
+	message.header.data_type = ECL_MSG_DATA;
+	message.header.request_type = ECL_ISH_WRITE;
+	message.header.offset = opr_dev->opr_context.cmd_area.offset;
+	message.header.data_len = opr_dev->opr_context.cmd_area.length;
+	message.header.event = opr_dev->opr_context.cmd_area.event_id;
+	len = sizeof(struct ecl_message_header) + message.header.data_len;
+
+	memcpy(message.payload,
+			opr_dev->opr_context.data_area.data +
+			message.header.offset, message.header.data_len);
+
+	cl = opr_dev->ecl_ishtp_cl;
+
+	if (!cl || !cl->dev) {
+		ret = -ENODEV;
+		goto err_exit;
+	}
+
+	if (cl->dev->dev_state != ISHTP_DEV_ENABLED) {
+		ret = -ENODEV;
+		goto err_exit;
+	}
+
+	if (cl->state != ISHTP_CL_CONNECTED)
+	{
+		ecl_log("[ERROR][ISH_WRITE] host client %d not connected to FW client = %d\n",
+				cl->host_client_id, cl->fw_client_id);
+		ret = -ENODEV;
+		goto err_exit;
+	}
+
+	if (len <= 0 || len > cl->device->fw_client->props.max_msg_length) {
+		ret = -EMSGSIZE;
+		goto err_exit;
+	}
+
+	ret = ishtp_cl_send(cl,(void *)&message, len);
+	if(!ret)
+		ecl_log("[ISH_WRITE] Data sent - off: %x, len:%x\n",
+				message.header.offset,
+				message.header.data_len);
+
+err_exit:
+	return ret;
+}
+
+static acpi_status ecl_opregion_cmd_handler(u32 function,
+		acpi_physical_address address, u32 bits, u64 *value64,
+		void *handler_context, void *region_context)
+{
+	int ret;
+	struct ishtp_opregion_dev *opr_dev;
+
+	if (region_context == NULL || value64 == NULL)
+		return AE_BAD_PARAMETER;
+
+	if(function == ACPI_READ){
+		ecl_log("[CMD_HNLR] ACPI read not supported\n");
+		return AE_ERROR;
+	}
+
+	opr_dev = region_context;
+
+	switch(address){
+		case cmd_opr_offsetof(command):
+			opr_dev->opr_context.cmd_area.command = *value64;
+
+			if(opr_dev->opr_context.cmd_area.command ==
+					ECL_ISH_READ){
+				ret = ecl_ish_cl_read(opr_dev);
+			}
+			else if(opr_dev->opr_context.cmd_area.command ==
+					ECL_ISH_WRITE){
+				ret = ecl_ish_cl_write(opr_dev);
+			}
+			break;
+		case cmd_opr_offsetof(offset):
+			opr_dev->opr_context.cmd_area.offset = *value64;
+			break;
+		case cmd_opr_offsetof(length):
+			opr_dev->opr_context.cmd_area.length = *value64;
+			break;
+		case cmd_opr_offsetof(event_id):
+			opr_dev->opr_context.cmd_area.event_id = *value64;
+			break;
+		default:
+			return AE_ERROR;
+	}
+
+	return AE_OK;
+}
+
+static acpi_status ecl_opregion_data_handler(u32 function, acpi_physical_address address,
+		      u32 bits, u64 *value64,
+		      void *handler_context, void *region_context)
+{
+	struct ishtp_opregion_dev *opr_dev;
+	unsigned int bytes = bits/8;
+
+	if (region_context == NULL || value64 == NULL)
+		return AE_BAD_PARAMETER;
+
+	if( address + bytes > ECL_DATA_OPR_BUFLEN){
+		ecl_log("[DATA_HNLR] Offset out of range\n");
+		return AE_BAD_PARAMETER;
+	}
+
+	opr_dev = region_context;
+
+	if(function == ACPI_READ){
+		memcpy(value64, &opr_dev->opr_context.data_area.data[address],
+				bytes);
+	}
+	else if(function == ACPI_WRITE){
+		ecl_log("[ACPI_WRITE] offset:%8llx, len: %8x\n", address, bytes);
+		memcpy(&opr_dev->opr_context.data_area.data[address], value64,
+				bytes);
+	}
+	else
+		return AE_BAD_PARAMETER;
+
+	return AE_OK;
+}
+
+static int acpi_opregion_init(struct ishtp_opregion_dev *opr_dev)
+{
+	acpi_status status;
+	struct acpi_device *device;
+	if (acpi_bus_get_device(opr_dev->acpi_handle, &device)){
+		ecl_log("[ERROR] ACPI opregion init failed\n");
+		return -ENODEV;
+	}
+
+	strcpy(acpi_device_name(device), ACPI_ECLITE_DEVICE_NAME);
+	strcpy(acpi_device_class(device), ACPI_ECLITE_CLASS);
+
+	status = acpi_install_address_space_handler(device->handle,
+			ECLITE_CMD_OPREGION_ID,
+			&ecl_opregion_cmd_handler,
+			NULL, opr_dev);
+	if (ACPI_FAILURE(status)) {
+		ecl_log("[ERROR]cmd space handler install failed\n");
+		return -1;
+	}
+
+	status = acpi_install_address_space_handler(device->handle,
+			ECLITE_DATA_OPREGION_ID,
+			&ecl_opregion_data_handler,
+			NULL, opr_dev);
+	if (ACPI_FAILURE(status)) {
+		ecl_log("[ERROR]data space handler install failed\n");
+		return -1;
+	}
+	ecl_log("[OPR_INIT]CMD & DATA opregion handlers installed succesfully\n");
+
+	return 0;
+}
+
+static void ecl_acpi_invoke_dsm(struct work_struct *work)
+{
+	struct ishtp_opregion_dev *opr_dev;
+	union acpi_object *obj;
+
+	opr_dev = container_of(work, struct ishtp_opregion_dev, event_work);
+
+	ecl_log("[INVOKE_DSM] Eval method\n");
+	obj = acpi_evaluate_dsm(opr_dev->acpi_handle, &ecl_acpi_uuid, 0,
+			opr_dev->dsm_event_id, NULL);
+	if (obj) {
+		ecl_log("[INVOKE_DSM] Exec DSM function code: %d success\n",
+				opr_dev->dsm_event_id);
+		ACPI_FREE(obj);
+	}
+}
+
+static void ecl_ish_process_received_data(struct ishtp_opregion_dev *opr_dev)
+{
+	struct ecl_message *message =
+		(struct ecl_message *)opr_dev->rb->buffer.data;
+
+	memcpy(opr_dev->opr_context.data_area.data + message->header.offset,
+			message->payload, message->header.data_len);
+
+	ecl_log("[ISH_CB][  RESP  ] %8x%8x%8x%8x%8x%8x ",
+			message->header.version, message->header.data_type,
+			message->header.request_type, message->header.offset,
+			message->header.data_len, message->header.event);
+
+	wake_up_interruptible(&opr_dev->read_wait);
+}
+
+static void ecl_ish_process_received_event(struct ishtp_opregion_dev *opr_dev)
+{
+	struct ecl_message_header *header =
+		(struct ecl_message_header *)opr_dev->rb->buffer.data;
+
+	opr_dev->dsm_event_id = header->event;
+	ecl_log("[ISH_CB][EVNT_MSG] Scheduling _DSM work\n");
+	schedule_work(&opr_dev->event_work);
+}
+
+static void ecl_ishtp_cl_event_cb(struct ishtp_cl_device *cl_device)
+{
+	struct ishtp_opregion_dev *opr_dev;
+	struct ecl_message_header *header;
+	struct ishtp_cl_rb *rb;
+
+	opr_dev = ishtp_get_drvdata(cl_device);
+	if (!opr_dev)
+		return;
+
+	rb = ishtp_cl_rx_get_rb(opr_dev->ecl_ishtp_cl);
+	if(!rb)	{
+		ecl_log("[ERROR][ISH_CB] Null rb\n");
+		return;
+	}
+
+	opr_dev->rb = rb;
+
+	header = (struct ecl_message_header *)rb->buffer.data;
+
+	if(header->data_type == ECL_MSG_DATA){
+		ecl_ish_process_received_data(opr_dev);
+	}
+	else if (header->data_type == ECL_MSG_EVENT){
+		ecl_ish_process_received_event(opr_dev);
+	}
+	else{
+		ecl_log("[ERROR][ISH_CB] Received wrong data_type \n");
+		return;
+		/* got an event with wrong data_type, handle this */
+	}
+
+	ishtp_cl_io_rb_recycle(rb);
+}
+
+static void ecl_ishtp_cl_reset_handler(struct work_struct *work)
+{
+	struct ishtp_opregion_dev *opr_dev;
+	struct ishtp_device *dev;
+	struct ishtp_cl_device *cl_device;
+	struct ishtp_cl *ecl_ishtp_cl;
+	struct ishtp_fw_client *fw_client;
+	int ret = 0;
+
+	opr_dev = container_of(work,
+			struct ishtp_opregion_dev, reset_work);
+
+	dev = opr_dev->cl_device->ishtp_dev;
+	if (!dev) {
+		dev_err(&opr_dev->cl_device->dev,
+			"This cl_device not link to ishtp_dev\n");
+		return;
+	}
+
+	cl_device = opr_dev->cl_device;
+
+	ecl_ishtp_cl = opr_dev->ecl_ishtp_cl;
+	if (ecl_ishtp_cl) {
+		ishtp_cl_unlink(ecl_ishtp_cl);
+		ishtp_cl_flush_queues(ecl_ishtp_cl);
+		ishtp_cl_free(ecl_ishtp_cl);
+
+		ecl_ishtp_cl = NULL;
+
+		ecl_ishtp_cl = ishtp_cl_allocate(cl_device);
+		if (!ecl_ishtp_cl) {
+			dev_err(&opr_dev->cl_device->dev,
+				"Allocate ishtp_cl failed\n");
+			return;
+		}
+
+		if (dev->dev_state != ISHTP_DEV_ENABLED) {
+			dev_err(&opr_dev->cl_device->dev,
+				"Ishtp dev isn't enabled\n");
+			ret = -ENODEV;
+			goto out_free;
+		}
+
+		ret = ishtp_cl_link(ecl_ishtp_cl);
+		if (ret) {
+			dev_err(&opr_dev->cl_device->dev,
+				"Can not link to ishtp\n");
+			goto out_free;
+		}
+
+		fw_client = ishtp_fw_cl_get_client(dev,
+				&cl_device->fw_client->props.protocol_name);
+		if (!fw_client) {
+			dev_err(&opr_dev->cl_device->dev,
+				"Don't find related fw client\n");
+			ret = -ENOENT;
+			goto out_free;
+		}
+
+		ecl_ishtp_cl->fw_client_id = fw_client->client_id;
+		ecl_ishtp_cl->state = ISHTP_CL_CONNECTING;
+
+		ret = ishtp_cl_connect(ecl_ishtp_cl);
+		if (ret) {
+			dev_err(&opr_dev->cl_device->dev,
+				"Connect to fw failed\n");
+			goto out_free;
+		}
+
+		opr_dev->ecl_ishtp_cl = ecl_ishtp_cl;
+	}
+
+	/* After reset, must register event callback again */
+	ishtp_register_event_cb(cl_device, ecl_ishtp_cl_event_cb);
+
+out_free:
+	if (ret) {
+		ishtp_cl_free(ecl_ishtp_cl);
+		opr_dev->ecl_ishtp_cl = NULL;
+
+		dev_err(&opr_dev->cl_device->dev, "Reset failed\n");
+	}
+}
+
+
+static int ecl_ishtp_cl_init(struct ishtp_cl *ecl_ishtp_cl)
+{
+	struct ishtp_device *dev;
+	struct ishtp_fw_client *fw_client;
+	int rv;
+
+	rv = ishtp_cl_link(ecl_ishtp_cl);
+	if (rv) {
+		ecl_log("[ERROR] ishtp_cl_link failed\n");
+		return	-ENOMEM;
+	}
+
+	dev = ecl_ishtp_cl->dev;
+
+	/* Connect to FW client */
+	ecl_ishtp_cl->rx_ring_size = ECL_CL_RX_RING_SIZE;
+	ecl_ishtp_cl->tx_ring_size = ECL_CL_TX_RING_SIZE;
+
+	fw_client = ishtp_fw_cl_get_client(dev, &ecl_ishtp_uuid);
+	if (!fw_client) {
+		ecl_log("[ERROR] fw client not found\n");
+		rv = -ENOENT;
+		goto err_cl_unlink;
+	}
+
+	ecl_ishtp_cl->fw_client_id = fw_client->client_id;
+	ecl_ishtp_cl->state = ISHTP_CL_CONNECTING;
+
+	rv = ishtp_cl_connect(ecl_ishtp_cl);
+	if (rv) {
+		ecl_log("[ERROR] Client connect failed\n");
+		goto err_cl_unlink;
+	}
+
+	ecl_log("[ISH_INIT]Host client = %d is  connected to fw client = %d\n",
+			ecl_ishtp_cl->host_client_id,
+			ecl_ishtp_cl->fw_client_id);
+
+	ishtp_register_event_cb(ecl_ishtp_cl->device, ecl_ishtp_cl_event_cb);
+
+	goto err_exit;
+err_cl_unlink:
+	ishtp_cl_unlink(ecl_ishtp_cl);
+err_exit:
+	return rv;
+}
+
+static void ecl_ishtp_cl_deinit(struct ishtp_cl *ecl_ishtp_cl)
+{
+	ishtp_cl_unlink(ecl_ishtp_cl);
+	ishtp_cl_flush_queues(ecl_ishtp_cl);
+	ishtp_cl_free(ecl_ishtp_cl);
+}
+
+static int ecl_ishtp_cl_probe(struct ishtp_cl_device *cl_device)
+{
+	struct ishtp_cl *ecl_ishtp_cl;
+	struct ishtp_opregion_dev *opr_dev;
+	acpi_handle handle;
+	acpi_status status;
+	int rv;
+
+	if (!cl_device)
+		return	-ENODEV;
+
+	ecl_log("[PROBE_ISH] ISH_ECL Device found\n");
+
+	opr_dev = kzalloc(sizeof(struct ishtp_opregion_dev), GFP_KERNEL);
+	if(!opr_dev)
+		return -ENOMEM;
+
+	ecl_ishtp_cl = ishtp_cl_allocate(cl_device);
+	if (!ecl_ishtp_cl){
+		rv = -ENOMEM;
+		goto err_opr_free;
+	}
+
+	ishtp_set_drvdata(cl_device, opr_dev);
+	opr_dev->ecl_ishtp_cl = ecl_ishtp_cl;
+	opr_dev->cl_device = cl_device;
+
+	rv = ecl_ishtp_cl_init(ecl_ishtp_cl);
+	if (rv) {
+		ecl_log("[ERROR] Client init failed\n");
+		goto err_ish_free;
+	}
+	ecl_log("[PROBE] eclite-ishtp client initialised\n");
+
+	ishtp_get_device(cl_device);
+
+	/* Now initialize ACPI */
+	status = ecl_acpi_get_handle(ECLITE_OPREGION_HID, &handle);
+	if(ACPI_FAILURE(status)){
+		ecl_log("[ERROR] ACPI device %s not found\n",
+				ECLITE_OPREGION_HID);
+		rv = -ENODEV;
+		goto err_ish_free;
+	}
+
+	opr_dev->acpi_handle = handle;
+
+	/* init waitqueue and work before installing opr handlers */
+	init_waitqueue_head(&opr_dev->read_wait);
+	INIT_WORK(&opr_dev->event_work, ecl_acpi_invoke_dsm);
+	INIT_WORK(&opr_dev->reset_work, ecl_ishtp_cl_reset_handler);
+
+	rv = acpi_opregion_init(opr_dev);
+	if(rv){
+		ecl_log("[ERROR] ACPI opregion init failed\n");
+		return -ENODEV;
+	}
+	ecl_log("[PROBE]Done, reenumerating devices..\n");
+
+	acpi_walk_dep_device_list(handle);
+
+	goto err_exit;
+
+err_ish_free:
+	ishtp_cl_free(ecl_ishtp_cl);
+err_opr_free:
+	kfree(opr_dev);
+err_exit:
+	return rv;
+}
+
+static int ecl_ishtp_cl_remove(struct ishtp_cl_device *cl_device)
+{
+	struct ishtp_cl *ecl_ishtp_cl;
+	struct ishtp_opregion_dev *opr_dev;
+
+	opr_dev = ishtp_get_drvdata(cl_device);
+	if (!opr_dev)
+		return -ENODEV;
+
+	ecl_ishtp_cl = opr_dev->ecl_ishtp_cl;
+	if (ecl_ishtp_cl) {
+		ecl_ishtp_cl->state = ISHTP_CL_DISCONNECTING;
+		ishtp_cl_disconnect(ecl_ishtp_cl);
+		ecl_ishtp_cl_deinit(ecl_ishtp_cl);
+		opr_dev->ecl_ishtp_cl = NULL;
+	}
+
+	ishtp_put_device(cl_device);
+	kfree(opr_dev);
+
+	acpi_remove_address_space_handler(opr_dev->acpi_handle,
+			ECLITE_CMD_OPREGION_ID, ecl_opregion_cmd_handler);
+
+	acpi_remove_address_space_handler(opr_dev->acpi_handle,
+			ECLITE_DATA_OPREGION_ID, ecl_opregion_data_handler);
+
+
+	return 0;
+}
+
+static int ecl_ishtp_cl_reset(struct ishtp_cl_device *cl_device)
+{
+	struct ishtp_opregion_dev *opr_dev = ishtp_get_drvdata(cl_device);
+	if (!opr_dev) {
+		dev_err(&cl_device->dev, "Client driver not ready yet\n");
+		return -ENODEV;
+	}
+
+	schedule_work(&opr_dev->reset_work);
+
+	return 0;
+}
+
+static struct ishtp_cl_driver ecl_ishtp_cl_driver = {
+	.name = "ishtp-ecl",
+	.guid = &ecl_ishtp_uuid,
+	.probe = ecl_ishtp_cl_probe,
+	.remove = ecl_ishtp_cl_remove,
+	.reset = ecl_ishtp_cl_reset,
+};
+
+static int __init ecl_init(void)
+{
+	return ishtp_cl_driver_register(&ecl_ishtp_cl_driver, THIS_MODULE);
+}
+
+static void __exit ecl_exit(void)
+{
+	return ishtp_cl_driver_unregister(&ecl_ishtp_cl_driver);
+}
+
+module_init(ecl_init);
+module_exit(ecl_exit);
+
+MODULE_DESCRIPTION("eclite opregion driver");
+MODULE_AUTHOR("K Naduvalath, Sumesh <sumesh.k.naduvalath@intel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hid/intel-ish-hid/intel-ishtp-eclite.h b/drivers/hid/intel-ish-hid/intel-ishtp-eclite.h
new file mode 100644
index 000000000000..71bc98c68f97
--- /dev/null
+++ b/drivers/hid/intel-ish-hid/intel-ishtp-eclite.h
@@ -0,0 +1,80 @@
+#define ACPI_ECLITE_CLASS		"ECLite Controller"
+#define ACPI_ECLITE_DEVICE_NAME		"ECLite Controller"
+#define ECLITE_DATA_OPREGION_ID		0x9E
+#define ECLITE_CMD_OPREGION_ID		0x9F
+#define ECLITE_OPREGION_HID		"INT3538"
+
+#define ECL_MSG_DATA	0x1
+#define	ECL_MSG_EVENT	0x2
+
+#define ECL_ISH_READ	0x1
+#define ECL_ISH_WRITE	0x2
+#define ECL_ISH_HEADER_VERSION 0
+
+#define ECL_CL_RX_RING_SIZE	32
+#define ECL_CL_TX_RING_SIZE	16
+
+#define ECL_DATA_OPR_BUFLEN	384
+
+#define cmd_opr_offsetof(element) offsetof(struct opregion_cmd, element)
+
+#ifdef ECLITE_DEBUG
+#define ecl_log(param...) printk("[ecl-dbg]: " param)
+#else
+#define ecl_log(param...)
+#endif
+
+struct opregion_cmd{
+	unsigned int command;
+	unsigned int offset;
+	unsigned int length;
+	unsigned int event_id;
+};
+
+struct opregion_data{
+	char data[ECL_DATA_OPR_BUFLEN];
+};
+struct opregion_context{
+	struct opregion_cmd cmd_area;
+	struct opregion_data data_area;
+};
+
+struct ecl_message_header {
+	uint32_t version:2;
+	uint32_t data_type:2;
+	uint32_t request_type:2;
+	uint32_t offset:9;
+	uint32_t data_len:9;
+	uint32_t event:8;
+};
+
+struct ecl_message {
+	struct ecl_message_header header;
+	char payload[ECL_DATA_OPR_BUFLEN];
+};
+
+/*
+ * eclite client device driver structure
+ */
+struct ishtp_opregion_dev {
+	struct opregion_context opr_context;
+	struct acpi_handle *acpi_handle;
+	struct ishtp_cl *ecl_ishtp_cl;
+	struct ishtp_cl_device *cl_device;
+	struct ishtp_fw_client *fw_client;
+	unsigned int dsm_event_id;
+	struct ishtp_cl_rb *rb;
+	wait_queue_head_t read_wait;
+	struct work_struct event_work;
+	struct work_struct reset_work;
+};
+
+/* eclite ish client UUID: 6a19cc4b-d760-4de3-b14d-f25ebd0fbcd9 */
+static const uuid_le ecl_ishtp_uuid =
+			UUID_LE(0x6a19cc4b, 0xd760, 0x4de3,
+				0xb1, 0x4d, 0xf2, 0x5e, 0xbd, 0xf, 0xbc, 0xd9);
+
+/* ACPI DSM UUID: 91d936a7-1f01-49c6-a6b4-72f00ad8d8a5 */
+static const uuid_le ecl_acpi_uuid =
+			UUID_LE(0x91d936a7, 0x1f01, 0x49c6,
+				0xa6, 0xb4, 0x72, 0xf0, 0x0a, 0xd8, 0xd8, 0xa5);
-- 
2.21.0

