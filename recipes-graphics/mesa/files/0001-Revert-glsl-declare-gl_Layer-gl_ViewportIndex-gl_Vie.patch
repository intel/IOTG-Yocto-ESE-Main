From 8a0989a0af5192341fad9af18f9acac470d79dbf Mon Sep 17 00:00:00 2001
From: "Zawawi, Muhammad Zul Husni" <muhammad.zul.husni.zawawi@intel.com>
Date: Wed, 2 Sep 2020 17:01:18 +0800
Subject: [PATCH] Revert "glsl: declare
 gl_Layer/gl_ViewportIndex/gl_ViewportMask as vs builtins"

This reverts commit 49d35f3d882bd0f4418a1ce056344b8f06bd75dd.

Fallback to older implementation where Unigine issue not reproducible on TGL B2

Unigine error log:

Loading "demos/heaven/unigine.cpp" 20ms
Unigine~# render_restart
OpenGL error: invalid enum
Loading "heaven/locale/unigine.en" dictionary
Loading "core/materials/default/unigine_post.mat" 23 materials 50 shaders 2ms
Loading "core/materials/default/unigine_render.mat" 47 materials 2368 shaders 4ms
Loading "core/materials/default/unigine_mesh.mat" 5 materials 3386 shaders 5ms
Loading "core/materials/default/unigine_mesh_lut.mat" 2 materials 1062 shaders 1ms
Loading "core/materials/default/unigine_mesh_paint.mat" 2 materials 1158 shaders 2ms
Loading "core/materials/default/unigine_mesh_tessellation.mat" 5 materials 3332 shaders 6ms
Loading "core/materials/default/unigine_mesh_tessellation_paint.mat" 2 materials 2276 shaders 3ms
Loading "core/materials/default/unigine_mesh_triplanar.mat" 1 material 112 shaders 0ms
Loading "core/materials/default/unigine_mesh_overlap.mat" 1 material 300 shaders 1ms
Loading "core/materials/default/unigine_mesh_terrain.mat" 1 material 813 shaders 1ms
Loading "core/materials/default/unigine_mesh_layer.mat" 1 material 84 shaders 0ms
Loading "core/materials/default/unigine_mesh_noise.mat" 1 material 106 shaders 0ms
Loading "core/materials/default/unigine_mesh_stem.mat" 2 materials 2180 shaders 6ms
Loading "core/materials/default/unigine_mesh_wire.mat" 1 material 45 shaders 0ms
Loading "core/materials/default/unigine_terrain.mat" 1 material 1980 shaders 3ms
Loading "core/materials/default/unigine_grass.mat" 2 materials 474 shaders 1ms
Loading "core/materials/default/unigine_particles.mat" 1 material 109 shaders 0ms
Loading "core/materials/default/unigine_billboard.mat" 1 material 51 shaders 0ms
Loading "core/materials/default/unigine_billboards.mat" 2 materials 840 shaders 1ms
Loading "core/materials/default/unigine_volume.mat" 6 materials 53 shaders 1ms
Loading "core/materials/default/unigine_gui.mat" 1 material 82 shaders 0ms
Loading "core/materials/default/unigine_water.mat" 1 material 533 shaders 9ms
Loading "core/materials/default/unigine_sky.mat" 1 material 21 shaders 7ms
Loading "core/materials/default/unigine_decal.mat" 1 material 99 shaders 0ms
Loading "core/properties/unigine.prop" 2 properties 0ms
OpenGL error: invalid enum
Received signal SIGSEGV, invalid memory reference

---
 src/compiler/glsl/builtin_variables.cpp | 105 +++++++++++-------------
 1 file changed, 50 insertions(+), 55 deletions(-)

diff --git a/src/compiler/glsl/builtin_variables.cpp b/src/compiler/glsl/builtin_variables.cpp
index 24d0d403328..a5f88d9b069 100644
--- a/src/compiler/glsl/builtin_variables.cpp
+++ b/src/compiler/glsl/builtin_variables.cpp
@@ -315,7 +315,7 @@ class per_vertex_accumulator
 public:
    per_vertex_accumulator();
    void add_field(int slot, const glsl_type *type, int precision,
-                  const char *name, enum glsl_interp_mode interp);
+                  const char *name);
    const glsl_type *construct_interface_instance() const;
 
 private:
@@ -333,8 +333,7 @@ per_vertex_accumulator::per_vertex_accumulator()
 
 void
 per_vertex_accumulator::add_field(int slot, const glsl_type *type,
-                                  int precision, const char *name,
-                                  enum glsl_interp_mode interp)
+                                  int precision, const char *name)
 {
    assert(this->num_fields < ARRAY_SIZE(this->fields));
    this->fields[this->num_fields].type = type;
@@ -342,7 +341,7 @@ per_vertex_accumulator::add_field(int slot, const glsl_type *type,
    this->fields[this->num_fields].matrix_layout = GLSL_MATRIX_LAYOUT_INHERITED;
    this->fields[this->num_fields].location = slot;
    this->fields[this->num_fields].offset = -1;
-   this->fields[this->num_fields].interpolation = interp;
+   this->fields[this->num_fields].interpolation = INTERP_MODE_NONE;
    this->fields[this->num_fields].centroid = 0;
    this->fields[this->num_fields].sample = 0;
    this->fields[this->num_fields].patch = 0;
@@ -398,16 +397,14 @@ private:
    }
 
    ir_variable *add_input(int slot, const glsl_type *type, int precision,
-                          const char *name,
-                          enum glsl_interp_mode interp = INTERP_MODE_NONE)
+                          const char *name)
    {
-      return add_variable(name, type, precision, ir_var_shader_in, slot, interp);
+      return add_variable(name, type, precision, ir_var_shader_in, slot);
    }
 
-   ir_variable *add_input(int slot, const glsl_type *type, const char *name,
-                          enum glsl_interp_mode interp = INTERP_MODE_NONE)
+   ir_variable *add_input(int slot, const glsl_type *type, const char *name)
    {
-      return add_input(slot, type, GLSL_PRECISION_NONE, name, interp);
+      return add_input(slot, type, GLSL_PRECISION_NONE, name);
    }
 
    ir_variable *add_output(int slot, const glsl_type *type, int precision,
@@ -441,7 +438,7 @@ private:
 
    ir_variable *add_variable(const char *name, const glsl_type *type,
                              int precision, enum ir_variable_mode mode,
-                             int slot, enum glsl_interp_mode interp = INTERP_MODE_NONE);
+                             int slot);
    ir_variable *add_index_variable(const char *name, const glsl_type *type,
                                    int precision, enum ir_variable_mode mode,
                                    int slot, int index);
@@ -458,12 +455,10 @@ private:
    }
    ir_variable *add_const_ivec3(const char *name, int x, int y, int z);
    void add_varying(int slot, const glsl_type *type, int precision,
-                    const char *name,
-                    enum glsl_interp_mode interp  = INTERP_MODE_NONE);
-   void add_varying(int slot, const glsl_type *type, const char *name,
-                    enum glsl_interp_mode interp = INTERP_MODE_NONE)
+                    const char *name);
+   void add_varying(int slot, const glsl_type *type, const char *name)
    {
-      add_varying(slot, type, GLSL_PRECISION_NONE, name, interp);
+      add_varying(slot, type, GLSL_PRECISION_NONE, name);
    }
 
    exec_list * const instructions;
@@ -558,8 +553,7 @@ ir_variable *
 builtin_variable_generator::add_variable(const char *name,
                                          const glsl_type *type,
                                          int precision,
-                                         enum ir_variable_mode mode, int slot,
-                                         enum glsl_interp_mode interp)
+                                         enum ir_variable_mode mode, int slot)
 {
    ir_variable *var = new(symtab) ir_variable(type, name, mode);
    var->data.how_declared = ir_var_declared_implicitly;
@@ -586,7 +580,6 @@ builtin_variable_generator::add_variable(const char *name,
    var->data.location = slot;
    var->data.explicit_location = (slot >= 0);
    var->data.explicit_index = 0;
-   var->data.interpolation = interp;
 
    if (state->es_shader)
       var->data.precision = precision;
@@ -1080,6 +1073,8 @@ builtin_variable_generator::generate_special_vars()
 void
 builtin_variable_generator::generate_vs_special_vars()
 {
+   ir_variable *var;
+
    if (state->is_version(130, 300) || state->EXT_gpu_shader4_enable) {
       add_system_value(SYSTEM_VALUE_VERTEX_ID, int_t, GLSL_PRECISION_HIGH,
                        "gl_VertexID");
@@ -1106,6 +1101,33 @@ builtin_variable_generator::generate_vs_special_vars()
       add_system_value(SYSTEM_VALUE_BASE_INSTANCE, int_t, "gl_BaseInstanceARB");
       add_system_value(SYSTEM_VALUE_DRAW_ID, int_t, "gl_DrawIDARB");
    }
+   if (state->AMD_vertex_shader_layer_enable ||
+       state->ARB_shader_viewport_layer_array_enable ||
+       state->NV_viewport_array2_enable) {
+      var = add_output(VARYING_SLOT_LAYER, int_t, "gl_Layer");
+      var->data.interpolation = INTERP_MODE_FLAT;
+   }
+   if (state->AMD_vertex_shader_viewport_index_enable ||
+       state->ARB_shader_viewport_layer_array_enable ||
+       state->NV_viewport_array2_enable) {
+      var = add_output(VARYING_SLOT_VIEWPORT, int_t, "gl_ViewportIndex");
+      var->data.interpolation = INTERP_MODE_FLAT;
+   }
+   if (state->NV_viewport_array2_enable) {
+      /* From the NV_viewport_array2 specification:
+       *
+       *    "The variable gl_ViewportMask[] is available as an output variable
+       *    in the VTG languages. The array has ceil(v/32) elements where v is
+       *    the maximum number of viewports supported by the implementation."
+       *
+       * Since no drivers expose more than 16 viewports, we can simply set the
+       * array size to 1 rather than computing it and dealing with varying
+       * slot complication.
+       */
+      var = add_output(VARYING_SLOT_VIEWPORT_MASK, array(int_t, 1),
+                       "gl_ViewportMask");
+      var->data.interpolation = INTERP_MODE_FLAT;
+   }
    if (compatibility) {
       add_input(VERT_ATTRIB_POS, vec4_t, "gl_Vertex");
       add_input(VERT_ATTRIB_NORMAL, vec3_t, "gl_Normal");
@@ -1383,14 +1405,16 @@ builtin_variable_generator::generate_fs_special_vars()
        state->ARB_fragment_layer_viewport_enable ||
        state->OES_geometry_shader_enable ||
        state->EXT_geometry_shader_enable) {
-      add_varying(VARYING_SLOT_LAYER, int_t, GLSL_PRECISION_HIGH,
-                  "gl_Layer", INTERP_MODE_FLAT);
+      var = add_input(VARYING_SLOT_LAYER, int_t, GLSL_PRECISION_HIGH,
+                      "gl_Layer");
+      var->data.interpolation = INTERP_MODE_FLAT;
    }
 
    if (state->is_version(430, 0) ||
        state->ARB_fragment_layer_viewport_enable ||
        state->OES_viewport_array_enable) {
-      add_varying(VARYING_SLOT_VIEWPORT, int_t, "gl_ViewportIndex", INTERP_MODE_FLAT);
+      var = add_input(VARYING_SLOT_VIEWPORT, int_t, "gl_ViewportIndex");
+      var->data.interpolation = INTERP_MODE_FLAT;
    }
 
    if (state->is_version(450, 310) || state->ARB_ES3_1_compatibility_enable)
@@ -1428,20 +1452,19 @@ builtin_variable_generator::generate_cs_special_vars()
  */
 void
 builtin_variable_generator::add_varying(int slot, const glsl_type *type,
-                                        int precision, const char *name,
-                                        enum glsl_interp_mode interp)
+                                        int precision, const char *name)
 {
    switch (state->stage) {
    case MESA_SHADER_TESS_CTRL:
    case MESA_SHADER_TESS_EVAL:
    case MESA_SHADER_GEOMETRY:
-      this->per_vertex_in.add_field(slot, type, precision, name, interp);
+      this->per_vertex_in.add_field(slot, type, precision, name);
       /* FALLTHROUGH */
    case MESA_SHADER_VERTEX:
-      this->per_vertex_out.add_field(slot, type, precision, name, interp);
+      this->per_vertex_out.add_field(slot, type, precision, name);
       break;
    case MESA_SHADER_FRAGMENT:
-      add_input(slot, type, precision, name, interp);
+      add_input(slot, type, precision, name);
       break;
    case MESA_SHADER_COMPUTE:
       /* Compute shaders don't have varyings. */
@@ -1481,34 +1504,6 @@ builtin_variable_generator::generate_varyings()
                      GLSL_PRECISION_MEDIUM,
                      "gl_PointSize");
       }
-      if (state->stage == MESA_SHADER_VERTEX) {
-         if (state->AMD_vertex_shader_viewport_index_enable ||
-             state->ARB_shader_viewport_layer_array_enable ||
-             state->NV_viewport_array2_enable) {
-            add_varying(VARYING_SLOT_VIEWPORT, int_t, "gl_ViewportIndex", INTERP_MODE_FLAT);
-         }
-
-         if (state->AMD_vertex_shader_layer_enable ||
-             state->ARB_shader_viewport_layer_array_enable ||
-             state->NV_viewport_array2_enable) {
-            add_varying(VARYING_SLOT_LAYER, int_t, GLSL_PRECISION_HIGH,
-                        "gl_Layer", INTERP_MODE_FLAT);
-         }
-
-         /* From the NV_viewport_array2 specification:
-          *
-          *    "The variable gl_ViewportMask[] is available as an output variable
-          *    in the VTG languages. The array has ceil(v/32) elements where v is
-          *    the maximum number of viewports supported by the implementation."
-          *
-          * Since no drivers expose more than 16 viewports, we can simply set the
-          * array size to 1 rather than computing it and dealing with varying
-          * slot complication.
-          */
-         if (state->NV_viewport_array2_enable)
-            add_varying(VARYING_SLOT_VIEWPORT_MASK, array(int_t, 1),
-                        "gl_ViewportMask", INTERP_MODE_FLAT);
-        }
    }
 
    if (state->has_clip_distance()) {
-- 
2.27.0

