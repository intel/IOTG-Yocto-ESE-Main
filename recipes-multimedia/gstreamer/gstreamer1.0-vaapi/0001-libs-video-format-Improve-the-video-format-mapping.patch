From 165e530443865dac91adc801efd13752201c9a50 Mon Sep 17 00:00:00 2001
From: He Junyan <junyan.he@hotmail.com>
Date: Wed, 10 Jul 2019 16:42:09 +0800
Subject: [PATCH] libs: video-format: Improve the video format mapping.

The format mapping between GstVideoFormat and VAImageFormat have
following problems:
1. Use G_BYTE_ORDER to judge the VA_MSB_FIRST or VA_LSB_FIRST.
The G_BYTE_ORDER is defined by glib and is the result of CPU platform.
That does not mean all devices using VA interfaces need to be the same
byte order.
2. There are channels reorder between LSB and MSB. Gstreamer always
define video format in MSB, need to re-order the channels if VA
driver is LSB.

We modify it to generate a dynamically runtime video format map,
consider both LSB and MSB drivers. Also consider driver special
formats.

Fix #180
Fix #179
---
 gst-libs/gst/vaapi/gstvaapidisplay.c |  41 +++---
 gst-libs/gst/vaapi/gstvaapiimage.c   |   1 +
 gst-libs/gst/vaapi/video-format.c    | 278 ++++++++++++++++++++++++++++-------
 gst-libs/gst/vaapi/video-format.h    |   3 +
 4 files changed, 253 insertions(+), 70 deletions(-)

diff --git a/gst-libs/gst/vaapi/gstvaapidisplay.c b/gst-libs/gst/vaapi/gstvaapidisplay.c
index b6d6d61..ae6f3e9 100644
--- a/gst-libs/gst/vaapi/gstvaapidisplay.c
+++ b/gst-libs/gst/vaapi/gstvaapidisplay.c
@@ -738,6 +738,23 @@ cleanup:
   return success;
 }
 
+/* Ensures the VA driver vendor string was copied */
+static gboolean
+ensure_vendor_string (GstVaapiDisplay * display)
+{
+  GstVaapiDisplayPrivate *const priv = GST_VAAPI_DISPLAY_GET_PRIVATE (display);
+  const gchar *vendor_string;
+
+  GST_VAAPI_DISPLAY_LOCK (display);
+  if (!priv->vendor_string) {
+    vendor_string = vaQueryVendorString (priv->display);
+    if (vendor_string)
+      priv->vendor_string = g_strdup (vendor_string);
+  }
+  GST_VAAPI_DISPLAY_UNLOCK (display);
+  return priv->vendor_string != NULL;
+}
+
 static void
 gst_vaapi_display_calculate_pixel_aspect_ratio (GstVaapiDisplay * display)
 {
@@ -906,6 +923,13 @@ gst_vaapi_display_create (GstVaapiDisplay * display,
   GST_INFO_OBJECT (display, "new display addr=%p", display);
   g_free (priv->display_name);
   priv->display_name = g_strdup (info.display_name);
+
+  if (!ensure_vendor_string (display)) {
+    gst_vaapi_display_destroy (display);
+    return FALSE;
+  }
+  gst_vaapi_video_format_init_map (priv->vendor_string);
+
   return TRUE;
 }
 
@@ -2005,23 +2029,6 @@ set_color_balance (GstVaapiDisplay * display, guint prop_id, gfloat v)
   return TRUE;
 }
 
-/* Ensures the VA driver vendor string was copied */
-static gboolean
-ensure_vendor_string (GstVaapiDisplay * display)
-{
-  GstVaapiDisplayPrivate *const priv = GST_VAAPI_DISPLAY_GET_PRIVATE (display);
-  const gchar *vendor_string;
-
-  GST_VAAPI_DISPLAY_LOCK (display);
-  if (!priv->vendor_string) {
-    vendor_string = vaQueryVendorString (priv->display);
-    if (vendor_string)
-      priv->vendor_string = g_strdup (vendor_string);
-  }
-  GST_VAAPI_DISPLAY_UNLOCK (display);
-  return priv->vendor_string != NULL;
-}
-
 /**
  * gst_vaapi_display_get_vendor_string:
  * @display: a #GstVaapiDisplay
diff --git a/gst-libs/gst/vaapi/gstvaapiimage.c b/gst-libs/gst/vaapi/gstvaapiimage.c
index 6c10b3b..a2a6268 100644
--- a/gst-libs/gst/vaapi/gstvaapiimage.c
+++ b/gst-libs/gst/vaapi/gstvaapiimage.c
@@ -94,6 +94,7 @@ vaapi_image_is_linear (const VAImage * va_image)
     case VA_FOURCC ('B', 'G', 'R', 'X'):
     case VA_FOURCC ('Y', '2', '1', '0'):
     case VA_FOURCC ('Y', '4', '1', '0'):
+    case VA_FOURCC ('A', 'R', '3', '0'):
       data_size = 4 * width * height;
       break;
     case VA_FOURCC ('P', '0', '1', '0'):
diff --git a/gst-libs/gst/vaapi/video-format.c b/gst-libs/gst/vaapi/video-format.c
index a798cd9..558c9b7 100644
--- a/gst-libs/gst/vaapi/video-format.c
+++ b/gst-libs/gst/vaapi/video-format.c
@@ -32,12 +32,6 @@
 #include "gstvaapisurface.h"
 #include "video-format.h"
 
-#if G_BYTE_ORDER == G_BIG_ENDIAN
-# define VIDEO_VA_ENDIANESS VA_MSB_FIRST
-#elif G_BYTE_ORDER == G_LITTLE_ENDIAN
-# define VIDEO_VA_ENDIANESS VA_LSB_FIRST
-#endif
-
 typedef struct
 {
   GstVideoFormat format;
@@ -45,58 +39,185 @@ typedef struct
   VAImageFormat va_format;
 } GstVideoFormatMap;
 
-#define DEF_YUV(FORMAT, FOURCC, BPP, SUB)                               \
-  { G_PASTE(GST_VIDEO_FORMAT_,FORMAT),                                  \
-    G_PASTE(GST_VAAPI_CHROMA_TYPE_YUV,SUB),                             \
-    { VA_FOURCC FOURCC, VIDEO_VA_ENDIANESS, BPP, }, }
-
-#define DEF_RGB(FORMAT, FOURCC, BPP, DEPTH, R,G,B,A)                    \
-  { G_PASTE(GST_VIDEO_FORMAT_,FORMAT),                                  \
-    G_PASTE(GST_VAAPI_CHROMA_TYPE_RGB,BPP),                             \
-    { VA_FOURCC FOURCC, VIDEO_VA_ENDIANESS, BPP, DEPTH, R,G,B,A }, }
+static GstVideoFormatMap const *gst_vaapi_video_formats;
+
+#define VAAPI_MAX_VIDEO_MAP_SIZE 64
+
+#define DEF_YUV(ENTRY, FORMAT, FOURCC, BPP, SUB)                               \
+  do {                                                                         \
+    ENTRY->format = G_PASTE (GST_VIDEO_FORMAT_, FORMAT);                       \
+    ENTRY->chroma_type = G_PASTE (GST_VAAPI_CHROMA_TYPE_YUV, SUB);             \
+    ENTRY->va_format.fourcc = VA_FOURCC FOURCC;                                \
+    ENTRY->va_format.byte_order = byte_order;                                  \
+    ENTRY->va_format.bits_per_pixel = BPP;                                     \
+    ENTRY++;                                                                   \
+  } while (0)
+
+#define DEF_RGB(ENTRY, FORMAT, FOURCC, BPP, DEPTH, R, G, B, A)                 \
+  do {                                                                         \
+    ENTRY->format = G_PASTE (GST_VIDEO_FORMAT_, FORMAT);                       \
+    ENTRY->chroma_type = G_PASTE (GST_VAAPI_CHROMA_TYPE_RGB, BPP);             \
+    ENTRY->va_format.fourcc = VA_FOURCC FOURCC;                                \
+    ENTRY->va_format.byte_order = byte_order;                                  \
+    ENTRY->va_format.bits_per_pixel = BPP;                                     \
+    ENTRY->va_format.depth = DEPTH;                                            \
+    ENTRY->va_format.red_mask = R;                                             \
+    ENTRY->va_format.green_mask = G;                                           \
+    ENTRY->va_format.blue_mask = B;                                            \
+    ENTRY->va_format.alpha_mask = A;                                           \
+    ENTRY++;                                                                   \
+  } while (0)
+
+
+/* MAP GstVideoFormat to VAImageFormat.
+   The map needs to consider the byte order and may need to re-order the
+   channels. Gstreamer defines all formats in MSB by default, and if LSB
+   is needed, the format has LE suffix.
+   So Establish the map by the following rules:
+   1. Planar format does not care about byte order.
+   2. Format with LE suffix just used in LSB map, format with BE suffix
+      just used in MSB map.
+   3. LSB and packed format, may need to change the channel order if
+      bpp == 32, let driver's own init function do the map.
+   4. LSB and packed format, no change if bpp != 32
+   5. MSB, same with GST, no changes */
+
+static GstVideoFormatMap *
+init_video_format_map (uint32_t byte_order, gboolean common)
+{
+  static GstVideoFormatMap all_video_formats[VAAPI_MAX_VIDEO_MAP_SIZE];
+  GstVideoFormatMap *entry = all_video_formats;
 
-/* Image formats, listed in HW order preference */
-/* *INDENT-OFF* */
-static const GstVideoFormatMap gst_vaapi_video_formats[] = {
+  /* *INDENT-OFF* */
+  /* Image formats, listed in HW order preference */
   /* YUV formats */
-  DEF_YUV (NV12, ('N', 'V', '1', '2'), 12, 420),
-  DEF_YUV (YV12, ('Y', 'V', '1', '2'), 12, 420),
-  DEF_YUV (I420, ('I', '4', '2', '0'), 12, 420),
-  DEF_YUV (YUY2, ('Y', 'U', 'Y', '2'), 16, 422),
-  DEF_YUV (UYVY, ('U', 'Y', 'V', 'Y'), 16, 422),
-  DEF_YUV (Y210, ('Y', '2', '1', '0'), 32, 422_10BPP),
-  DEF_YUV (Y410, ('Y', '4', '1', '0'), 32, 444_10BPP),
-  DEF_YUV (AYUV, ('A', 'Y', 'U', 'V'), 32, 444),
-  DEF_YUV (Y444, ('4', '4', '4', 'P'), 24, 444),
-  DEF_YUV (GRAY8, ('Y', '8', '0', '0'), 8, 400),
-  DEF_YUV (P010_10LE, ('P', '0', '1', '0'), 24, 420_10BPP),
-  /* RGB formats */
-  DEF_RGB (ARGB, ('A', 'R', 'G', 'B'), 32,
-      32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000),
-  DEF_RGB (ABGR, ('A', 'B', 'G', 'R'), 32,
-      32, 0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000),
-  DEF_RGB (xRGB, ('X', 'R', 'G', 'B'), 32,
-      24, 0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000),
-  DEF_RGB (xBGR, ('X', 'B', 'G', 'R'), 32,
-      24, 0x000000ff, 0x0000ff00, 0x00ff0000, 0x00000000),
-  DEF_RGB (BGRA, ('B', 'G', 'R', 'A'), 32,
-      32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000),
-  DEF_RGB (RGBA, ('R', 'G', 'B', 'A'), 32,
-      32, 0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000),
-  DEF_RGB (BGRx, ('B', 'G', 'R', 'X'), 32,
-      24, 0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000),
-  DEF_RGB (RGBx, ('R', 'G', 'B', 'X'), 32,
-      24, 0x000000ff, 0x0000ff00, 0x00ff0000, 0x00000000),
-  DEF_RGB (RGB16, ('R', 'G', '1', '6'), 16,
-      16, 0x0000f800, 0x000007e0, 0x0000001f, 0x00000000),
-  DEF_RGB (RGB, ('R', 'G', '2', '4'), 32,
-      24, 0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000),
-  {0,}
-};
-/* *INDENT-ON* */
+  DEF_YUV (entry, NV12, ('N', 'V', '1', '2'), 12, 420); /* rule 1 */
+  DEF_YUV (entry, YV12, ('Y', 'V', '1', '2'), 12, 420); /* rule 1 */
+  DEF_YUV (entry, I420, ('I', '4', '2', '0'), 12, 420); /* rule 1 */
+  DEF_YUV (entry, YUY2, ('Y', 'U', 'Y', '2'), 16, 422); /* rule 4 */
+  DEF_YUV (entry, UYVY, ('U', 'Y', 'V', 'Y'), 16, 422); /* rule 4 */
+
+  DEF_YUV (entry, Y444, ('4', '4', '4', 'P'), 24, 444); /* rule 1 */
+  DEF_YUV (entry, GRAY8, ('Y', '8', '0', '0'), 8, 400); /* rule 1 */
+
+  if (common) {
+    if (byte_order == VA_LSB_FIRST) {
+      DEF_RGB (entry, ARGB, ('B', 'G', 'R', 'A'), 32, 32, 0x0000ff00,
+          0x00ff0000, 0xff000000, 0x000000ff); /* rule 3 */
+      DEF_RGB (entry, ABGR, ('R', 'G', 'B', 'A'), 32, 32, 0xff000000,
+          0x00ff0000, 0x0000ff00, 0x000000ff); /* rule 3 */
+      DEF_RGB (entry, BGRA, ('A', 'R', 'G', 'B'), 32, 32, 0x00ff0000,
+          0x0000ff00, 0x000000ff, 0xff000000); /* rule 3 */
+      DEF_RGB (entry, RGBA, ('A', 'B', 'G', 'R'), 32, 32, 0x000000ff,
+          0x0000ff00, 0x00ff0000, 0xff000000); /* rule 3 */
+
+      DEF_RGB (entry, xRGB, ('B', 'G', 'R', 'X'), 32, 24, 0x0000ff00,
+          0x00ff0000, 0xff000000, 0x00000000); /* rule 3 */
+      DEF_RGB (entry, xBGR, ('R', 'G', 'B', 'X'), 32, 24, 0xff000000,
+          0x00ff0000, 0x0000ff00, 0x00000000); /* rule 3 */
+      DEF_RGB (entry, BGRx, ('X', 'R', 'G', 'B'), 32, 24, 0x00ff0000,
+          0x0000ff00, 0x000000ff, 0x00000000); /* rule 3 */
+      DEF_RGB (entry, RGBx, ('X', 'B', 'G', 'R'), 32, 24, 0x000000ff,
+          0x0000ff00, 0x00ff0000, 0x00000000); /* rule 3 */
+    } else {
+      DEF_RGB (entry, ARGB, ('A', 'R', 'G', 'B'), 32, 32, 0x00ff0000,
+          0x0000ff00, 0x000000ff, 0xff000000); /* rule 5 */
+      DEF_RGB (entry, ABGR, ('A', 'B', 'G', 'R'), 32, 32, 0x000000ff,
+          0x0000ff00, 0x00ff0000, 0xff000000); /* rule 5 */
+      DEF_RGB (entry, BGRA, ('B', 'G', 'R', 'A'), 32, 32, 0x0000ff00,
+          0x00ff0000, 0xff000000, 0x000000ff); /* rule 5 */
+      DEF_RGB (entry, RGBA, ('R', 'G', 'B', 'A'), 32, 32, 0xff000000,
+          0x00ff0000, 0x0000ff00, 0x000000ff); /* rule 5 */
+
+      DEF_RGB (entry, xRGB, ('X', 'R', 'G', 'B'), 32, 24, 0x00ff0000,
+          0x0000ff00, 0x000000ff, 0x00000000); /* rule 5 */
+      DEF_RGB (entry, xBGR, ('X', 'B', 'G', 'R'), 32, 24, 0x000000ff,
+          0x0000ff00, 0x00ff0000, 0x00000000); /* rule 5 */
+      DEF_RGB (entry, BGRx, ('B', 'G', 'R', 'X'), 32, 24, 0x0000ff00,
+          0x00ff0000, 0xff000000, 0x00000000); /* rule 5 */
+      DEF_RGB (entry, RGBx, ('R', 'G', 'B', 'X'), 32, 24, 0xff000000,
+          0x00ff0000, 0x0000ff00, 0x00000000); /* rule 5 */
+    }
+  }
+  /* *INDENT-ON* */
+
+  /* Need at least one empty entry */
+  g_assert ((entry - all_video_formats) / sizeof (GstVideoFormatMap) <
+      VAAPI_MAX_VIDEO_MAP_SIZE);
+  return all_video_formats;
+}
+
+static void
+init_video_format_map_ihd (GstVideoFormatMap * map)
+{
+  GstVideoFormatMap *entry;
+  uint32_t byte_order = VA_LSB_FIRST;
+
+  entry = map;
+  while (entry->format)
+    entry++;
+
+  /* Need to re-order the channels */
+  /* *INDENT-OFF* */
+  DEF_YUV (entry, P010_10LE, ('P', '0', '1', '0'), 24, 420_10BPP); /* rule 2 */
+  DEF_YUV (entry, VUYA, ('A', 'Y', 'U', 'V'), 32, 444); /* rule 2 and 3 */
+  DEF_YUV (entry, Y210, ('Y', '2', '1', '0'), 32, 422_10BPP); /* rule 3 but not re-order */
+  DEF_YUV (entry, Y410, ('Y', '4', '1', '0'), 32, 444_10BPP); /* rule 3 but not re-order */
+
+  DEF_RGB (entry, ARGB, ('B', 'G', 'R', 'A'), 32, 32, 0x0000ff00, 0x00ff0000,
+      0xff000000, 0x000000ff); /* rule 3 */
+  DEF_RGB (entry, ABGR, ('R', 'G', 'B', 'A'), 32, 32, 0xff000000, 0x00ff0000,
+      0x0000ff00, 0x000000ff); /* rule 3 */
+  DEF_RGB (entry, BGRA, ('A', 'R', 'G', 'B'), 32, 32, 0x00ff0000, 0x0000ff00,
+      0x000000ff, 0xff000000); /* rule 3 */
+  DEF_RGB (entry, RGBA, ('A', 'B', 'G', 'R'), 32, 32, 0x000000ff, 0x0000ff00,
+      0x00ff0000, 0xff000000); /* rule 3 */
+
+  DEF_RGB (entry, xRGB, ('B', 'G', 'R', 'X'), 32, 24, 0x0000ff00, 0x00ff0000,
+      0xff000000, 0x00000000); /* rule 3 */
+  DEF_RGB (entry, xBGR, ('R', 'G', 'B', 'X'), 32, 24, 0xff000000, 0x00ff0000,
+      0x0000ff00, 0x00000000); /* rule 3 */
+  DEF_RGB (entry, BGRx, ('X', 'R', 'G', 'B'), 32, 24, 0x00ff0000, 0x0000ff00,
+      0x000000ff, 0x00000000); /* rule 3 */
+  DEF_RGB (entry, RGBx, ('X', 'B', 'G', 'R'), 32, 24, 0x000000ff, 0x0000ff00,
+      0x00ff0000, 0x00000000); /* rule 3 */
+  DEF_RGB (entry, BGR10A2_LE, ('A', 'R', '3', '0'), 32, 30, 0x3ff00000,
+      0x000ffc00, 0x000003ff, 0x30000000); /* rule 3 */
+
+  DEF_RGB (entry, RGB16, ('R', 'G', '1', '6'), 16, 16, 0x0000f800, 0x000007e0,
+      0x0000001f, 0x00000000); /* rule 4 */
+  DEF_RGB (entry, RGB, ('R', 'G', '2', '4'), 32, 24, 0x00ff0000, 0x0000ff00,
+      0x000000ff, 0x00000000); /* FIXME: the bpp should be 24 ? */
+  /* *INDENT-ON* */
+
+  /* Need at least one empty entry */
+  g_assert ((entry - map) / sizeof (GstVideoFormatMap) <
+      VAAPI_MAX_VIDEO_MAP_SIZE);
+}
+
+static void
+init_video_format_map_i965 (GstVideoFormatMap * map)
+{
+  GstVideoFormatMap *entry;
+  uint32_t byte_order = VA_LSB_FIRST;
+
+  entry = map;
+  while (entry->format)
+    entry++;
+
+  /* No channel reorder, driver do it by itself. */
+  /* *INDENT-OFF* */
+  DEF_YUV (entry, P010_10LE, ('P', '0', '1', '0'), 24, 420_10BPP); /* rule 2 */
+  DEF_RGB (entry, RGBx, ('R', 'G', 'B', 'X'), 32, 24, 0x000000ff,
+      0x0000ff00, 0x00ff0000, 0x00000000);
+  DEF_RGB (entry, BGRx, ('B', 'G', 'R', 'X'), 32, 24, 0x00ff0000,
+      0x0000ff00, 0x000000ff, 0x00000000);
+  /* *INDENT-ON* */
+}
 
 #undef DEF_RGB
 #undef DEF_YUV
+#undef VAAPI_MAX_VIDEO_MAP_SIZE
 
 static inline gboolean
 va_format_is_rgb (const VAImageFormat * va_format)
@@ -340,3 +461,54 @@ gst_vaapi_video_format_get_best_native (GstVideoFormat format)
   chroma_type = gst_vaapi_video_format_get_chroma_type (format);
   return gst_vaapi_video_format_from_chroma (chroma_type);
 }
+
+/**
+ * gst_vaapi_video_format_init_map:
+ * @vendor_string: va driver's vendor name #gchar
+ *
+ * Init the gstreamer video format and VAImageFormat map, need
+ * to consider the endianness.
+ **/
+void
+gst_vaapi_video_format_init_map (gchar * vendor_string)
+{
+  static volatile gsize map_inited = FALSE;
+
+  struct DrvMap
+  {
+    const gchar *str;
+    guint str_len;
+    uint32_t byte_order;
+    void (*init_func) (GstVideoFormatMap *);
+  };
+  static const struct DrvMap drv_names[] = {
+    {"Intel ihd driver", 16, VA_LSB_FIRST, init_video_format_map_ihd},
+    {"Intel i965 driver", 17, VA_LSB_FIRST, init_video_format_map_i965},
+    {NULL, 0}
+  };
+  const struct DrvMap *m = NULL;
+
+  if (g_once_init_enter (&map_inited)) {
+    uint32_t byte_order = VA_LSB_FIRST;
+    GstVideoFormatMap *format_map = NULL;
+
+    for (m = drv_names; m->str != NULL; m++) {
+      if (vendor_string && strlen (vendor_string) >= m->str_len &&
+          g_ascii_strncasecmp (vendor_string, m->str, m->str_len) == 0) {
+        byte_order = m->byte_order;
+        break;
+      }
+    }
+
+    GST_DEBUG ("init the video_formats map using %s order",
+        byte_order == VA_LSB_FIRST ? "LSB" : "MSB");
+    format_map = init_video_format_map (byte_order,
+        (m == NULL || m->init_func == NULL));
+    if (m && m->init_func)
+      m->init_func (format_map);
+
+    gst_vaapi_video_formats = format_map;
+
+    g_once_init_leave (&map_inited, TRUE);
+  }
+}
diff --git a/gst-libs/gst/vaapi/video-format.h b/gst-libs/gst/vaapi/video-format.h
index 35f96ec..1d2c2e5 100644
--- a/gst-libs/gst/vaapi/video-format.h
+++ b/gst-libs/gst/vaapi/video-format.h
@@ -59,6 +59,9 @@ gst_vaapi_video_format_from_chroma (guint chroma);
 GstVideoFormat
 gst_vaapi_video_format_get_best_native (GstVideoFormat format);
 
+void
+gst_vaapi_video_format_init_map (gchar * vendor_string);
+
 G_END_DECLS
 
 #endif /* GST_VAAPI_VIDEO_FORMAT_H */
-- 
2.7.4
