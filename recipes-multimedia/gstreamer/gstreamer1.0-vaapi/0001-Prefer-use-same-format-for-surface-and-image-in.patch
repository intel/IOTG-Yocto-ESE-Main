From b78214e7bafca21215cd3e9a7453ce055d920515 Mon Sep 17 00:00:00 2001
From: He Junyan <junyan.he@hotmail.com>
Date: Tue, 5 Feb 2019 16:59:40 +0800
Subject: [PATCH] plugins: Prefer use same format for surface and image in
 allocator.

We prefer to use the same format between image and surface for gst
vaapi allocator. The old way may choose different formats between
image and surface. For example, the RGBA image may have a NV12 surface.
So we need to do format conversion when we put/get image to surface.
Some drivers such as iHD can not support such conversion and always
cause a data flow error. There may also have some performance cost
for format conversion when put/get images.
So we prefer to use the same format for image and surface in the
allocator. If the surface can not support that format, we then
fallback to find a best one as the surface format.
---
 gst/vaapi/gstvaapivideomemory.c | 121 ++++++++++++++++----------------
 1 file changed, 62 insertions(+), 59 deletions(-)

diff --git a/gst/vaapi/gstvaapivideomemory.c b/gst/vaapi/gstvaapivideomemory.c
index 7bacdda2..33176f8d 100644
--- a/gst/vaapi/gstvaapivideomemory.c
+++ b/gst/vaapi/gstvaapivideomemory.c
@@ -162,30 +162,6 @@ ensure_image_is_current (GstVaapiVideoMemory * mem)
   return TRUE;
 }
 
-static GstVaapiSurface *
-new_surface (GstVaapiDisplay * display, const GstVideoInfo * vip,
-    GstVaapiImageUsageFlags usage_flag)
-{
-  GstVaapiSurface *surface;
-  GstVaapiChromaType chroma_type;
-
-  /* Try with explicit format first */
-  if (!use_native_formats (usage_flag) &&
-      GST_VIDEO_INFO_FORMAT (vip) != GST_VIDEO_FORMAT_ENCODED) {
-    surface = gst_vaapi_surface_new_full (display, vip, 0);
-    if (surface)
-      return surface;
-  }
-
-  /* Try to pick something compatible, i.e. with same chroma type */
-  chroma_type =
-      gst_vaapi_video_format_get_chroma_type (GST_VIDEO_INFO_FORMAT (vip));
-  if (!chroma_type)
-    return NULL;
-  return gst_vaapi_surface_new (display, chroma_type,
-      GST_VIDEO_INFO_WIDTH (vip), GST_VIDEO_INFO_HEIGHT (vip));
-}
-
 static GstVaapiSurfaceProxy *
 new_surface_proxy (GstVaapiVideoMemory * mem)
 {
@@ -747,59 +723,86 @@ static inline gboolean
 allocator_configure_surface_info (GstVaapiDisplay * display,
     GstVaapiVideoAllocator * allocator, GstVaapiImageUsageFlags req_usage_flag)
 {
-  const GstVideoInfo *vinfo;
-  GstVideoInfo *sinfo;
+  const GstVideoInfo *sinfo;
   GstVaapiSurface *surface = NULL;
   GstVideoFormat fmt;
 
-  vinfo = &allocator->allocation_info;
-  allocator->usage_flag = GST_VAAPI_IMAGE_USAGE_FLAG_NATIVE_FORMATS;
+  allocator->surface_info = allocator->allocation_info;
+  gst_video_info_force_nv12_if_encoded (&allocator->surface_info);
+  sinfo = &allocator->surface_info;
 
-  fmt = gst_vaapi_video_format_get_best_native (GST_VIDEO_INFO_FORMAT (vinfo));
+  surface = gst_vaapi_surface_new_full (display, sinfo, 0);
+
+  /* We always prefer the same format between surface and image. If we can
+     successfully create that surface, and native usage, it is OK. */
+  if (surface && (use_native_formats (req_usage_flag)
+          || GST_VIDEO_INFO_FORMAT (sinfo) == GST_VIDEO_FORMAT_ENCODED)) {
+    allocator->usage_flag = GST_VAAPI_IMAGE_USAGE_FLAG_NATIVE_FORMATS;
+    goto success;
+  }
+
+  /* Further check whether that surface can support direct upload/render */
+  if (surface) {
+    GstVideoInfo surface_info;
+    if (gst_video_info_update_from_surface (&surface_info, surface)) {
+      if (GST_VIDEO_INFO_FORMAT (&surface_info) ==
+          GST_VIDEO_INFO_FORMAT (sinfo)) {
+        /* Set the correct flag */
+        if (use_direct_rendering (req_usage_flag)
+            && !use_direct_uploading (req_usage_flag)) {
+          allocator->usage_flag = GST_VAAPI_IMAGE_USAGE_FLAG_DIRECT_RENDER;
+          GST_INFO_OBJECT (allocator, "has direct-rendering for %s surfaces",
+              GST_VIDEO_INFO_FORMAT_STRING (&allocator->surface_info));
+        } else if (!use_direct_rendering (req_usage_flag)
+            && use_direct_uploading (req_usage_flag)) {
+          allocator->usage_flag = GST_VAAPI_IMAGE_USAGE_FLAG_DIRECT_UPLOAD;
+          GST_INFO_OBJECT (allocator, "has direct-uploading for %s surfaces",
+              GST_VIDEO_INFO_FORMAT_STRING (&allocator->surface_info));
+        }
+
+        goto success;
+      }
+    }
+
+    /* Can not derive image or not the same format,
+       don't use derived images, just fallback to use native */
+    allocator->usage_flag = GST_VAAPI_IMAGE_USAGE_FLAG_NATIVE_FORMATS;
+    goto success;
+  }
+
+  /* Find a best native surface format if possible */
+  fmt =
+      gst_vaapi_video_format_get_best_native (GST_VIDEO_INFO_FORMAT
+      (&allocator->allocation_info));
   if (fmt == GST_VIDEO_FORMAT_UNKNOWN)
     goto error_invalid_format;
+  if (fmt == GST_VIDEO_INFO_FORMAT (sinfo))     // The same format, we already tried.
+    goto error_invalid_format;
 
   gst_video_info_set_format (&allocator->surface_info, fmt,
-      GST_VIDEO_INFO_WIDTH (vinfo), GST_VIDEO_INFO_HEIGHT (vinfo));
-
-  /* nothing to configure */
-  if (use_native_formats (req_usage_flag)
-      || GST_VIDEO_INFO_FORMAT (vinfo) == GST_VIDEO_FORMAT_ENCODED)
-    return TRUE;
-
-  surface = new_surface (display, vinfo, req_usage_flag);
+      GST_VIDEO_INFO_WIDTH (&allocator->allocation_info),
+      GST_VIDEO_INFO_HEIGHT (&allocator->allocation_info));
+  surface = gst_vaapi_surface_new_full (display, &allocator->surface_info, 0);
   if (!surface)
     goto error_no_surface;
 
-  sinfo = &allocator->surface_info;
-  if (!gst_video_info_update_from_surface (sinfo, surface))
-    goto bail;
-
-  /* if not the same format, don't use derived images */
-  if (GST_VIDEO_INFO_FORMAT (sinfo) != GST_VIDEO_INFO_FORMAT (vinfo))
-    goto bail;
-
-  if (use_direct_rendering (req_usage_flag)
-      && !use_direct_uploading (req_usage_flag)) {
-    allocator->usage_flag = GST_VAAPI_IMAGE_USAGE_FLAG_DIRECT_RENDER;
-    GST_INFO_OBJECT (allocator, "has direct-rendering for %s surfaces",
-        GST_VIDEO_INFO_FORMAT_STRING (sinfo));
-  } else if (!use_direct_rendering (req_usage_flag)
-      && use_direct_uploading (req_usage_flag)) {
-    allocator->usage_flag = GST_VAAPI_IMAGE_USAGE_FLAG_DIRECT_UPLOAD;
-    GST_INFO_OBJECT (allocator, "has direct-uploading for %s surfaces",
-        GST_VIDEO_INFO_FORMAT_STRING (sinfo));
-  }
+  /* Not the same format, don't use derived images */
+  allocator->usage_flag = GST_VAAPI_IMAGE_USAGE_FLAG_NATIVE_FORMATS;
 
-bail:
+success:
   if (surface)
     gst_vaapi_object_unref (surface);
+
+  GST_DEBUG_OBJECT (allocator, "success to set the surface format %s"
+      " for video format %s",
+      GST_VIDEO_INFO_FORMAT_STRING (&allocator->surface_info),
+      GST_VIDEO_INFO_FORMAT_STRING (&allocator->allocation_info));
   return TRUE;
 
-  /* ERRORS */
 error_invalid_format:
   {
-    GST_ERROR ("Cannot handle format %s", GST_VIDEO_INFO_FORMAT_STRING (vinfo));
+    GST_ERROR ("Cannot handle format %s",
+        GST_VIDEO_INFO_FORMAT_STRING (&allocator->allocation_info));
     return FALSE;
   }
 error_no_surface:
-- 
2.18.1

