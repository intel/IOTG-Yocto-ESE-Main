From 14f80de094b90d16d57af989d8cb52f90da58b20 Mon Sep 17 00:00:00 2001
From: Haihao Xiang <haihao.xiang@intel.com>
Date: Wed, 12 Feb 2020 14:20:04 +0800
Subject: [PATCH 1/4] Fix VC1 decode output corruption on GEN12

This is a copy of commit 18457ca9

Refer to https://gitlab.freedesktop.org/gstreamer/gstreamer-vaapi/issues/220 for
issue details

Signed-off-by: Haihao Xiang <haihao.xiang@intel.com>
---
 .../codec/hal/codechal_decode_vc1_g12.cpp     | 27 +++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/media_driver/agnostic/gen12/codec/hal/codechal_decode_vc1_g12.cpp b/media_driver/agnostic/gen12/codec/hal/codechal_decode_vc1_g12.cpp
index bd689548..9802e79e 100644
--- a/media_driver/agnostic/gen12/codec/hal/codechal_decode_vc1_g12.cpp
+++ b/media_driver/agnostic/gen12/codec/hal/codechal_decode_vc1_g12.cpp
@@ -527,6 +527,33 @@ MOS_STATUS CodechalDecodeVc1G12::DecodePrimitiveLevelVLD()
             int32_t lLength = slc->slice_data_size >> 3;
             int32_t lOffset = slc->macroblock_offset >> 3;
 
+            CodechalResLock ResourceLock(m_osInterface, &m_resDataBuffer);
+            auto buf = (uint8_t*)ResourceLock.Lock(CodechalResLock::readOnly);
+            buf += slc->slice_data_offset;
+            if (lOffset > 3 && buf != nullptr &&
+                m_vc1PicParams->sequence_fields.AdvancedProfileFlag)
+            {
+                int i = 0;
+                int j = 0;
+                for (i = 0, j = 0; i < lOffset - 1; i++, j++)
+                {
+                    if (!buf[j] && !buf[j + 1] && buf[j + 2] == 3 && buf[j + 3] < 4)
+                    {
+                        i++, j += 2;
+                    }
+                }
+                if (i == lOffset - 1)
+                {
+                    if (!buf[j] && !buf[j + 1] && buf[j + 2] == 3 && buf[j + 3] < 4)
+                    {
+                        buf[j + 2] = 0;
+                        j++;
+                    }
+                    j++;
+                }
+                lOffset = (8 * j + slc->macroblock_offset % 8)>>3;
+            }
+
             // Check that the slice data does not overrun the bitstream buffer size
             if ((slc->slice_data_offset + lLength) > m_dataSize)
             {
-- 
2.17.1

