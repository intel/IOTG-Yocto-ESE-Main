From 09481a11738323474c5803c854d0fd3873025d27 Mon Sep 17 00:00:00 2001
From: tianhaol <tianhao.liu@intel.com>
Date: Thu, 12 Sep 2019 14:29:26 +0800
Subject: [PATCH] [Encode] 2 Add media interface for EHL number 2

Without the specific media interface for EHL,
the corresponding function cannot work.

[Internal]
Platforms: Gen11
OS: Linux
Feature impact: N/A
Related-to:
Resolves: VSMGWL-21956
Klockwork: PASS

Change-Id: I7662a7a1bcd9687e83276ca7bf35cce91bf6bd2a
---
 .../media_interfaces_g11_ehl.cpp              | 482 ++++++++++++++++++
 .../media_interfaces_g11_ehl.h                | 231 +++++++++
 .../media_interfaces_g11_icllp.cpp            |  36 ++
 .../media_interfaces_g11_icllp.h              |   0
 .../media_interfaces/media_srcs.cmake         |   2 +
 5 files changed, 751 insertions(+)
 create mode 100755 media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_ehl.cpp
 create mode 100755 media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_ehl.h
 mode change 100644 => 100755 media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_icllp.cpp
 mode change 100644 => 100755 media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_icllp.h
 mode change 100644 => 100755 media_driver/agnostic/gen11_icllp/media_interfaces/media_srcs.cmake

diff --git a/media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_ehl.cpp b/media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_ehl.cpp
new file mode 100755
index 00000000000..53a34cf6b9e
--- /dev/null
+++ b/media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_ehl.cpp
@@ -0,0 +1,482 @@
+/*
+* Copyright (c) 2019, Intel Corporation
+*
+* Permission is hereby granted, free of charge, to any person obtaining a
+* copy of this software and associated documentation files (the "Software"),
+* to deal in the Software without restriction, including without limitation
+* the rights to use, copy, modify, merge, publish, distribute, sublicense,
+* and/or sell copies of the Software, and to permit persons to whom the
+* Software is furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included
+* in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+* OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+* OTHER DEALINGS IN THE SOFTWARE.
+*/
+//!
+//! \file     media_interfaces_g11_ehl.cpp
+//! \brief    Helps with ehl factory creation.
+//!
+
+#include "media_interfaces_g11_icllp.h"
+#include "media_interfaces_g11_ehl.h"
+#include "codechal_encoder_base.h"
+#include "codechal_debug.h"
+#include "igcodeckrn_g11.h"
+
+extern template class MediaInterfacesFactory<MhwInterfaces>;
+extern template class MediaInterfacesFactory<MmdDevice>;
+extern template class MediaInterfacesFactory<MosUtilDevice>;
+extern template class MediaInterfacesFactory<CodechalDevice>;
+extern template class MediaInterfacesFactory<CMHalDevice>;
+extern template class MediaInterfacesFactory<VphalDevice>;
+extern template class MediaInterfacesFactory<RenderHalDevice>;
+extern template class MediaInterfacesFactory<Nv12ToP010Device>;
+extern template class MediaInterfacesFactory<DecodeHistogramDevice>;
+
+static bool ehlRegisteredVphal =
+MediaInterfacesFactory<VphalDevice>::
+RegisterHal<VphalInterfacesG11Ehl>((uint32_t)IGFX_ELKHARTLAKE);
+
+MOS_STATUS VphalInterfacesG11Ehl::Initialize(
+    PMOS_INTERFACE  osInterface,
+    PMOS_CONTEXT    osDriverContext,
+    MOS_STATUS      *eStatus)
+{
+    m_vphalState = MOS_New(
+        VphalState,
+        osInterface,
+        osDriverContext,
+        eStatus);
+
+    return *eStatus;
+}
+
+static bool ehlRegisteredMhw =
+    MediaInterfacesFactory<MhwInterfaces>::
+    RegisterHal<MhwInterfacesG11Ehl>((uint32_t)IGFX_ELKHARTLAKE);
+
+#define PLATFORM_INTEL_EHL 18  //Tianhao
+#define GENX_ICLLP         10
+
+MOS_STATUS MhwInterfacesG11Ehl::Initialize(
+    CreateParams params,
+    PMOS_INTERFACE osInterface)
+{
+    if (osInterface == nullptr)
+    {
+        MHW_ASSERTMESSAGE("The OS interface is not valid!");
+        return MOS_STATUS_INVALID_PARAMETER;
+    }
+
+    auto gtSystemInfo = osInterface->pfnGetGtSystemInfo(osInterface);
+    if (gtSystemInfo == nullptr)
+    {
+        MHW_ASSERTMESSAGE("The OS interface is not valid!");
+        return MOS_STATUS_INVALID_PARAMETER;
+    }
+
+    if ((params.m_isCp == false) && (params.Flags.m_value == 0))
+    {
+        MHW_ASSERTMESSAGE("No MHW interfaces were requested for creation.");
+        return MOS_STATUS_INVALID_PARAMETER;
+    }
+
+    // MHW_CP and MHW_MI must always be created
+    MOS_STATUS status;
+    m_cpInterface = Create_MhwCpInterface(osInterface);
+    m_miInterface = MOS_New(Mi, m_cpInterface, osInterface);
+
+    if (params.Flags.m_render)
+    {
+        m_renderInterface =
+            MOS_New(Render, m_miInterface, osInterface, gtSystemInfo, params.m_heapMode);
+    }
+    if (params.Flags.m_stateHeap)
+    {
+        m_stateHeapInterface =
+            MOS_New(StateHeap, osInterface, params.m_heapMode);
+    }
+    if (params.Flags.m_sfc)
+    {
+        m_sfcInterface = MOS_New(Sfc, osInterface);
+    }
+    if (params.Flags.m_vebox)
+    {
+        m_veboxInterface = MOS_New(Vebox, osInterface);
+    }
+
+    if (params.Flags.m_vdboxAll || params.Flags.m_mfx)
+    {
+        m_mfxInterface =
+            MOS_New(Mfx, osInterface, m_miInterface, m_cpInterface, params.m_isDecode);
+    }
+    if (params.Flags.m_vdboxAll || params.Flags.m_hcp)
+    {
+        m_hcpInterface =
+            MOS_New(Hcp, osInterface, m_miInterface, m_cpInterface, params.m_isDecode);
+    }
+    if (params.Flags.m_vdboxAll || params.Flags.m_huc)
+    {
+        m_hucInterface = MOS_New(Huc, osInterface, m_miInterface, m_cpInterface);
+    }
+    if (params.Flags.m_vdboxAll || params.Flags.m_vdenc)
+    {
+        m_vdencInterface = MOS_New(Vdenc, osInterface);
+    }
+
+    return MOS_STATUS_SUCCESS;
+}
+
+static bool ehlRegisteredNv12ToP010 =
+    MediaInterfacesFactory<Nv12ToP010Device>::
+    RegisterHal<Nv12ToP010DeviceG11Ehl>((uint32_t)IGFX_ELKHARTLAKE);
+
+MOS_STATUS Nv12ToP010DeviceG11Ehl::Initialize(
+    PMOS_INTERFACE            osInterface)
+{
+    CODECHAL_PUBLIC_ASSERTMESSAGE("Not support Nv12 to P010 interfaces.")
+
+    return MOS_STATUS_INVALID_PARAMETER;
+}
+
+static bool ehlhpRegisteredCodecHal =
+    MediaInterfacesFactory<CodechalDevice>::
+    RegisterHal<CodechalInterfacesG11Ehl>((uint32_t)IGFX_ELKHARTLAKE);
+
+MOS_STATUS CodechalInterfacesG11Ehl::Initialize(
+    void *standardInfo,
+    void *settings,
+    MhwInterfaces *mhwInterfaces,
+    PMOS_INTERFACE osInterface)
+{
+    if (standardInfo    == nullptr ||
+        mhwInterfaces   == nullptr ||
+        osInterface     == nullptr)
+    {
+        CODECHAL_PUBLIC_ASSERTMESSAGE("CodecHal device is not valid!");
+        return MOS_STATUS_INVALID_PARAMETER;
+    }
+    PCODECHAL_STANDARD_INFO info = ((PCODECHAL_STANDARD_INFO)standardInfo);
+    CODECHAL_FUNCTION CodecFunction = info->CodecFunction;
+
+    CodechalHwInterface *hwInterface = MOS_New(Hw, osInterface, CodecFunction, mhwInterfaces);
+
+    if (hwInterface == nullptr)
+    {
+        CODECHAL_PUBLIC_ASSERTMESSAGE("hwInterface is not valid!");
+        return MOS_STATUS_NO_SPACE;
+    }
+#if USE_CODECHAL_DEBUG_TOOL
+    CodechalDebugInterface *debugInterface = MOS_New(CodechalDebugInterface);
+    if (debugInterface == nullptr)
+    {
+        CODECHAL_PUBLIC_ASSERTMESSAGE("debugInterface is not valid!");
+        return MOS_STATUS_NO_SPACE;
+    }
+    if (debugInterface->Initialize(hwInterface, CodecFunction) != MOS_STATUS_SUCCESS)
+    {
+        CODECHAL_PUBLIC_ASSERTMESSAGE("Debug interface creation failed!");
+        return MOS_STATUS_INVALID_PARAMETER;
+    }
+#else
+    CodechalDebugInterface *debugInterface = nullptr;
+#endif // USE_CODECHAL_DEBUG_TOOL
+
+    if (CodecHalIsDecode(CodecFunction))
+    {
+    #ifdef _MPEG2_DECODE_SUPPORTED
+        if (info->Mode == CODECHAL_DECODE_MODE_MPEG2IDCT ||
+            info->Mode == CODECHAL_DECODE_MODE_MPEG2VLD)
+        {
+            m_codechalDevice = MOS_New(Decode::Mpeg2, hwInterface, debugInterface, info);
+        }
+        else
+    #endif
+    #ifdef _VC1_DECODE_SUPPORTED
+        if (info->Mode == CODECHAL_DECODE_MODE_VC1IT ||
+            info->Mode == CODECHAL_DECODE_MODE_VC1VLD)
+        {
+            m_codechalDevice = MOS_New(Decode::Vc1, hwInterface, debugInterface, info);
+        }
+        else
+    #endif
+    #ifdef _AVC_DECODE_SUPPORTED
+        if (info->Mode == CODECHAL_DECODE_MODE_AVCVLD)
+        {
+            m_codechalDevice = MOS_New(Decode::Avc, hwInterface, debugInterface, info);
+
+            if (m_codechalDevice == nullptr)
+            {
+                CODECHAL_PUBLIC_ASSERTMESSAGE("Failed to create decode device!");
+                return MOS_STATUS_NO_SPACE;
+            }
+#ifdef _DECODE_PROCESSING_SUPPORTED
+            if (settings != nullptr && ((CodechalSetting *)settings)->downsamplingHinted)
+            {
+                CodechalDecode *decoder = dynamic_cast<CodechalDecode *>(m_codechalDevice);
+                if (decoder == nullptr)
+                {
+                    CODECHAL_PUBLIC_ASSERTMESSAGE("Failed to create decode device!");
+                    return MOS_STATUS_NO_SPACE;
+                }
+                FieldScalingInterface *fieldScalingInterface =
+                    MOS_New(Decode::FieldScaling, hwInterface);
+                if (fieldScalingInterface == nullptr)
+                {
+                    CODECHAL_PUBLIC_ASSERTMESSAGE("Failed to create field scaling interface!");
+                    return MOS_STATUS_NO_SPACE;
+                }
+                decoder->m_fieldScalingInterface = fieldScalingInterface;
+            }
+#endif
+        }
+        else
+    #endif
+    #ifdef _JPEG_DECODE_SUPPORTED
+        if (info->Mode == CODECHAL_DECODE_MODE_JPEG)
+        {
+            m_codechalDevice = MOS_New(Decode::Jpeg, hwInterface, debugInterface, info);
+        }
+        else
+    #endif
+    #ifdef _VP8_DECODE_SUPPORTED
+        if (info->Mode == CODECHAL_DECODE_MODE_VP8VLD)
+        {
+            m_codechalDevice = MOS_New(Decode::Vp8, hwInterface, debugInterface, info);
+        }
+        else
+    #endif
+    #ifdef _HEVC_DECODE_SUPPORTED
+        if (info->Mode == CODECHAL_DECODE_MODE_HEVCVLD)
+        {
+            m_codechalDevice = MOS_New(Decode::Hevc, hwInterface, debugInterface, info);
+        }
+        else
+    #endif
+    #ifdef _VP9_DECODE_SUPPORTED
+        if (info->Mode == CODECHAL_DECODE_MODE_VP9VLD)
+        {
+            m_codechalDevice = MOS_New(Decode::Vp9, hwInterface, debugInterface, info);
+        }
+        else
+    #endif
+        {
+            CODECHAL_PUBLIC_ASSERTMESSAGE("Decode mode requested invalid!");
+            return MOS_STATUS_INVALID_PARAMETER;
+        }
+
+        if (m_codechalDevice == nullptr)
+        {
+            CODECHAL_PUBLIC_ASSERTMESSAGE("Decoder device creation failed!");
+            return MOS_STATUS_NO_SPACE;
+        }
+    }
+    else if (CodecHalIsEncode(CodecFunction))
+    {
+        CodechalEncoderState *encoder = nullptr;
+#if defined (_AVC_ENCODE_VME_SUPPORTED) || defined (_AVC_ENCODE_VDENC_SUPPORTED)
+        if (info->Mode == CODECHAL_ENCODE_MODE_AVC)
+        {
+            if (CodecHalUsesVdencEngine(info->CodecFunction))
+            {
+            #ifdef _AVC_ENCODE_VDENC_SUPPORTED
+                encoder = MOS_New(Encode::AvcVdenc, hwInterface, debugInterface, info);
+            #endif
+            }
+            if (encoder == nullptr)
+            {
+                CODECHAL_PUBLIC_ASSERTMESSAGE("Encode state creation failed!");
+                return MOS_STATUS_INVALID_PARAMETER;
+            }
+            else
+            {
+                m_codechalDevice = encoder;
+            }
+        }
+        else
+#endif
+#ifdef _VP9_ENCODE_VDENC_SUPPORTED
+        if (info->Mode == CODECHAL_ENCODE_MODE_VP9)
+        {
+            encoder = MOS_New(Encode::Vp9, hwInterface, debugInterface, info);
+            if (encoder == nullptr)
+            {
+                CODECHAL_PUBLIC_ASSERTMESSAGE("Encode state creation failed!");
+                return MOS_STATUS_INVALID_PARAMETER;
+            }
+            else
+            {
+                m_codechalDevice = encoder;
+            }
+
+        }
+        else
+#endif
+#ifdef _JPEG_ENCODE_SUPPORTED
+        if (info->Mode == CODECHAL_ENCODE_MODE_JPEG)
+        {
+            encoder = MOS_New(Encode::Jpeg, hwInterface, debugInterface, info);
+            if (encoder == nullptr)
+            {
+                CODECHAL_PUBLIC_ASSERTMESSAGE("Encode state creation failed!");
+                return MOS_STATUS_INVALID_PARAMETER;
+            }
+            else
+            {
+                m_codechalDevice = encoder;
+            }
+            encoder->m_vdboxOneDefaultUsed = true;
+        }
+        else
+#endif
+#ifdef _HEVC_ENCODE_VDENC_SUPPORTED
+        if (info->Mode == CODECHAL_ENCODE_MODE_HEVC)
+        {
+            if (CodecHalUsesVdencEngine(info->CodecFunction))
+            {
+                encoder = MOS_New(Encode::HevcVdenc, hwInterface, debugInterface, info);
+            }
+            else
+            {
+                return MOS_STATUS_INVALID_PARAMETER;
+            }
+
+            if (encoder == nullptr)
+            {
+                CODECHAL_PUBLIC_ASSERTMESSAGE("Encode state creation failed!");
+                return MOS_STATUS_INVALID_PARAMETER;
+            }
+            else
+            {
+                m_codechalDevice = encoder;
+            }
+
+            encoder->m_kernelBase = (uint8_t*)IGCODECKRN_G11;
+        }
+        else
+#endif
+        {
+            CODECHAL_PUBLIC_ASSERTMESSAGE("Unsupported encode function requested.");
+            return MOS_STATUS_INVALID_PARAMETER;
+        }
+
+        if (info->Mode != CODECHAL_ENCODE_MODE_JPEG)
+        {
+            // Create CSC and Downscaling interface
+            if ((encoder->m_cscDsState = MOS_New(Encode::CscDs, encoder)) == nullptr)
+            {
+                return MOS_STATUS_INVALID_PARAMETER;
+            }
+        }
+    }
+    else
+    {
+        CODECHAL_PUBLIC_ASSERTMESSAGE("Unsupported codec function requested.");
+        return MOS_STATUS_INVALID_PARAMETER;
+    }
+
+    return MOS_STATUS_SUCCESS;
+}
+
+static bool ehlRegisteredCMHal =
+    MediaInterfacesFactory<CMHalDevice>::
+    RegisterHal<CMHalInterfacesG11Ehl>((uint32_t)IGFX_ELKHARTLAKE);
+
+MOS_STATUS CMHalInterfacesG11Ehl::Initialize(CM_HAL_STATE *pCmState)
+{
+    if (pCmState == nullptr)
+    {
+        MHW_ASSERTMESSAGE("pCmState is nullptr.")
+        return MOS_STATUS_INVALID_PARAMETER;
+    }
+
+    m_cmhalDevice = MOS_New(CMHal, pCmState);
+    if (m_cmhalDevice == nullptr)
+    {
+        MHW_ASSERTMESSAGE("Create CM Hal interfaces failed.")
+        return MOS_STATUS_NO_SPACE;
+    }
+
+    m_cmhalDevice->SetGenPlatformInfo(PLATFORM_INTEL_EHL, PLATFORM_INTEL_GT2, "ICLLP");
+    uint32_t cisaID = GENX_ICLLP;
+    m_cmhalDevice->AddSupportedCisaIDs(&cisaID);
+    m_cmhalDevice->SetOverridePowerOptionPerGpuContext(true);
+    m_cmhalDevice->SetDecompressFlag(true);
+    return MOS_STATUS_SUCCESS;
+}
+
+static bool ehlRegisteredMosUtil =
+    MediaInterfacesFactory<MosUtilDevice>::
+    RegisterHal<MosUtilDeviceG11Ehl>((uint32_t)IGFX_ELKHARTLAKE);
+
+MOS_STATUS MosUtilDeviceG11Ehl::Initialize()
+{
+#define MOSUTIL_FAILURE()                                       \
+{                                                           \
+    if (device != nullptr)                                  \
+    {                                                       \
+        delete device;                                      \
+    }                                                       \
+    return MOS_STATUS_NO_SPACE;                             \
+}
+
+    MosUtil *device = nullptr;
+
+    device = MOS_New(MosUtil);
+
+    if (device == nullptr)
+    {
+        MOSUTIL_FAILURE();
+    }
+
+    if (device->Initialize() != MOS_STATUS_SUCCESS)
+    {
+        MOSUTIL_FAILURE();
+    }
+
+    m_mosUtilDevice = device;
+
+    return MOS_STATUS_SUCCESS;
+}
+
+static bool ehlRegisteredRenderHal =
+    MediaInterfacesFactory<RenderHalDevice>::
+    RegisterHal<RenderHalInterfacesG11Ehl>((uint32_t)IGFX_ELKHARTLAKE);
+
+MOS_STATUS RenderHalInterfacesG11Ehl::Initialize()
+{
+    m_renderhalDevice = MOS_New(XRenderHal);
+    if (m_renderhalDevice == nullptr)
+    {
+        MHW_ASSERTMESSAGE("Create Render Hal interfaces failed.")
+        return MOS_STATUS_NO_SPACE;
+    }
+    return MOS_STATUS_SUCCESS;
+}
+
+static bool ehlRegisteredDecodeHistogram =
+MediaInterfacesFactory<DecodeHistogramDevice>::
+RegisterHal<DecodeHistogramDeviceG11Ehl>((uint32_t)IGFX_ELKHARTLAKE);
+
+MOS_STATUS DecodeHistogramDeviceG11Ehl::Initialize(
+    CodechalHwInterface       *hwInterface,
+    PMOS_INTERFACE            osInterface)
+{
+    m_decodeHistogramDevice = MOS_New(DecodeHistogramVebox, hwInterface, osInterface);
+
+    if (m_decodeHistogramDevice == nullptr)
+    {
+        MHW_ASSERTMESSAGE("Create vebox decode histogram  interfaces failed.")
+            return MOS_STATUS_NO_SPACE;
+    }
+
+    return MOS_STATUS_SUCCESS;
+}
+
diff --git a/media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_ehl.h b/media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_ehl.h
new file mode 100755
index 00000000000..c47e7be01cf
--- /dev/null
+++ b/media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_ehl.h
@@ -0,0 +1,231 @@
+/*
+* Copyright (c) 2019, Intel Corporation
+*
+* Permission is hereby granted, free of charge, to any person obtaining a
+* copy of this software and associated documentation files (the "Software"),
+* to deal in the Software without restriction, including without limitation
+* the rights to use, copy, modify, merge, publish, distribute, sublicense,
+* and/or sell copies of the Software, and to permit persons to whom the
+* Software is furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included
+* in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+* OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+* OTHER DEALINGS IN THE SOFTWARE.
+*/
+//!
+//! \file     media_interfaces_g11_ehl.h
+//! \brief    All interfaces used for EHL that require factory creation
+//!
+
+#ifndef __MEDIA_INTERFACES_G11_EHL_H__
+#define __MEDIA_INTERFACES_G11_EHL_H__
+
+#include "media_interfaces_mhw.h"
+#include "media_interfaces_codechal.h"
+#include "media_interfaces_mmd.h"
+#include "media_interfaces_cmhal.h"
+#include "media_interfaces_mosutil.h"
+#include "media_interfaces_vphal.h"
+#include "media_interfaces_renderhal.h"
+#include "media_interfaces_nv12top010.h"
+#include "media_interfaces_decode_histogram.h"
+
+#include "mhw_cp_interface.h"
+#include "mhw_mi_g11_X.h"
+#include "mhw_render_g11_X.h"
+#include "mhw_sfc_g11_X.h"
+#include "mhw_state_heap_g11.h"
+#include "mhw_vebox_g11_X.h"
+#include "mhw_vdbox_mfx_g11_X.h"
+#include "mhw_vdbox_hcp_g11_X.h"
+#include "mhw_vdbox_huc_g11_X.h"
+#include "mhw_vdbox_vdenc_g11_X.h"
+
+#include "codechal_hw_g11_X.h"
+
+#ifdef _AVC_DECODE_SUPPORTED
+#include "codechal_decode_avc_g11.h"
+#endif
+
+#include "codechal_decode_downsampling_g11_icllp.h"
+
+#ifdef _HEVC_DECODE_SUPPORTED
+#include "codechal_decode_hevc_g11.h"
+#endif
+
+#ifdef _JPEG_DECODE_SUPPORTED
+#include "codechal_decode_jpeg_g11.h"
+#endif
+
+#ifdef _MPEG2_DECODE_SUPPORTED
+#include "codechal_decode_mpeg2_g11.h"
+#endif
+
+#ifdef _VC1_DECODE_SUPPORTED
+#include "codechal_decode_vc1_g11.h"
+#endif
+
+#ifdef _VP8_DECODE_SUPPORTED
+#include "codechal_decode_vp8_g11.h"
+#endif
+
+#ifdef _VP9_DECODE_SUPPORTED
+#include "codechal_decode_vp9_g11.h"
+#endif
+
+#include "codechal_encode_sfc.h"
+#include "codechal_encode_csc_ds_g11.h"
+
+#ifdef _VP9_ENCODE_VDENC_SUPPORTED
+#include "codechal_vdenc_vp9_g11.h"
+#endif
+
+#ifdef _VP9_ENCODE_VDENC_SUPPORTED
+#include "codechal_vdenc_vp9_g11.h"
+#endif
+
+#include "cm_hal_g11.h"
+#include "mos_util_user_interface.h"
+#include "vphal_g11_icllp.h"
+#include "renderhal_g11.h"
+
+
+class MhwInterfacesG11Ehl : public MhwInterfaces
+{
+public:
+    using Mi = MhwMiInterfaceG11;
+    using Cp = MhwCpInterface;
+    using Render = MhwRenderInterfaceG11;
+    using Sfc = MhwSfcInterfaceG11;
+    using StateHeap = MHW_STATE_HEAP_INTERFACE_G11_X;
+    using Mfx = MhwVdboxMfxInterfaceG11;
+    using Hcp = MhwVdboxHcpInterfaceG11;
+    using Huc = MhwVdboxHucInterfaceG11;
+    using Vdenc = MhwVdboxVdencInterfaceG11<mhw_vdbox_vdenc_g11_X>;
+    using Vebox = MhwVeboxInterfaceG11;
+
+    MOS_STATUS Initialize(
+        CreateParams params,
+        PMOS_INTERFACE osInterface);
+};
+
+class Nv12ToP010DeviceG11Ehl : public Nv12ToP010Device
+{
+public:
+
+    MOS_STATUS Initialize(
+        PMOS_INTERFACE osInterface);
+};
+
+class CodechalDecodeInterfacesG11Ehl
+{
+public:
+#ifdef _AVC_DECODE_SUPPORTED
+    using Avc = CodechalDecodeAvcG11;
+#endif
+#ifdef _HEVC_DECODE_SUPPORTED
+    using Hevc = CodechalDecodeHevcG11;
+#endif
+#ifdef _JPEG_DECODE_SUPPORTED
+    using Jpeg = CodechalDecodeJpegG11;
+#endif
+#ifdef _MPEG2_DECODE_SUPPORTED
+    using Mpeg2 = CodechalDecodeMpeg2G11;
+#endif
+#ifdef _VC1_DECODE_SUPPORTED
+    using Vc1 = CodechalDecodeVc1G11;
+#endif
+#ifdef _VP8_DECODE_SUPPORTED
+    using Vp8 = CodechalDecodeVp8G11;
+#endif
+#ifdef _VP9_DECODE_SUPPORTED
+    using Vp9 = CodechalDecodeVp9G11;
+#endif
+#ifdef _DECODE_PROCESSING_SUPPORTED
+    using FieldScaling = FieldScalingInterfaceG11IclLp;
+#endif
+};
+
+class CodechalEncodeInterfacesG11Ehl
+{
+public:
+#ifdef _AVC_ENCODE_VDENC_SUPPORTED
+    using AvcVdenc = CodechalVdencAvcStateG11;
+#endif
+    using CscDs = CodechalEncodeCscDsG11;
+#ifdef _VP9_ENCODE_VDENC_SUPPORTED
+    using Vp9 = CodechalVdencVp9StateG11;
+#endif
+#ifdef _JPEG_ENCODE_SUPPORTED
+    using Jpeg = CodechalEncodeJpegState;
+#endif
+#ifdef _HEVC_ENCODE_VDENC_SUPPORTED
+    using HevcVdenc = CodechalVdencHevcStateG11;
+#endif
+};
+
+class CodechalInterfacesG11Ehl : public CodechalDevice
+{
+public:
+    using Decode = CodechalDecodeInterfacesG11Ehl;
+    using Hw = CodechalHwInterfaceG11;
+    using Encode = CodechalEncodeInterfacesG11Ehl;
+
+    MOS_STATUS Initialize(
+        void *standardInfo,
+        void *settings,
+        MhwInterfaces *mhwInterfaces,
+        PMOS_INTERFACE osInterface) override;
+};
+
+class CMHalInterfacesG11Ehl : public CMHalDevice
+{
+protected:
+    using CMHal = CM_HAL_G11_X;
+    MOS_STATUS Initialize(
+        CM_HAL_STATE *pCmState);
+};
+
+class MosUtilDeviceG11Ehl : public MosUtilDevice
+{
+public:
+    using MosUtil = MosUtilUserInterface;
+
+    MOS_STATUS Initialize();
+};
+class VphalInterfacesG11Ehl : public VphalDevice
+{
+public:
+    using VphalState = VphalStateG11Icllp;
+
+    MOS_STATUS Initialize(
+        PMOS_INTERFACE  osInterface,
+        PMOS_CONTEXT    osDriverContext,
+        MOS_STATUS      *eStatus);
+};
+
+class RenderHalInterfacesG11Ehl : public RenderHalDevice
+{
+protected:
+    using XRenderHal = XRenderHal_Interface_g11;
+    MOS_STATUS Initialize();
+};
+
+class DecodeHistogramDeviceG11Ehl : public DecodeHistogramDevice
+{
+public:
+    using DecodeHistogramVebox = CodechalDecodeHistogramVeboxG11;
+
+    MOS_STATUS Initialize(
+        CodechalHwInterface *hwInterface,
+        PMOS_INTERFACE osInterface);
+};
+
+#endif // __MEDIA_INTERFACES_G11_EHL_H__
diff --git a/media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_icllp.cpp b/media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_icllp.cpp
old mode 100644
new mode 100755
index dd44c6a5369..574f348c285
--- a/media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_icllp.cpp
+++ b/media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_icllp.cpp
@@ -702,3 +702,39 @@ MOS_STATUS DecodeHistogramDeviceG11Icllp::Initialize(
     return MOS_STATUS_SUCCESS;
 }
 
+static bool ehlRegisteredVphal =
+      MediaInterfacesFactory<VphalDevice>::
+      RegisterHal<VphalInterfacesG11Icllp>((uint32_t)IGFX_ELKHARTLAKE);
+
+static bool ehlRegisteredMhw =
+    MediaInterfacesFactory<MhwInterfaces>::
+    RegisterHal<MhwInterfacesG11Icllp>((uint32_t)IGFX_ELKHARTLAKE);
+
+static bool ehlRegisteredMmd =
+    MediaInterfacesFactory<MmdDevice>::
+    RegisterHal<MmdDeviceG11Icllp>((uint32_t)IGFX_ELKHARTLAKE);
+
+static bool ehlRegisteredNv12ToP010 =
+    MediaInterfacesFactory<Nv12ToP010Device>::
+    RegisterHal<Nv12ToP010DeviceG11Icllp>((uint32_t)IGFX_ELKHARTLAKE);
+
+static bool ehlhpRegisteredCodecHal =
+    MediaInterfacesFactory<CodechalDevice>::
+    RegisterHal<CodechalInterfacesG11Icllp>((uint32_t)IGFX_ELKHARTLAKE);
+
+static bool ehlRegisteredCMHal =
+    MediaInterfacesFactory<CMHalDevice>::
+    RegisterHal<CMHalInterfacesG11Icllp>((uint32_t)IGFX_ELKHARTLAKE);
+
+static bool ehlRegisteredMosUtil =
+    MediaInterfacesFactory<MosUtilDevice>::
+    RegisterHal<MosUtilDeviceG11Icllp>((uint32_t)IGFX_ELKHARTLAKE);
+
+static bool ehlRegisteredRenderHal =
+    MediaInterfacesFactory<RenderHalDevice>::
+    RegisterHal<RenderHalInterfacesG11Icllp>((uint32_t)IGFX_ELKHARTLAKE);
+
+static bool ehlRegisteredDecodeHistogram =
+    MediaInterfacesFactory<DecodeHistogramDevice>::
+    RegisterHal<DecodeHistogramDeviceG11Icllp>((uint32_t)IGFX_ELKHARTLAKE);
+
diff --git a/media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_icllp.h b/media_driver/agnostic/gen11_icllp/media_interfaces/media_interfaces_g11_icllp.h
old mode 100644
new mode 100755
diff --git a/media_driver/agnostic/gen11_icllp/media_interfaces/media_srcs.cmake b/media_driver/agnostic/gen11_icllp/media_interfaces/media_srcs.cmake
old mode 100644
new mode 100755
index 45be1aa009c..c62177920c6
--- a/media_driver/agnostic/gen11_icllp/media_interfaces/media_srcs.cmake
+++ b/media_driver/agnostic/gen11_icllp/media_interfaces/media_srcs.cmake
@@ -20,10 +20,12 @@
 
 set(TMP_SOURCES_
     ${CMAKE_CURRENT_LIST_DIR}/media_interfaces_g11_icllp.cpp
+    ${CMAKE_CURRENT_LIST_DIR}/media_interfaces_g11_ehl.cpp
 )
 
 set(TMP_HEADERS_
     ${CMAKE_CURRENT_LIST_DIR}/media_interfaces_g11_icllp.h
+    ${CMAKE_CURRENT_LIST_DIR}/media_interfaces_g11_ehl.h
 )
 
 set(SOURCES_
-- 
2.23.0

