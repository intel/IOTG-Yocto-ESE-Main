From e4883c33197a35eef3273724255b58a6a857b46e Mon Sep 17 00:00:00 2001
From: qiwenX <qix.wen@intel.com>
Date: Mon, 22 Apr 2019 10:28:01 +0800
Subject: [PATCH 1/2] Fix for Kclockwork scan and fix one possible crash

    1,Fix some potential problems
    2,Fix one crash.

Signed-off-by: qiwenX <qix.wen@intel.com>
---
 COPYING                            |    0
 Makefile                           |   23 +
 commonfunc/commonfunc.c            |  136 +++++
 commonfunc/commonfunc.h            |  135 +++++
 inc.mak                            |   84 +++
 onvif_server.c                     |  133 +++++
 server_interface/analyticsdevice.c |   76 +++
 server_interface/device.c          | 1066 ++++++++++++++++++++++++++++++++++++
 server_interface/deviceIO.c        |  148 +++++
 server_interface/discovery.c       |  247 +++++++++
 server_interface/display.c         |   62 +++
 server_interface/imaging.c         |  349 ++++++++++++
 server_interface/media.c           | 1057 +++++++++++++++++++++++++++++++++++
 server_interface/ptz.c             |   99 ++++
 server_interface/receiver.c        |   58 ++
 server_interface/recording.c       |   84 +++
 server_interface/replay.c          |   50 ++
 server_interface/search.c          |   70 +++
 utils/mpapi.c                      |  523 ++++++++++++++++++
 utils/mpapi.h                      |   63 +++
 20 files changed, 4463 insertions(+)
 create mode 100644 COPYING
 create mode 100644 Makefile
 create mode 100755 commonfunc/commonfunc.c
 create mode 100755 commonfunc/commonfunc.h
 create mode 100644 inc.mak
 create mode 100755 onvif_server.c
 create mode 100644 server_interface/analyticsdevice.c
 create mode 100644 server_interface/device.c
 create mode 100644 server_interface/deviceIO.c
 create mode 100755 server_interface/discovery.c
 create mode 100644 server_interface/display.c
 create mode 100644 server_interface/imaging.c
 create mode 100755 server_interface/media.c
 create mode 100644 server_interface/ptz.c
 create mode 100644 server_interface/receiver.c
 create mode 100644 server_interface/recording.c
 create mode 100644 server_interface/replay.c
 create mode 100644 server_interface/search.c
 create mode 100644 utils/mpapi.c
 create mode 100644 utils/mpapi.h

diff --git a/COPYING b/COPYING
new file mode 100644
index 0000000..e69de29
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..eeeb088
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,23 @@
+#project name
+TARGET_NAME = server_onvif
+
+# project type "so", "a", ""
+TARGET_SUFFIX = 
+
+# project version
+VER_MAJOR = 1
+VER_MINOR = 0
+
+# project dir
+PROJECT_DIR = $(shell pwd)
+
+# output path
+OUT_DIR = $(PROJECT_DIR)
+
+# find code
+CFILES   = $(shell find $(PROJECT_DIR) -name "*.c" -print)
+
+# source code
+SRCS   = $(CFILES)
+
+include $(PROJECT_DIR)/inc.mak
diff --git a/commonfunc/commonfunc.c b/commonfunc/commonfunc.c
new file mode 100755
index 0000000..f578ac4
--- /dev/null
+++ b/commonfunc/commonfunc.c
@@ -0,0 +1,136 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include "commonfunc.h"
+
+static void get_local_net_name(char *szCardName);
+
+void fprintflog(int level, const char* pFunName,int pLine,const char* fmt, ...){
+    va_list args;
+    va_start(args, fmt);
+    switch(level)
+    {
+        case DBG:
+            {
+                 printf("[DEBUG][%s][%d]",pFunName,pLine);
+                 vprintf(fmt, args);
+                 break;
+            }
+        case INFO:
+            {
+                 printf("[INFO][%s][%d]",pFunName,pLine);
+                 vprintf(fmt, args);
+                 break;
+            }
+        case WARN:
+            {
+                 printf("[WARN][%s][%d]",pFunName,pLine);
+                 vprintf(fmt, args);
+                 break;
+            }
+        case ERROR:
+            {
+                 printf("[ERROR][%s][%d]",pFunName,pLine);
+                 vprintf(fmt, args);
+                 break;
+            }
+        default:
+            {
+                 vprintf(fmt, args);
+                 break;
+            }
+    };
+    va_end(args);
+    return;
+}
+
+/*int onvif_receiver_fault_subcode_oom(struct soap *soap)
+{
+    return soap_receiver_fault_subcode(soap, "ter:OutofMemory", "Out of Memory", "The device does not have sufficient memory to complete the action.");
+}*/
+
+static void get_local_net_name(char *szCardName)
+{
+    FILE *f = NULL;
+    char line[100], *p, *c;
+    f = fopen("/proc/net/route" ,"r");
+    if (NULL == f)
+    {
+        LOG(ERROR, "failed to open file!\n");
+        return;
+    }
+    while(fgets(line, 100, f)) {
+        p = strtok(line, " \t");
+        c = strtok(NULL, " \t");
+
+        if(p != NULL && c != NULL)
+        {
+            if(strcmp(c, "00000000") == 0)
+            {
+                strcpy(szCardName,p);
+                break;
+            }
+        }
+    }
+    fclose(f);
+    return;
+}
+
+const char*  get_local_ip()
+{
+    struct sockaddr_in *sin;
+    struct ifreq ifr_ip;
+    int sock_fd;
+    static char szLocalIp[128];
+    char szCardName[30] = {'\0'};
+    if ((sock_fd = socket( AF_INET, SOCK_DGRAM, 0)) >= 0 ) {
+        LOG(INFO,"sock_fd = %d\n",sock_fd);
+        memset (&ifr_ip, 0, sizeof(ifr_ip));
+        get_local_net_name(szCardName);
+        strncpy (ifr_ip.ifr_name, szCardName, sizeof(ifr_ip.ifr_name) - 1);
+        if( ioctl( sock_fd, SIOCGIFADDR, &ifr_ip) >= 0 ) {
+            sin = (struct sockaddr_in *) &ifr_ip.ifr_addr;
+            strncpy(szLocalIp, inet_ntoa(sin->sin_addr), 128);
+        }
+        close(sock_fd);
+    }
+    return szLocalIp;
+}
\ No newline at end of file
diff --git a/commonfunc/commonfunc.h b/commonfunc/commonfunc.h
new file mode 100755
index 0000000..cb7a2ac
--- /dev/null
+++ b/commonfunc/commonfunc.h
@@ -0,0 +1,135 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#ifndef COMMONFUNC_H_
+#define COMMONFUNC_H_
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/vfs.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <net/if.h>
+#include <net/route.h>
+#include <netdb.h>
+#include <arpa/inet.h>
+#include <ifaddrs.h>
+#include <time.h>
+#include <json-c/json.h>
+#include <stdarg.h>
+#include "../gsoap/soapH.h"
+
+#define SHORT_LENGTH 64
+#define INFO_LENGTH 256
+#define SMALL_INFO_LENGTH 512
+#define LARGE_INFO_LENGTH 1024
+#define MAX_PROF_TOKEN 1024
+
+#define ONVIF_SERVER_CALL()    LOG(INFO,"onvifs: call %s, path=%s\r\n", __FUNCTION__, soap->path)
+#define ONVIF_NOTSUPPORTED_FUNC(soap, namespaces)   \
+    ONVIF_SERVER_CALL();    \
+    if(namespaces!=NULL) soap_set_namespaces(soap, namespaces);  \
+    return soap_receiver_fault_subcode(soap, "ter:ActionNotSupported", "Optional Action Not Implemented ", "The requested action is optional and is not implemented by the device.");
+#define  LOG(enum1,fmt, ...)             fprintflog(enum1,__FUNCTION__, __LINE__,fmt,##__VA_ARGS__)
+
+enum RESULT
+{
+    RET_SUCESS = 0,
+    RET_FAILED = -1
+};
+
+typedef struct ImagingSetting{
+     int brightness;
+     int colorsaturation;
+     int contrast;
+     int sharpness;
+     int exposuretime;
+     int exposuremode;
+     int irismode;
+     int irislevel;
+ }ImagingSetting;
+
+typedef struct VideoEncoderConfiguration{
+     char Encoder[20];
+     char bitratemode[20];
+     int  bitrate;
+     int  framerate;
+     int  width;
+     int  height;
+     float  quality;
+     int govlen;
+}VideoEncoderConfiguration;
+
+typedef struct Options{
+        int brightness_min;
+        int brightness_max;
+        int colorsaturation_min;
+        int colorsaturation_max;
+        int contrast_min;
+        int contrast_max;
+        int sharpness_min;
+        int sharpness_max;
+        int exposuretime_min;
+        int exposuretime_max;
+        int iris_min;
+        int iris_max;
+}Options;
+
+enum loglevel
+{
+    DBG =0,
+    INFO,
+    WARN,
+    ERROR,
+};
+
+void fprintflog(int level, const char* pFunName,int pLine,const char* fmt, ...);
+
+const char*  get_local_ip();
+
+
+#endif
diff --git a/inc.mak b/inc.mak
new file mode 100644
index 0000000..08eb1eb
--- /dev/null
+++ b/inc.mak
@@ -0,0 +1,84 @@
+
+#public include dir
+PUB_INC ?= 
+
+#project include dir
+PROJECT_INC ?=-I$(PROJECT_DIR)/include
+
+#public library dir
+PUB_LIB_PATH ?= -L/usr/local/lib
+
+PUB_LIB ?=  -ljson-c -lpthread
+
+PUB_MACROS = -D_ALL_SOURCE
+
+# default dir
+SOURCE_DIR ?= $(PROJECT_DIR)
+
+#solution dir
+SLN_DIR ?= $(PROJECT_DIR)/build
+
+RELEASE ?= 1
+CXX = g++
+LD  = $(CC)
+
+RM = /bin/rm
+CP = /bin/cp
+MKDIR = /bin/mkdir
+
+#CFLAGS ?= -Wall -Wno-deprecated
+PUB_MACROS += -D__GNU_GCC__=__GNUC__
+
+ifeq ($(shell echo $(RELEASE) | tr a-z A-Z),TRUE)
+#CFLAGS += -O2
+PUB_MACROS += -D_NDEBUG=1
+else
+  ifneq ($(RELEASE),1)
+    CFLAGS += -g -DDEBUG
+    PUB_MACROS += -D_DEBUG_=1
+  else
+#    CFLAGS += -O2
+    PUB_MACROS += -D_NDEBUG=1
+  endif
+endif
+
+
+ifeq ($(TARGET_SUFFIX),)
+TARGET_PREFIX :=
+endif
+
+ifneq ($(TARGET_SUFFIX),)
+TARGET = $(TARGET_PREFIX)$(TARGET_NAME).$(TARGET_SUFFIX)
+else
+TARGET = $(TARGET_NAME)
+endif
+
+INCLUDE =  $(PROJECT_INC) $(PUB_INC)
+LIBRARY =  $(PROJECT_LIB_PATH) $(PUB_LIB_PATH)  $(PROJECT_LIB) $(PUB_LIB)
+MACROS = $(PUB_MACROS) $(PROJECT_MACROS)
+
+TMP   = $(subst .cpp,.o,$(SRCS))
+OBJS   = $(subst .c,.o,$(TMP))
+#DFILES = $(subst .o,.d,$(OBJS))
+
+all :   $(TARGET)
+
+%.o : %.c
+	$(CC) $(MACROS) $(INCLUDE) $(CFLAGS) -Wall -o $@ -c $<
+
+$(TARGET) :   $(OBJS)
+
+ifeq ($(TARGET_SUFFIX),)
+        #@echo "===================  Link executeable file $@ ======================="
+	$(LD) $(OBJS) $(LDFLAGS) $(LIBRARY) -o $(OUT_DIR)/$@
+endif
+
+
+
+clean :
+	-$(RM) -f $(OBJS)
+	-$(RM) -f $(OUT_DIR)/$(TARGET)
+
+
+
+
diff --git a/onvif_server.c b/onvif_server.c
new file mode 100755
index 0000000..77c5ca4
--- /dev/null
+++ b/onvif_server.c
@@ -0,0 +1,133 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include <pthread.h>
+#include "commonfunc/commonfunc.h"
+#include "gsoap/nsmap.h"
+
+#define ONVIF_UDP_PORT  3702
+#define ONVIF_HTTP_PORT 80
+#define IP_LENGTH 64
+
+static void* udp_server(void* param)
+{
+    LOG(INFO,"start !\n");
+
+    int count = 0;
+    struct soap ServerSoap;
+    struct ip_mreq mcast;
+
+    soap_init1(&ServerSoap, SOAP_IO_UDP | SOAP_XML_IGNORENS);
+    soap_set_namespaces(&ServerSoap,  namespaces);
+
+    LOG(INFO,"ServerSoap.version = %d \n", ServerSoap.version);
+
+    if(!soap_valid_socket(soap_bind(&ServerSoap, NULL, ONVIF_UDP_PORT, 10)))
+    {
+        soap_print_fault(&ServerSoap, stderr);
+        exit(1);
+    }
+
+    mcast.imr_multiaddr.s_addr = inet_addr("239.255.255.250");
+    mcast.imr_interface.s_addr = htonl(INADDR_ANY);
+
+    if(setsockopt(ServerSoap.master, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*)&mcast, sizeof(mcast)) < 0)
+    {
+        LOG(ERROR,"setsockopt error! error code = %d,err string = %s\n",errno,strerror(errno));
+        exit(1);
+    }
+
+    while (1)
+    {
+        if (!soap_valid_socket(soap_accept(&ServerSoap)))
+        {
+            soap_print_fault(&ServerSoap, stderr);
+            exit(1);
+        }
+        if (soap_serve(&ServerSoap))
+        {
+            soap_print_fault(&ServerSoap, stderr);
+        }
+
+        soap_end(&ServerSoap);
+
+        LOG(INFO, "RECEIVE count %d, connection from IP = %lu.%lu.%lu.%lu socket = %d \r\n",
+            count, ((ServerSoap.ip) >> 24) & 0xFF, ((ServerSoap.ip) >> 16) & 0xFF, ((ServerSoap.ip) >> 8) & 0xFF, (ServerSoap.ip) & 0xFF, (ServerSoap.socket));
+        count++;
+    }
+
+    soap_done(&ServerSoap);
+}
+
+int main(int argc,char ** argv)
+{
+    struct soap soap;
+    int s, m;
+    pthread_t pid;
+
+    pthread_create(&pid, NULL, udp_server, NULL);
+    soap_init(&soap);
+    soap_set_namespaces(&soap, namespaces);
+    soap.bind_flags = SO_REUSEADDR;
+    m = soap_bind(&soap, NULL, ONVIF_HTTP_PORT, 100);
+    if (!soap_valid_socket(m)){
+        soap_print_fault(&soap, stderr);
+        exit(-1);
+    }else{
+        LOG(INFO,"Start accept...\n");
+        while(1){
+            s = soap_accept(&soap);
+            if(!soap_valid_socket(s)){
+                if(soap.errnum)
+                    soap_print_fault(&soap, stderr);
+                else
+                    fprintf(stderr,"Server timed out (see code how to change this)\n");
+                break;
+            }
+            if(soap_serve(&soap)){
+                soap_print_fault(&soap, stderr);
+            }
+            soap_end(&soap);
+        }
+    }
+    soap_done(&soap);
+    return 0;
+}
diff --git a/server_interface/analyticsdevice.c b/server_interface/analyticsdevice.c
new file mode 100644
index 0000000..1efff2d
--- /dev/null
+++ b/server_interface/analyticsdevice.c
@@ -0,0 +1,76 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include "../utils/mpapi.h"
+/** Web service operation '__tad__GetServiceCapabilities' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__GetServiceCapabilities(struct soap* soap, struct _tad__GetServiceCapabilities *tad__GetServiceCapabilities, struct _tad__GetServiceCapabilitiesResponse *tad__GetServiceCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__DeleteAnalyticsEngineControl' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__DeleteAnalyticsEngineControl(struct soap* soap, struct _tad__DeleteAnalyticsEngineControl *tad__DeleteAnalyticsEngineControl, struct _tad__DeleteAnalyticsEngineControlResponse *tad__DeleteAnalyticsEngineControlResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__CreateAnalyticsEngineControl' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__CreateAnalyticsEngineControl(struct soap* soap, struct _tad__CreateAnalyticsEngineControl *tad__CreateAnalyticsEngineControl, struct _tad__CreateAnalyticsEngineControlResponse *tad__CreateAnalyticsEngineControlResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__SetAnalyticsEngineControl' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__SetAnalyticsEngineControl(struct soap* soap, struct _tad__SetAnalyticsEngineControl *tad__SetAnalyticsEngineControl, struct _tad__SetAnalyticsEngineControlResponse *tad__SetAnalyticsEngineControlResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__GetAnalyticsEngineControl' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsEngineControl(struct soap* soap, struct _tad__GetAnalyticsEngineControl *tad__GetAnalyticsEngineControl, struct _tad__GetAnalyticsEngineControlResponse *tad__GetAnalyticsEngineControlResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__GetAnalyticsEngineControls' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsEngineControls(struct soap* soap, struct _tad__GetAnalyticsEngineControls *tad__GetAnalyticsEngineControls, struct _tad__GetAnalyticsEngineControlsResponse *tad__GetAnalyticsEngineControlsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__GetAnalyticsEngine' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsEngine(struct soap* soap, struct _tad__GetAnalyticsEngine *tad__GetAnalyticsEngine, struct _tad__GetAnalyticsEngineResponse *tad__GetAnalyticsEngineResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__GetAnalyticsEngines' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsEngines(struct soap* soap, struct _tad__GetAnalyticsEngines *tad__GetAnalyticsEngines, struct _tad__GetAnalyticsEnginesResponse *tad__GetAnalyticsEnginesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__SetVideoAnalyticsConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__SetVideoAnalyticsConfiguration(struct soap* soap, struct _tad__SetVideoAnalyticsConfiguration *tad__SetVideoAnalyticsConfiguration, struct _tad__SetVideoAnalyticsConfigurationResponse *tad__SetVideoAnalyticsConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__SetAnalyticsEngineInput' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__SetAnalyticsEngineInput(struct soap* soap, struct _tad__SetAnalyticsEngineInput *tad__SetAnalyticsEngineInput, struct _tad__SetAnalyticsEngineInputResponse *tad__SetAnalyticsEngineInputResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__GetAnalyticsEngineInput' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsEngineInput(struct soap* soap, struct _tad__GetAnalyticsEngineInput *tad__GetAnalyticsEngineInput, struct _tad__GetAnalyticsEngineInputResponse *tad__GetAnalyticsEngineInputResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__GetAnalyticsEngineInputs' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsEngineInputs(struct soap* soap, struct _tad__GetAnalyticsEngineInputs *tad__GetAnalyticsEngineInputs, struct _tad__GetAnalyticsEngineInputsResponse *tad__GetAnalyticsEngineInputsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__GetAnalyticsDeviceStreamUri' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsDeviceStreamUri(struct soap* soap, struct _tad__GetAnalyticsDeviceStreamUri *tad__GetAnalyticsDeviceStreamUri, struct _tad__GetAnalyticsDeviceStreamUriResponse *tad__GetAnalyticsDeviceStreamUriResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__GetVideoAnalyticsConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__GetVideoAnalyticsConfiguration(struct soap* soap, struct _tad__GetVideoAnalyticsConfiguration *tad__GetVideoAnalyticsConfiguration, struct _tad__GetVideoAnalyticsConfigurationResponse *tad__GetVideoAnalyticsConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__CreateAnalyticsEngineInputs' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__CreateAnalyticsEngineInputs(struct soap* soap, struct _tad__CreateAnalyticsEngineInputs *tad__CreateAnalyticsEngineInputs, struct _tad__CreateAnalyticsEngineInputsResponse *tad__CreateAnalyticsEngineInputsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__DeleteAnalyticsEngineInputs' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__DeleteAnalyticsEngineInputs(struct soap* soap, struct _tad__DeleteAnalyticsEngineInputs *tad__DeleteAnalyticsEngineInputs, struct _tad__DeleteAnalyticsEngineInputsResponse *tad__DeleteAnalyticsEngineInputsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tad__GetAnalyticsState' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsState(struct soap* soap, struct _tad__GetAnalyticsState *tad__GetAnalyticsState, struct _tad__GetAnalyticsStateResponse *tad__GetAnalyticsStateResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
diff --git a/server_interface/device.c b/server_interface/device.c
new file mode 100644
index 0000000..dc716f5
--- /dev/null
+++ b/server_interface/device.c
@@ -0,0 +1,1066 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include "../utils/mpapi.h"
+
+static char szLocalIp[128];
+static char* pLocalIp = szLocalIp;
+/** Web service operation '__tds__GetServices' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetServices(struct soap* soap, struct _tds__GetServices *tds__GetServices, struct _tds__GetServicesResponse *tds__GetServicesResponse)
+{
+    LOG(INFO,"start !\n");
+
+    tds__GetServicesResponse->__sizeService = 7;
+    if (szLocalIp[0] == 0)
+    {
+        strncpy(szLocalIp, get_local_ip(), 128);
+    }
+    if((tds__GetServicesResponse->Service = (struct tds__Service*)soap_malloc(soap, sizeof(struct tds__Service)*(tds__GetServicesResponse->__sizeService))))
+    {
+        if((tds__GetServicesResponse->Service[0].Namespace = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            strcpy(tds__GetServicesResponse->Service[0].Namespace, "http://www.onvif.org/ver10/device/wsdl");
+        if((tds__GetServicesResponse->Service[0].XAddr = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            sprintf(tds__GetServicesResponse->Service[0].XAddr,"http://%s/onvif/device_service",pLocalIp);
+        if((tds__GetServicesResponse->Service[0].Version = (struct tt__OnvifVersion*)soap_malloc(soap, sizeof(struct tt__OnvifVersion))))
+        {
+            tds__GetServicesResponse->Service[0].Version->Major = 1;
+            tds__GetServicesResponse->Service[0].Version->Minor = 0;
+        }
+
+        if((tds__GetServicesResponse->Service[1].Namespace = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            strcpy(tds__GetServicesResponse->Service[1].Namespace, "http://www.onvif.org/ver20/analytics/wsdl");
+        if((tds__GetServicesResponse->Service[1].XAddr = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            sprintf(tds__GetServicesResponse->Service[1].XAddr,"http://%s/onvif/analytics_service",pLocalIp);
+        if((tds__GetServicesResponse->Service[1].Version = (struct tt__OnvifVersion*)soap_malloc(soap, sizeof(struct tt__OnvifVersion))))
+        {
+            tds__GetServicesResponse->Service[1].Version->Major = 2;
+            tds__GetServicesResponse->Service[1].Version->Minor = 0;
+        }
+
+        if((tds__GetServicesResponse->Service[2].Namespace = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            strcpy(tds__GetServicesResponse->Service[2].Namespace, "http://www.onvif.org/ver20/imaging/wsdl");
+        if((tds__GetServicesResponse->Service[2].XAddr = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            sprintf(tds__GetServicesResponse->Service[2].XAddr,"http://%s/onvif/imaging_service",pLocalIp);
+        if((tds__GetServicesResponse->Service[2].Version = (struct tt__OnvifVersion*)soap_malloc(soap, sizeof(struct tt__OnvifVersion))))
+        {
+            tds__GetServicesResponse->Service[2].Version->Major = 2;
+            tds__GetServicesResponse->Service[2].Version->Minor = 0;
+        }
+
+        if((tds__GetServicesResponse->Service[3].Namespace = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            strcpy(tds__GetServicesResponse->Service[3].Namespace, "http://www.onvif.org/ver10/media/wsdl");
+        if((tds__GetServicesResponse->Service[3].XAddr = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            sprintf(tds__GetServicesResponse->Service[3].XAddr,"http://%s/onvif/,media_service",pLocalIp);
+        if((tds__GetServicesResponse->Service[3].Version = (struct tt__OnvifVersion*)soap_malloc(soap, sizeof(struct tt__OnvifVersion))))
+        {
+            tds__GetServicesResponse->Service[3].Version->Major = 1;
+            tds__GetServicesResponse->Service[3].Version->Minor = 0;
+        }
+
+        if((tds__GetServicesResponse->Service[4].Namespace = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            strcpy(tds__GetServicesResponse->Service[4].Namespace, "http://www.onvif.org/ver20/ptz/wsdl");
+        if((tds__GetServicesResponse->Service[4].XAddr = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            sprintf(tds__GetServicesResponse->Service[4].XAddr,"http://%s/onvif/ptz_service",pLocalIp);
+        if((tds__GetServicesResponse->Service[4].Version = (struct tt__OnvifVersion*)soap_malloc(soap, sizeof(struct tt__OnvifVersion))))
+        {
+            tds__GetServicesResponse->Service[4].Version->Major = 2;
+            tds__GetServicesResponse->Service[4].Version->Minor = 0;
+        }
+
+        if((tds__GetServicesResponse->Service[5].Namespace = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            strcpy(tds__GetServicesResponse->Service[5].Namespace, "http://www.onvif.org/ver10/events/wsdl");
+        if((tds__GetServicesResponse->Service[5].XAddr = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            sprintf(tds__GetServicesResponse->Service[5].XAddr,"http://%s/onvif/event_service",pLocalIp);
+        if((tds__GetServicesResponse->Service[5].Version = (struct tt__OnvifVersion*)soap_malloc(soap, sizeof(struct tt__OnvifVersion))))
+        {
+            tds__GetServicesResponse->Service[5].Version->Major = 1;
+            tds__GetServicesResponse->Service[5].Version->Minor = 0;
+        }
+
+        if((tds__GetServicesResponse->Service[6].Namespace = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            strcpy(tds__GetServicesResponse->Service[6].Namespace, "http://www.onvif.org/ver10/deviceIO/wsdl");
+        if((tds__GetServicesResponse->Service[6].XAddr = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            sprintf(tds__GetServicesResponse->Service[6].XAddr,"http://%s/onvif/deviceIO_service",pLocalIp);
+        if((tds__GetServicesResponse->Service[6].Version = (struct tt__OnvifVersion*)soap_malloc(soap, sizeof(struct tt__OnvifVersion))))
+        {
+            tds__GetServicesResponse->Service[6].Version->Major = 1;
+            tds__GetServicesResponse->Service[6].Version->Minor = 0;
+        }
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+
+}
+/** Web service operation '__tds__GetServiceCapabilities' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetServiceCapabilities(struct soap* soap, struct _tds__GetServiceCapabilities *tds__GetServiceCapabilities, struct _tds__GetServiceCapabilitiesResponse *tds__GetServiceCapabilitiesResponse)
+{
+    return SOAP_OK;
+}
+/** Web service operation '__tds__GetDeviceInformation' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDeviceInformation(struct soap* soap, struct _tds__GetDeviceInformation *tds__GetDeviceInformation, struct _tds__GetDeviceInformationResponse *tds__GetDeviceInformationResponse)
+{
+    LOG(INFO,"start !\n");
+
+    if((tds__GetDeviceInformationResponse->Manufacturer = (char *)soap_malloc(soap,sizeof(char) * INFO_LENGTH)))
+        strcpy(tds__GetDeviceInformationResponse->Manufacturer,"Intel");
+    if((tds__GetDeviceInformationResponse->Model = (char *)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+        strcpy(tds__GetDeviceInformationResponse->Model,"Intel(R)Core(TM)i7-5557u CPU @ 3.1GHz");
+    if((tds__GetDeviceInformationResponse->FirmwareVersion = (char *)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+        strcpy(tds__GetDeviceInformationResponse->FirmwareVersion,"4.2.0-27-generic");
+    if((tds__GetDeviceInformationResponse->SerialNumber = (char *)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+        strcpy(tds__GetDeviceInformationResponse->SerialNumber,"261012301643");
+    if((tds__GetDeviceInformationResponse->HardwareId = (char *)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+        strcpy(tds__GetDeviceInformationResponse->HardwareId,"Total_Memory(15943MB),Memory_Usage(15101MB)");
+
+    return SOAP_OK;
+}
+/** Web service operation '__tds__SetSystemDateAndTime' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetSystemDateAndTime(struct soap* soap, struct _tds__SetSystemDateAndTime *tds__SetSystemDateAndTime, struct _tds__SetSystemDateAndTimeResponse *tds__SetSystemDateAndTimeResponse)
+{
+    LOG(INFO,"start !\n");
+    if(tds__SetSystemDateAndTime!=NULL)
+    {
+        LOG(INFO,"tds__SetSystemDateAndTime->DateTimeType is %d\r\n",tds__SetSystemDateAndTime->DateTimeType);
+        LOG(INFO,"tds__SetSystemDateAndTime->DaylightSavings is %d\r\n",tds__SetSystemDateAndTime->DaylightSavings);
+        if(tds__SetSystemDateAndTime->TimeZone!=NULL)
+        {
+            LOG(INFO,"tds__SetSystemDateAndTime->TimeZone->TZ is %s\r\n",tds__SetSystemDateAndTime->TimeZone->TZ);
+        }
+        if(tds__SetSystemDateAndTime->UTCDateTime!=NULL)
+        {
+            if(tds__SetSystemDateAndTime->UTCDateTime->Time!=NULL)
+            {
+                LOG(INFO,"tds__SetSystemDateAndTime->UTCDateTime->Time is %d:%d:%d\r\n",tds__SetSystemDateAndTime->UTCDateTime->Time->Hour,tds__SetSystemDateAndTime->UTCDateTime->Time->Minute,tds__SetSystemDateAndTime->UTCDateTime->Time->Second);
+            }
+            if(tds__SetSystemDateAndTime->UTCDateTime->Date!=NULL)
+            {
+                LOG(INFO,"tds__SetSystemDateAndTime->UTCDateTime->Date is %d:%d:%d\r\n",tds__SetSystemDateAndTime->UTCDateTime->Date->Year,tds__SetSystemDateAndTime->UTCDateTime->Date->Month,tds__SetSystemDateAndTime->UTCDateTime->Date->Day);
+            }
+        }
+    }
+
+    return SOAP_OK;
+
+}
+/** Web service operation '__tds__GetSystemDateAndTime' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemDateAndTime(struct soap* soap, struct _tds__GetSystemDateAndTime *tds__GetSystemDateAndTime, struct _tds__GetSystemDateAndTimeResponse *tds__GetSystemDateAndTimeResponse)
+{
+    time_t timer;
+    struct timeval tv;
+    struct timezone tz;
+    timer = time(NULL);
+    LOG(INFO,"start !\n");
+
+    if((tds__GetSystemDateAndTimeResponse->SystemDateAndTime = (struct tt__SystemDateTime *)soap_malloc(soap,sizeof(struct tt__SystemDateTime))))
+    {
+        tds__GetSystemDateAndTimeResponse->SystemDateAndTime->DateTimeType = tt__SetDateTimeType__Manual;
+        tds__GetSystemDateAndTimeResponse->SystemDateAndTime->DaylightSavings = xsd__boolean__true_;
+
+        if((tds__GetSystemDateAndTimeResponse->SystemDateAndTime->TimeZone = (struct tt__TimeZone*)soap_malloc(soap,sizeof(struct tt__TimeZone))))
+            if((tds__GetSystemDateAndTimeResponse->SystemDateAndTime->TimeZone->TZ = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            {
+                gettimeofday( &tv, &tz);
+                if(tz.tz_minuteswest >= 0)
+                    sprintf(tds__GetSystemDateAndTimeResponse->SystemDateAndTime->TimeZone->TZ,"CST+%02d:%02d:00",tz.tz_minuteswest/60,tz.tz_minuteswest%60);
+                else{
+                    sprintf(tds__GetSystemDateAndTimeResponse->SystemDateAndTime->TimeZone->TZ,"CST-%02d:%02d:00",(-tz.tz_minuteswest)/60,(-tz.tz_minuteswest)%60);
+                }
+            }
+        if((tds__GetSystemDateAndTimeResponse->SystemDateAndTime->UTCDateTime = (struct tt__DateTime *)soap_malloc(soap,sizeof(struct tt__DateTime ))))
+        {
+            struct tm *tm_utc;
+            tm_utc = gmtime(&timer);
+            if(tm_utc && tm_utc->tm_year && tm_utc->tm_mon && tm_utc->tm_mday)
+            {
+                if((tds__GetSystemDateAndTimeResponse->SystemDateAndTime->UTCDateTime->Date = (struct tt__Date *)soap_malloc(soap,sizeof(struct tt__Date ))))
+                {
+                    tds__GetSystemDateAndTimeResponse->SystemDateAndTime->UTCDateTime->Date->Year = tm_utc->tm_year + 1900;
+                    tds__GetSystemDateAndTimeResponse->SystemDateAndTime->UTCDateTime->Date->Month = tm_utc->tm_mon + 1;
+                    tds__GetSystemDateAndTimeResponse->SystemDateAndTime->UTCDateTime->Date->Day = tm_utc->tm_mday;
+                }
+            }
+            if(tm_utc && tm_utc->tm_hour && tm_utc->tm_min && tm_utc->tm_sec)
+            {
+                if((tds__GetSystemDateAndTimeResponse->SystemDateAndTime->UTCDateTime->Time = (struct tt__Time *)soap_malloc(soap,sizeof(struct tt__Time ))))
+                {
+                    tds__GetSystemDateAndTimeResponse->SystemDateAndTime->UTCDateTime->Time->Hour = tm_utc->tm_hour;
+                    tds__GetSystemDateAndTimeResponse->SystemDateAndTime->UTCDateTime->Time->Minute = tm_utc->tm_min;
+                    tds__GetSystemDateAndTimeResponse->SystemDateAndTime->UTCDateTime->Time->Second = tm_utc->tm_sec;
+                }
+            }
+        }
+        if((tds__GetSystemDateAndTimeResponse->SystemDateAndTime->LocalDateTime =  (struct tt__DateTime *)soap_malloc(soap,sizeof(struct tt__DateTime ))))
+        {
+            struct tm *tm_local;
+            tm_local = localtime(&timer);
+            if(tm_local && tm_local->tm_year && tm_local->tm_mon && tm_local->tm_mday)
+            {
+                if((tds__GetSystemDateAndTimeResponse->SystemDateAndTime->LocalDateTime->Date = (struct tt__Date *)soap_malloc(soap,sizeof(struct tt__Date ))))
+                {
+                    tds__GetSystemDateAndTimeResponse->SystemDateAndTime->LocalDateTime->Date->Year = tm_local->tm_year + 1900;
+                    tds__GetSystemDateAndTimeResponse->SystemDateAndTime->LocalDateTime->Date->Month = tm_local->tm_mon + 1;
+                    tds__GetSystemDateAndTimeResponse->SystemDateAndTime->LocalDateTime->Date->Day = tm_local->tm_mday;
+                }
+            }
+            if(tm_local && tm_local->tm_hour && tm_local->tm_min && tm_local->tm_sec)
+            {
+                if((tds__GetSystemDateAndTimeResponse->SystemDateAndTime->LocalDateTime->Time = (struct tt__Time *)soap_malloc(soap,sizeof(struct tt__Time ))))
+                {
+                    tds__GetSystemDateAndTimeResponse->SystemDateAndTime->LocalDateTime->Time->Hour = tm_local->tm_hour;
+                    tds__GetSystemDateAndTimeResponse->SystemDateAndTime->LocalDateTime->Time->Minute = tm_local->tm_min;
+                    tds__GetSystemDateAndTimeResponse->SystemDateAndTime->LocalDateTime->Time->Second = tm_local->tm_sec;
+                }
+            }
+        }
+        tds__GetSystemDateAndTimeResponse->SystemDateAndTime->Extension = NULL;
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+/** Web service operation '__tds__SetSystemFactoryDefault' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetSystemFactoryDefault(struct soap* soap, struct _tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault, struct _tds__SetSystemFactoryDefaultResponse *tds__SetSystemFactoryDefaultResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__UpgradeSystemFirmware' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__UpgradeSystemFirmware(struct soap* soap, struct _tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware, struct _tds__UpgradeSystemFirmwareResponse *tds__UpgradeSystemFirmwareResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SystemReboot' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SystemReboot(struct soap* soap, struct _tds__SystemReboot *tds__SystemReboot, struct _tds__SystemRebootResponse *tds__SystemRebootResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__RestoreSystem' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__RestoreSystem(struct soap* soap, struct _tds__RestoreSystem *tds__RestoreSystem, struct _tds__RestoreSystemResponse *tds__RestoreSystemResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetSystemBackup' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemBackup(struct soap* soap, struct _tds__GetSystemBackup *tds__GetSystemBackup, struct _tds__GetSystemBackupResponse *tds__GetSystemBackupResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetSystemLog' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemLog(struct soap* soap, struct _tds__GetSystemLog *tds__GetSystemLog, struct _tds__GetSystemLogResponse *tds__GetSystemLogResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetSystemSupportInformation' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemSupportInformation(struct soap* soap, struct _tds__GetSystemSupportInformation *tds__GetSystemSupportInformation, struct _tds__GetSystemSupportInformationResponse *tds__GetSystemSupportInformationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetScopes' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetScopes(struct soap* soap, struct _tds__GetScopes *tds__GetScopes, struct _tds__GetScopesResponse *tds__GetScopesResponse)
+{
+    LOG(INFO,"start !\n");
+    tds__GetScopesResponse->__sizeScopes = 8;
+    if((tds__GetScopesResponse->Scopes = (struct tt__Scope*)soap_malloc(soap, sizeof(struct tt__Scope)*(tds__GetScopesResponse->__sizeScopes))))
+    {
+        if((tds__GetScopesResponse->Scopes[0].ScopeItem = (char*)soap_malloc(soap,sizeof(char)*SMALL_INFO_LENGTH)))
+            strcpy(tds__GetScopesResponse->Scopes[0].ScopeItem,"onvif://www.onvif.org/location/country/china");
+        tds__GetScopesResponse->Scopes[0].ScopeDef = tt__ScopeDefinition__Fixed;
+        if((tds__GetScopesResponse->Scopes[1].ScopeItem = (char*)soap_malloc(soap,sizeof(char)*SMALL_INFO_LENGTH)))
+            strcpy(tds__GetScopesResponse->Scopes[1].ScopeItem,"onvif://www.onvif.org/name/IntelIPCamera");
+        tds__GetScopesResponse->Scopes[1].ScopeDef = tt__ScopeDefinition__Fixed;
+        if((tds__GetScopesResponse->Scopes[2].ScopeItem = (char*)soap_malloc(soap,sizeof(char)*SMALL_INFO_LENGTH)))
+            strcpy(tds__GetScopesResponse->Scopes[2].ScopeItem,"onvif://www.onvif.org/hardware/IPC-Intel0000");
+        tds__GetScopesResponse->Scopes[2].ScopeDef = tt__ScopeDefinition__Fixed;
+        if((tds__GetScopesResponse->Scopes[3].ScopeItem = (char*)soap_malloc(soap,sizeof(char)*SMALL_INFO_LENGTH)))
+            strcpy(tds__GetScopesResponse->Scopes[3].ScopeItem,"onvif://www.onvif.org/Profile/Streaming");
+        tds__GetScopesResponse->Scopes[3].ScopeDef = tt__ScopeDefinition__Fixed;
+        if((tds__GetScopesResponse->Scopes[4].ScopeItem = (char*)soap_malloc(soap,sizeof(char)*SMALL_INFO_LENGTH)))
+            strcpy(tds__GetScopesResponse->Scopes[4].ScopeItem,"onvif://www.onvif.org/type/Network_Video_Transmitter");
+        tds__GetScopesResponse->Scopes[4].ScopeDef = tt__ScopeDefinition__Fixed;
+        if((tds__GetScopesResponse->Scopes[5].ScopeItem = (char*)soap_malloc(soap,sizeof(char)*SMALL_INFO_LENGTH)))
+            strcpy(tds__GetScopesResponse->Scopes[5].ScopeItem,"onvif://www.onvif.org/extension/unique_identifier");
+        tds__GetScopesResponse->Scopes[5].ScopeDef = tt__ScopeDefinition__Fixed;
+        if((tds__GetScopesResponse->Scopes[6].ScopeItem = (char*)soap_malloc(soap,sizeof(char)*SMALL_INFO_LENGTH)))
+            strcpy(tds__GetScopesResponse->Scopes[6].ScopeItem,"onvif://www.onvif.org/profile/Q/Operational");
+        tds__GetScopesResponse->Scopes[6].ScopeDef = tt__ScopeDefinition__Fixed;
+        if((tds__GetScopesResponse->Scopes[7].ScopeItem = (char*)soap_malloc(soap,sizeof(char)*SMALL_INFO_LENGTH)))
+            strcpy(tds__GetScopesResponse->Scopes[7].ScopeItem,"");
+        tds__GetScopesResponse->Scopes[7].ScopeDef = tt__ScopeDefinition__Fixed;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__tds__SetScopes' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetScopes(struct soap* soap, struct _tds__SetScopes *tds__SetScopes, struct _tds__SetScopesResponse *tds__SetScopesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__AddScopes' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__AddScopes(struct soap* soap, struct _tds__AddScopes *tds__AddScopes, struct _tds__AddScopesResponse *tds__AddScopesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__RemoveScopes' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__RemoveScopes(struct soap* soap, struct _tds__RemoveScopes *tds__RemoveScopes, struct _tds__RemoveScopesResponse *tds__RemoveScopesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDiscoveryMode' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDiscoveryMode(struct soap* soap, struct _tds__GetDiscoveryMode *tds__GetDiscoveryMode, struct _tds__GetDiscoveryModeResponse *tds__GetDiscoveryModeResponse)
+{
+    LOG(INFO,"start !\n");
+    tds__GetDiscoveryModeResponse->DiscoveryMode = tt__DiscoveryMode__Discoverable;
+    return SOAP_OK;
+}
+
+/** Web service operation '__tds__SetDiscoveryMode' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDiscoveryMode(struct soap* soap, struct _tds__SetDiscoveryMode *tds__SetDiscoveryMode, struct _tds__SetDiscoveryModeResponse *tds__SetDiscoveryModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetRemoteDiscoveryMode' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetRemoteDiscoveryMode(struct soap* soap, struct _tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode, struct _tds__GetRemoteDiscoveryModeResponse *tds__GetRemoteDiscoveryModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetRemoteDiscoveryMode' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRemoteDiscoveryMode(struct soap* soap, struct _tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode, struct _tds__SetRemoteDiscoveryModeResponse *tds__SetRemoteDiscoveryModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDPAddresses' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDPAddresses(struct soap* soap, struct _tds__GetDPAddresses *tds__GetDPAddresses, struct _tds__GetDPAddressesResponse *tds__GetDPAddressesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetEndpointReference' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetEndpointReference(struct soap* soap, struct _tds__GetEndpointReference *tds__GetEndpointReference, struct _tds__GetEndpointReferenceResponse *tds__GetEndpointReferenceResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetRemoteUser' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetRemoteUser(struct soap* soap, struct _tds__GetRemoteUser *tds__GetRemoteUser, struct _tds__GetRemoteUserResponse *tds__GetRemoteUserResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetRemoteUser' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRemoteUser(struct soap* soap, struct _tds__SetRemoteUser *tds__SetRemoteUser, struct _tds__SetRemoteUserResponse *tds__SetRemoteUserResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetUsers' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetUsers(struct soap* soap, struct _tds__GetUsers *tds__GetUsers, struct _tds__GetUsersResponse *tds__GetUsersResponse)
+{
+    LOG(INFO,"start !\n");
+    soap->header = NULL;
+    tds__GetUsersResponse->__sizeUser = 1;
+    if((tds__GetUsersResponse->User = (struct tt__User*)soap_malloc(soap,sizeof(struct tt__User)*(tds__GetUsersResponse->__sizeUser))))
+    {
+        if((tds__GetUsersResponse->User[0].Username = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(tds__GetUsersResponse->User[0].Username,"admin");
+        if((tds__GetUsersResponse->User[0].Password = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(tds__GetUsersResponse->User[0].Password,"admin");
+        tds__GetUsersResponse->User->UserLevel = tt__UserLevel__Administrator;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__tds__CreateUsers' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__CreateUsers(struct soap* soap, struct _tds__CreateUsers *tds__CreateUsers, struct _tds__CreateUsersResponse *tds__CreateUsersResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__DeleteUsers' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteUsers(struct soap* soap, struct _tds__DeleteUsers *tds__DeleteUsers, struct _tds__DeleteUsersResponse *tds__DeleteUsersResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetUser' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetUser(struct soap* soap, struct _tds__SetUser *tds__SetUser, struct _tds__SetUserResponse *tds__SetUserResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetWsdlUrl' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetWsdlUrl(struct soap* soap, struct _tds__GetWsdlUrl *tds__GetWsdlUrl, struct _tds__GetWsdlUrlResponse *tds__GetWsdlUrlResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetCapabilities' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCapabilities(struct soap* soap, struct _tds__GetCapabilities *tds__GetCapabilities, struct _tds__GetCapabilitiesResponse *tds__GetCapabilitiesResponse)
+{
+    //int _Category;
+    char _IPv4Address[LARGE_INFO_LENGTH];
+    if (szLocalIp[0] == 0)
+    {
+        strncpy(szLocalIp, get_local_ip(), 128);
+    }
+    LOG(INFO,"start !\n");
+    if((tds__GetCapabilities->Category=(enum tt__CapabilityCategory *)soap_malloc(soap, sizeof(enum tt__CapabilityCategory))))
+        *tds__GetCapabilities->Category = tt__CapabilityCategory__All;
+    sprintf(_IPv4Address, "http://%s/onvif/services", pLocalIp);
+    if((tds__GetCapabilitiesResponse->Capabilities = (struct tt__Capabilities*)soap_malloc(soap, sizeof(struct tt__Capabilities))))
+    {
+        tds__GetCapabilitiesResponse->Capabilities->Analytics = NULL;
+        tds__GetCapabilitiesResponse->Capabilities->Events = NULL;
+        tds__GetCapabilitiesResponse->Capabilities->PTZ = NULL;
+        //Capabilities__Extension_Choice:
+        if((tds__GetCapabilitiesResponse->Capabilities->Extension = (struct tt__CapabilitiesExtension*)soap_malloc(soap, sizeof(struct tt__CapabilitiesExtension))))
+        {
+            if((tds__GetCapabilitiesResponse->Capabilities->Extension->DeviceIO = (struct tt__DeviceIOCapabilities*)soap_malloc(soap, sizeof(struct tt__DeviceIOCapabilities))))
+            {
+                tds__GetCapabilitiesResponse->Capabilities->Extension->DeviceIO->XAddr = (char *)soap_malloc(soap, sizeof(char) * INFO_LENGTH);
+                strcpy(tds__GetCapabilitiesResponse->Capabilities->Extension->DeviceIO->XAddr,_IPv4Address);
+
+                tds__GetCapabilitiesResponse->Capabilities->Extension->DeviceIO->VideoSources = TRUE;
+                tds__GetCapabilitiesResponse->Capabilities->Extension->DeviceIO->VideoOutputs = TRUE;
+                tds__GetCapabilitiesResponse->Capabilities->Extension->DeviceIO->AudioSources = FALSE;
+                tds__GetCapabilitiesResponse->Capabilities->Extension->DeviceIO->AudioOutputs = FALSE;
+                tds__GetCapabilitiesResponse->Capabilities->Extension->DeviceIO->RelayOutputs = FALSE;
+            }
+
+
+            tds__GetCapabilitiesResponse->Capabilities->Extension->Display = NULL;
+            tds__GetCapabilitiesResponse->Capabilities->Extension->Recording = NULL;
+            tds__GetCapabilitiesResponse->Capabilities->Extension->Search = NULL;
+            tds__GetCapabilitiesResponse->Capabilities->Extension->Replay = NULL;
+            tds__GetCapabilitiesResponse->Capabilities->Extension->Receiver = NULL;
+            tds__GetCapabilitiesResponse->Capabilities->Extension->AnalyticsDevice = NULL;
+            tds__GetCapabilitiesResponse->Capabilities->Extension->Extensions = NULL;
+
+
+        }
+        //Capabilities__Device_Choice:
+        if((tds__GetCapabilitiesResponse->Capabilities->Device = (struct tt__DeviceCapabilities*)soap_malloc(soap, sizeof(struct tt__DeviceCapabilities))))
+        {
+            if((tds__GetCapabilitiesResponse->Capabilities->Device->XAddr = (char *) soap_malloc(soap, sizeof(char) * LARGE_INFO_LENGTH)))
+                sprintf(tds__GetCapabilitiesResponse->Capabilities->Device->XAddr, "http://%s/onvif/device_service",pLocalIp);
+
+            if((tds__GetCapabilitiesResponse->Capabilities->Device->Network = (struct tt__NetworkCapabilities*)soap_malloc(soap, sizeof(struct tt__NetworkCapabilities))))
+            {
+                if((tds__GetCapabilitiesResponse->Capabilities->Device->Network->IPFilter = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
+                    *(tds__GetCapabilitiesResponse->Capabilities->Device->Network->IPFilter) = xsd__boolean__false_;
+                if((tds__GetCapabilitiesResponse->Capabilities->Device->Network->ZeroConfiguration = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
+                    *(tds__GetCapabilitiesResponse->Capabilities->Device->Network->ZeroConfiguration) = xsd__boolean__true_;
+                if((tds__GetCapabilitiesResponse->Capabilities->Device->Network->IPVersion6 = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
+                    *(tds__GetCapabilitiesResponse->Capabilities->Device->Network->IPVersion6) = xsd__boolean__false_;
+                if((tds__GetCapabilitiesResponse->Capabilities->Device->Network->DynDNS = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
+                    *(tds__GetCapabilitiesResponse->Capabilities->Device->Network->DynDNS) = xsd__boolean__true_;
+                if((tds__GetCapabilitiesResponse->Capabilities->Device->Network->Extension = (struct tt__NetworkCapabilitiesExtension*)soap_malloc(soap, sizeof(struct tt__NetworkCapabilitiesExtension))))
+                {
+                    if((tds__GetCapabilitiesResponse->Capabilities->Device->Network->Extension->Dot11Configuration = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
+                        tds__GetCapabilitiesResponse->Capabilities->Device->Network->Extension->Dot11Configuration = xsd__boolean__false_;
+                    tds__GetCapabilitiesResponse->Capabilities->Device->Network->Extension->Extension = NULL;
+                }
+            }
+
+            if((tds__GetCapabilitiesResponse->Capabilities->Device->System = (struct tt__SystemCapabilities*)soap_malloc(soap, sizeof(struct tt__SystemCapabilities))))
+            {
+                tds__GetCapabilitiesResponse->Capabilities->Device->System->DiscoveryResolve = xsd__boolean__true_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->System->DiscoveryBye = xsd__boolean__false_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->System->RemoteDiscovery = xsd__boolean__false_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->System->SystemBackup = xsd__boolean__false_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->System->SystemLogging = xsd__boolean__false_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->System->FirmwareUpgrade = xsd__boolean__false_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->System->__sizeSupportedVersions = xsd__boolean__true_;
+                if((tds__GetCapabilitiesResponse->Capabilities->Device->System->SupportedVersions = (struct tt__OnvifVersion*)soap_malloc(soap, sizeof(struct tt__OnvifVersion))))
+                {
+                    tds__GetCapabilitiesResponse->Capabilities->Device->System->SupportedVersions->Major = 0;
+                    tds__GetCapabilitiesResponse->Capabilities->Device->System->SupportedVersions->Minor = 3;
+                }
+                if((tds__GetCapabilitiesResponse->Capabilities->Device->System->Extension = (struct tt__SystemCapabilitiesExtension*)soap_malloc(soap, sizeof(struct tt__SystemCapabilitiesExtension))))
+                {
+                    if((tds__GetCapabilitiesResponse->Capabilities->Device->System->Extension->HttpSystemBackup = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
+                        *tds__GetCapabilitiesResponse->Capabilities->Device->System->Extension->HttpSystemBackup = xsd__boolean__false_;
+                    if((tds__GetCapabilitiesResponse->Capabilities->Device->System->Extension->HttpFirmwareUpgrade = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
+                        *tds__GetCapabilitiesResponse->Capabilities->Device->System->Extension->HttpFirmwareUpgrade = xsd__boolean__true_;
+                    if((tds__GetCapabilitiesResponse->Capabilities->Device->System->Extension->HttpSystemLogging = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
+                        *tds__GetCapabilitiesResponse->Capabilities->Device->System->Extension->HttpSystemLogging = xsd__boolean__true_;
+                    if((tds__GetCapabilitiesResponse->Capabilities->Device->System->Extension->HttpSupportInformation = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
+                        *tds__GetCapabilitiesResponse->Capabilities->Device->System->Extension->HttpSupportInformation = xsd__boolean__true_;
+                    tds__GetCapabilitiesResponse->Capabilities->Device->System->Extension->Extension = NULL;
+                }
+            }
+
+            if((tds__GetCapabilitiesResponse->Capabilities->Device->IO = (struct tt__IOCapabilities*)soap_malloc(soap, sizeof(struct tt__IOCapabilities))))
+            {
+                if((tds__GetCapabilitiesResponse->Capabilities->Device->IO->InputConnectors = (int*)soap_malloc(soap,sizeof(int))))
+                    *tds__GetCapabilitiesResponse->Capabilities->Device->IO->InputConnectors = 0;
+                if((tds__GetCapabilitiesResponse->Capabilities->Device->IO->RelayOutputs = (int*)soap_malloc(soap,sizeof(int))))
+                    *tds__GetCapabilitiesResponse->Capabilities->Device->IO->RelayOutputs = 0;
+                if((tds__GetCapabilitiesResponse->Capabilities->Device->IO->Extension = (struct tt__IOCapabilitiesExtension *)soap_malloc(soap, sizeof(struct tt__IOCapabilitiesExtension))))
+                {
+                    if((tds__GetCapabilitiesResponse->Capabilities->Device->IO->Extension->Auxiliary = (enum xsd__boolean *)soap_malloc(soap,sizeof(enum xsd__boolean))))
+                        *tds__GetCapabilitiesResponse->Capabilities->Device->IO->Extension->Auxiliary = xsd__boolean__false_;
+                    tds__GetCapabilitiesResponse->Capabilities->Device->IO->Extension->__sizeAuxiliaryCommands = 0;
+                    tds__GetCapabilitiesResponse->Capabilities->Device->IO->Extension->AuxiliaryCommands= NULL;
+                    tds__GetCapabilitiesResponse->Capabilities->Device->IO->Extension->Extension = NULL;
+                }
+            }
+
+            if((tds__GetCapabilitiesResponse->Capabilities->Device->Security = (struct tt__SecurityCapabilities*)soap_malloc(soap, sizeof(struct tt__SecurityCapabilities))))
+            {
+                tds__GetCapabilitiesResponse->Capabilities->Device->Security->TLS1_x002e1 = xsd__boolean__false_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->Security->TLS1_x002e2 = xsd__boolean__false_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->Security->OnboardKeyGeneration = xsd__boolean__false_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->Security->AccessPolicyConfig = xsd__boolean__false_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->Security->X_x002e509Token = xsd__boolean__false_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->Security->SAMLToken = xsd__boolean__false_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->Security->KerberosToken = xsd__boolean__false_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->Security->RELToken = xsd__boolean__false_;
+                tds__GetCapabilitiesResponse->Capabilities->Device->Security->Extension = NULL;
+            }
+            tds__GetCapabilitiesResponse->Capabilities->Device->Extension = NULL;
+        }
+        // Capabilities__Media_Choice:
+        if((tds__GetCapabilitiesResponse->Capabilities->Media = (struct tt__MediaCapabilities*)soap_malloc(soap, sizeof(struct tt__MediaCapabilities))))
+        {
+            if((tds__GetCapabilitiesResponse->Capabilities->Media->XAddr = (char *) soap_malloc(soap, sizeof(char) * LARGE_INFO_LENGTH)))
+                sprintf(tds__GetCapabilitiesResponse->Capabilities->Media->XAddr, "http://%s/onvif/media_service",pLocalIp);
+            if((tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities = (struct tt__RealTimeStreamingCapabilities*)soap_malloc(soap, sizeof(struct tt__RealTimeStreamingCapabilities))))
+            {
+                if((tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities->RTPMulticast = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
+                    *tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities->RTPMulticast = xsd__boolean__true_;
+                if((tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities->RTP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
+                    *tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities->RTP_USCORETCP = xsd__boolean__true_;
+                if((tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities->RTP_USCORERTSP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
+                    *tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities->RTP_USCORERTSP_USCORETCP = xsd__boolean__true_;
+                tds__GetCapabilitiesResponse->Capabilities->Media->StreamingCapabilities->Extension = NULL;
+            }
+            tds__GetCapabilitiesResponse->Capabilities->Media->Extension = NULL;
+        }
+        // Capabilities__Imaging_Choice:
+        if((tds__GetCapabilitiesResponse->Capabilities->Imaging = (struct tt__ImagingCapabilities*)soap_malloc(soap,sizeof(struct tt__ImagingCapabilities))))
+        {
+            if((tds__GetCapabilitiesResponse->Capabilities->Imaging->XAddr = (char *)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                sprintf(tds__GetCapabilitiesResponse->Capabilities->Imaging->XAddr,"http://%s/onvif/imaging_service",pLocalIp);
+        }
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__tds__SetDPAddresses' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDPAddresses(struct soap* soap, struct _tds__SetDPAddresses *tds__SetDPAddresses, struct _tds__SetDPAddressesResponse *tds__SetDPAddressesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetHostname' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetHostname(struct soap* soap, struct _tds__GetHostname *tds__GetHostname, struct _tds__GetHostnameResponse *tds__GetHostnameResponse)
+{
+    LOG(INFO,"start !\n");
+    if((tds__GetHostnameResponse->HostnameInformation = (struct tt__HostnameInformation*)soap_malloc(soap,sizeof(struct tt__HostnameInformation))))
+    {
+        if((tds__GetHostnameResponse->HostnameInformation->Name = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            strcpy(tds__GetHostnameResponse->HostnameInformation->Name,"IntelIPC");
+        tds__GetHostnameResponse->HostnameInformation->FromDHCP = xsd__boolean__true_; //not from DHCP
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__tds__SetHostname' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetHostname(struct soap* soap, struct _tds__SetHostname *tds__SetHostname, struct _tds__SetHostnameResponse *tds__SetHostnameResponse)
+{
+    LOG(INFO,"start !\n");
+    if(tds__SetHostname!=NULL&&tds__SetHostname->Name!=NULL)
+        LOG(INFO,"[%s] %s\r\n",__func__,tds__SetHostname->Name);
+
+    return SOAP_OK;
+}
+/** Web service operation '__tds__SetHostnameFromDHCP' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetHostnameFromDHCP(struct soap* soap, struct _tds__SetHostnameFromDHCP *tds__SetHostnameFromDHCP, struct _tds__SetHostnameFromDHCPResponse *tds__SetHostnameFromDHCPResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDNS' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDNS(struct soap* soap, struct _tds__GetDNS *tds__GetDNS, struct _tds__GetDNSResponse *tds__GetDNSResponse)
+{
+    LOG(INFO,"start !\n");
+    if((tds__GetDNSResponse->DNSInformation = (struct tt__DNSInformation*)soap_malloc(soap,sizeof(struct tt__DNSInformation))))
+    {
+        tds__GetDNSResponse->DNSInformation->FromDHCP = xsd__boolean__false_;
+        tds__GetDNSResponse->DNSInformation->__sizeSearchDomain = 1;
+        if((tds__GetDNSResponse->DNSInformation->SearchDomain = (char**)soap_malloc(soap,sizeof(char*)*(tds__GetDNSResponse->DNSInformation->__sizeSearchDomain))))
+            if((tds__GetDNSResponse->DNSInformation->SearchDomain[0] = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                strcpy(tds__GetDNSResponse->DNSInformation->SearchDomain[0],"Intel_IPCamera");
+        tds__GetDNSResponse->DNSInformation->__sizeDNSFromDHCP = 0;
+        tds__GetDNSResponse->DNSInformation->DNSFromDHCP = NULL;
+        tds__GetDNSResponse->DNSInformation->__sizeDNSManual = 4;
+        if((tds__GetDNSResponse->DNSInformation->DNSManual = (struct tt__IPAddress*)soap_malloc(soap,sizeof(struct tt__IPAddress)*(tds__GetDNSResponse->DNSInformation->__sizeDNSManual))))
+        {
+            tds__GetDNSResponse->DNSInformation->DNSManual[0].Type = tt__IPType__IPv4;
+            if((tds__GetDNSResponse->DNSInformation->DNSManual[0].IPv4Address = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                strcpy(tds__GetDNSResponse->DNSInformation->DNSManual[0].IPv4Address,"10.248.2.5");
+            tds__GetDNSResponse->DNSInformation->DNSManual[0].IPv6Address = NULL;
+            tds__GetDNSResponse->DNSInformation->DNSManual[1].Type = tt__IPType__IPv4;
+            if((tds__GetDNSResponse->DNSInformation->DNSManual[1].IPv4Address = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                strcpy(tds__GetDNSResponse->DNSInformation->DNSManual[1].IPv4Address,"10.239.27.228");
+            tds__GetDNSResponse->DNSInformation->DNSManual[1].IPv6Address = NULL;
+            tds__GetDNSResponse->DNSInformation->DNSManual[2].Type = tt__IPType__IPv6;
+            tds__GetDNSResponse->DNSInformation->DNSManual[2].IPv4Address = NULL;
+            if((tds__GetDNSResponse->DNSInformation->DNSManual[2].IPv6Address = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                strcpy(tds__GetDNSResponse->DNSInformation->DNSManual[2].IPv6Address,"2001:da8:2000:2017::33");
+            tds__GetDNSResponse->DNSInformation->DNSManual[3].Type = tt__IPType__IPv6;
+            tds__GetDNSResponse->DNSInformation->DNSManual[3].IPv4Address = NULL;
+            if((tds__GetDNSResponse->DNSInformation->DNSManual[3].IPv6Address = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                strcpy(tds__GetDNSResponse->DNSInformation->DNSManual[3].IPv6Address,"2001:da8:2000:2193::33");
+        }
+        tds__GetDNSResponse->DNSInformation->Extension = NULL;
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__tds__SetDNS' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDNS(struct soap* soap, struct _tds__SetDNS *tds__SetDNS, struct _tds__SetDNSResponse *tds__SetDNSResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetNTP' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNTP(struct soap* soap, struct _tds__GetNTP *tds__GetNTP, struct _tds__GetNTPResponse *tds__GetNTPResponse)
+{
+    LOG(INFO,"start !\n");
+    if((tds__GetNTPResponse->NTPInformation = (struct tt__NTPInformation*)soap_malloc(soap,sizeof(struct tt__NTPInformation))))
+    {
+        tds__GetNTPResponse->NTPInformation->FromDHCP = xsd__boolean__false_;
+        tds__GetNTPResponse->NTPInformation->__sizeNTPFromDHCP = 0;
+        tds__GetNTPResponse->NTPInformation->NTPFromDHCP = NULL;
+        tds__GetNTPResponse->NTPInformation->__sizeNTPManual = 2;
+        if((tds__GetNTPResponse->NTPInformation->NTPManual = (struct tt__NetworkHost*)soap_malloc(soap,sizeof(struct tt__NetworkHost)*(tds__GetNTPResponse->NTPInformation->__sizeNTPManual))))
+        {
+            tds__GetNTPResponse->NTPInformation->NTPManual[0].Type = tt__NetworkHostType__IPv4;
+            if((tds__GetNTPResponse->NTPInformation->NTPManual[0].IPv4Address = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                strcpy(tds__GetNTPResponse->NTPInformation->NTPManual[0].IPv4Address,"10.1.1.1");
+            tds__GetNTPResponse->NTPInformation->NTPManual[0].IPv6Address = NULL;
+            tds__GetNTPResponse->NTPInformation->NTPManual[0].DNSname = NULL;
+            tds__GetNTPResponse->NTPInformation->NTPManual[0].Extension = NULL;
+            tds__GetNTPResponse->NTPInformation->NTPManual[1].Type = tt__NetworkHostType__IPv6;
+            tds__GetNTPResponse->NTPInformation->NTPManual[1].IPv4Address = NULL;
+            if((tds__GetNTPResponse->NTPInformation->NTPManual[1].IPv6Address = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                strcpy(tds__GetNTPResponse->NTPInformation->NTPManual[1].IPv6Address,"2001:1:1:1:1:1:1:1");
+            tds__GetNTPResponse->NTPInformation->NTPManual[1].DNSname = NULL;
+            tds__GetNTPResponse->NTPInformation->NTPManual[1].Extension = NULL;
+        }
+        tds__GetNTPResponse->NTPInformation->Extension = NULL;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__tds__SetNTP' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNTP(struct soap* soap, struct _tds__SetNTP *tds__SetNTP, struct _tds__SetNTPResponse *tds__SetNTPResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDynamicDNS' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDynamicDNS(struct soap* soap, struct _tds__GetDynamicDNS *tds__GetDynamicDNS, struct _tds__GetDynamicDNSResponse *tds__GetDynamicDNSResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetDynamicDNS' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDynamicDNS(struct soap* soap, struct _tds__SetDynamicDNS *tds__SetDynamicDNS, struct _tds__SetDynamicDNSResponse *tds__SetDynamicDNSResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetNetworkInterfaces' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNetworkInterfaces(struct soap* soap, struct _tds__GetNetworkInterfaces *tds__GetNetworkInterfaces, struct _tds__GetNetworkInterfacesResponse *tds__GetNetworkInterfacesResponse)
+{
+    LOG(INFO,"start !\n");
+    if (szLocalIp[0] == 0)
+    {
+        strncpy(szLocalIp, get_local_ip(), 128);
+    }
+    tds__GetNetworkInterfacesResponse->__sizeNetworkInterfaces = 1;
+    if((tds__GetNetworkInterfacesResponse->NetworkInterfaces = (struct tt__NetworkInterface*)soap_malloc(soap,sizeof(struct tt__NetworkInterface)*(tds__GetNetworkInterfacesResponse->__sizeNetworkInterfaces))))
+    {
+        if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->token = (char *)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(tds__GetNetworkInterfacesResponse->NetworkInterfaces->token,"eth0");
+        tds__GetNetworkInterfacesResponse->NetworkInterfaces->Enabled = xsd__boolean__true_;
+        if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->Info = (struct tt__NetworkInterfaceInfo*)soap_malloc(soap,sizeof(struct tt__NetworkInterfaceInfo))))
+        {
+            if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->Info->Name = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                strcpy(tds__GetNetworkInterfacesResponse->NetworkInterfaces->Info->Name,"eth0");
+            if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->Info->HwAddress = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                strcpy(tds__GetNetworkInterfacesResponse->NetworkInterfaces->Info->HwAddress,"3c:ef:8c:66:14:77");
+            if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->Info->MTU = (int*)soap_malloc(soap,sizeof(int))))
+                *tds__GetNetworkInterfacesResponse->NetworkInterfaces->Info->MTU = 1500;
+        }
+        if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->Link = (struct tt__NetworkInterfaceLink*)soap_malloc(soap,sizeof(struct tt__NetworkInterfaceLink))))
+        {
+            if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->Link->AdminSettings = (struct tt__NetworkInterfaceConnectionSetting*)soap_malloc(soap,sizeof(struct tt__NetworkInterfaceConnectionSetting))))
+            {
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->Link->AdminSettings->AutoNegotiation = xsd__boolean__false_;
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->Link->AdminSettings->Speed  = 10;
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->Link->AdminSettings->Duplex = tt__Duplex__Full;
+            }
+            if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->Link->OperSettings = (struct tt__NetworkInterfaceConnectionSetting*)soap_malloc(soap,sizeof(struct tt__NetworkInterfaceConnectionSetting))))
+            {
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->Link->OperSettings->AutoNegotiation = xsd__boolean__false_;
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->Link->OperSettings->Speed  = 10;
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->Link->OperSettings->Duplex = tt__Duplex__Full;
+            }
+            tds__GetNetworkInterfacesResponse->NetworkInterfaces->Link->InterfaceType = 6;
+        }
+        if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4 = (struct tt__IPv4NetworkInterface*)soap_malloc(soap,sizeof(struct tt__IPv4NetworkInterface))))
+        {
+            tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Enabled = xsd__boolean__true_;
+            if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Config = (struct tt__IPv4Configuration*)soap_malloc(soap,sizeof(struct tt__IPv4Configuration))))
+            {
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Config->__sizeManual = 1;
+                if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Config->Manual  = (struct tt__PrefixedIPv4Address*)soap_malloc(soap,sizeof(struct tt__PrefixedIPv4Address)*(tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Config->__sizeManual))))
+                {
+                    if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Config->Manual->Address = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                    {
+                        LOG(INFO," local ip = %s!\n", pLocalIp);
+                        strcpy(tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Config->Manual->Address, pLocalIp);
+                    }
+                    tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Config->Manual->PrefixLength = 24;
+                }
+                if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Config->LinkLocal = (struct tt__PrefixedIPv4Address*)soap_malloc(soap,sizeof(struct tt__PrefixedIPv4Address))))
+                {
+                    if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Config->LinkLocal->Address = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                        strcpy(tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Config->LinkLocal->Address, pLocalIp);
+                    tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Config->LinkLocal->PrefixLength = 24;
+                }
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Config->FromDHCP = NULL;
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv4->Config->DHCP = xsd__boolean__false_;
+            }
+
+        }
+        if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6 = (struct tt__IPv6NetworkInterface*)soap_malloc(soap,sizeof(struct tt__IPv6NetworkInterface))))
+        {
+            tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Enabled = xsd__boolean__true_;
+            if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config = (struct tt__IPv6Configuration*)soap_malloc(soap,sizeof(struct tt__IPv6Configuration))))
+            {
+                if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->AcceptRouterAdvert = (enum xsd__boolean*)soap_malloc(soap,sizeof(enum xsd__boolean))))
+                    *tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->AcceptRouterAdvert = xsd__boolean__false_;
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->DHCP = tt__IPv6DHCPConfiguration__Off;
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->__sizeManual = 1;
+                if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->Manual  = (struct tt__PrefixedIPv6Address*)soap_malloc(soap,sizeof(struct tt__PrefixedIPv6Address)*(tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->__sizeManual))))
+                {
+                    tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->Manual->Address = NULL;
+                    tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->Manual->PrefixLength = 0;
+                }
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->__sizeLinkLocal = 1;
+                if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->LinkLocal = (struct tt__PrefixedIPv6Address*)soap_malloc(soap,sizeof(struct tt__PrefixedIPv6Address)*(tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->__sizeLinkLocal))))
+                {
+                    if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->LinkLocal->Address = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                        strcpy(tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->LinkLocal->Address,"fe80::3eef:8cff:fe66:1477");
+                    tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->LinkLocal->PrefixLength = 64;
+                }
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->__sizeFromDHCP = 0;
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->FromDHCP = NULL;
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->__sizeFromRA = 1;
+                if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->FromRA = (struct tt__PrefixedIPv6Address*)soap_malloc(soap,sizeof(struct tt__PrefixedIPv6Address)*(tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->__sizeFromRA))))
+                {
+                    if((tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->FromRA->Address = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                        strcpy(tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->FromRA->Address,"2001:250:3000:3ca0:215:f2ff:fe5d:2301");
+                    tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->FromRA->PrefixLength = 64;
+                }
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->IPv6->Config->Extension = NULL;
+                tds__GetNetworkInterfacesResponse->NetworkInterfaces->Extension=NULL;
+            }
+        }
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__tds__SetNetworkInterfaces' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNetworkInterfaces(struct soap* soap, struct _tds__SetNetworkInterfaces *tds__SetNetworkInterfaces, struct _tds__SetNetworkInterfacesResponse *tds__SetNetworkInterfacesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetNetworkProtocols' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNetworkProtocols(struct soap* soap, struct _tds__GetNetworkProtocols *tds__GetNetworkProtocols, struct _tds__GetNetworkProtocolsResponse *tds__GetNetworkProtocolsResponse)
+{
+    LOG(INFO,"start !\n");
+    tds__GetNetworkProtocolsResponse->__sizeNetworkProtocols = 2;
+    if((tds__GetNetworkProtocolsResponse->NetworkProtocols = (struct tt__NetworkProtocol*)soap_malloc(soap,sizeof(struct tt__NetworkProtocol)*(tds__GetNetworkProtocolsResponse->__sizeNetworkProtocols))))
+    {
+        tds__GetNetworkProtocolsResponse->NetworkProtocols[0].Name = tt__NetworkProtocolType__HTTP;
+        tds__GetNetworkProtocolsResponse->NetworkProtocols[0].Enabled = xsd__boolean__true_;
+        tds__GetNetworkProtocolsResponse->NetworkProtocols[0].__sizePort = 1;
+        if((tds__GetNetworkProtocolsResponse->NetworkProtocols[0].Port = (int*)soap_malloc(soap,sizeof(int))))
+            *tds__GetNetworkProtocolsResponse->NetworkProtocols[0].Port = 80;
+        tds__GetNetworkProtocolsResponse->NetworkProtocols[0].Extension = NULL;
+
+        tds__GetNetworkProtocolsResponse->NetworkProtocols[1].Name = tt__NetworkProtocolType__RTSP;
+        tds__GetNetworkProtocolsResponse->NetworkProtocols[1].Enabled = xsd__boolean__true_;
+        tds__GetNetworkProtocolsResponse->NetworkProtocols[1].__sizePort = 1;
+        if((tds__GetNetworkProtocolsResponse->NetworkProtocols[1].Port = (int*)soap_malloc(soap,sizeof(int))))
+            *tds__GetNetworkProtocolsResponse->NetworkProtocols[1].Port = 554;
+        tds__GetNetworkProtocolsResponse->NetworkProtocols[1].Extension = NULL;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__tds__SetNetworkProtocols' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNetworkProtocols(struct soap* soap, struct _tds__SetNetworkProtocols *tds__SetNetworkProtocols, struct _tds__SetNetworkProtocolsResponse *tds__SetNetworkProtocolsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetNetworkDefaultGateway' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNetworkDefaultGateway(struct soap* soap, struct _tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway, struct _tds__GetNetworkDefaultGatewayResponse *tds__GetNetworkDefaultGatewayResponse)
+{
+    LOG(INFO,"start !\n");
+    if((tds__GetNetworkDefaultGatewayResponse->NetworkGateway = (struct tt__NetworkGateway*)soap_malloc(soap,sizeof(struct tt__NetworkGateway))))
+    {
+        tds__GetNetworkDefaultGatewayResponse->NetworkGateway->__sizeIPv4Address = 1;
+        if((tds__GetNetworkDefaultGatewayResponse->NetworkGateway->IPv4Address = (char**)soap_malloc(soap,sizeof(char*)*(tds__GetNetworkDefaultGatewayResponse->NetworkGateway->__sizeIPv4Address))))
+            if((tds__GetNetworkDefaultGatewayResponse->NetworkGateway->IPv4Address[0] = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                strcpy(tds__GetNetworkDefaultGatewayResponse->NetworkGateway->IPv4Address[0],"10.239.85.1");
+        tds__GetNetworkDefaultGatewayResponse->NetworkGateway->__sizeIPv6Address = 0;
+        tds__GetNetworkDefaultGatewayResponse->NetworkGateway->IPv6Address = NULL;
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__tds__SetNetworkDefaultGateway' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNetworkDefaultGateway(struct soap* soap, struct _tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway, struct _tds__SetNetworkDefaultGatewayResponse *tds__SetNetworkDefaultGatewayResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetZeroConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetZeroConfiguration(struct soap* soap, struct _tds__GetZeroConfiguration *tds__GetZeroConfiguration, struct _tds__GetZeroConfigurationResponse *tds__GetZeroConfigurationResponse)
+{
+    if((tds__GetZeroConfigurationResponse->ZeroConfiguration = (struct tt__NetworkZeroConfiguration*)soap_malloc(soap,sizeof(struct tt__NetworkZeroConfiguration))))
+    {
+        if((tds__GetZeroConfigurationResponse->ZeroConfiguration->InterfaceToken  = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(tds__GetZeroConfigurationResponse->ZeroConfiguration->InterfaceToken,"eth0");
+        tds__GetZeroConfigurationResponse->ZeroConfiguration->Enabled = xsd__boolean__true_;
+        tds__GetZeroConfigurationResponse->ZeroConfiguration->__sizeAddresses = 2;
+        if((tds__GetZeroConfigurationResponse->ZeroConfiguration->Addresses = (char**)soap_malloc(soap,sizeof(char*)*(tds__GetZeroConfigurationResponse->ZeroConfiguration->__sizeAddresses))))
+        {
+            if((tds__GetZeroConfigurationResponse->ZeroConfiguration->Addresses[0] = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                strcpy(tds__GetZeroConfigurationResponse->ZeroConfiguration->Addresses[0],"169.254.10.200");
+            if((tds__GetZeroConfigurationResponse->ZeroConfiguration->Addresses[1] = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                strcpy(tds__GetZeroConfigurationResponse->ZeroConfiguration->Addresses[1],"169.254.10.100");
+        }
+        tds__GetZeroConfigurationResponse->ZeroConfiguration->Extension = NULL;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__tds__SetZeroConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetZeroConfiguration(struct soap* soap, struct _tds__SetZeroConfiguration *tds__SetZeroConfiguration, struct _tds__SetZeroConfigurationResponse *tds__SetZeroConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetIPAddressFilter' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetIPAddressFilter(struct soap* soap, struct _tds__GetIPAddressFilter *tds__GetIPAddressFilter, struct _tds__GetIPAddressFilterResponse *tds__GetIPAddressFilterResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetIPAddressFilter' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetIPAddressFilter(struct soap* soap, struct _tds__SetIPAddressFilter *tds__SetIPAddressFilter, struct _tds__SetIPAddressFilterResponse *tds__SetIPAddressFilterResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__AddIPAddressFilter' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__AddIPAddressFilter(struct soap* soap, struct _tds__AddIPAddressFilter *tds__AddIPAddressFilter, struct _tds__AddIPAddressFilterResponse *tds__AddIPAddressFilterResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__RemoveIPAddressFilter' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__RemoveIPAddressFilter(struct soap* soap, struct _tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter, struct _tds__RemoveIPAddressFilterResponse *tds__RemoveIPAddressFilterResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetAccessPolicy' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetAccessPolicy(struct soap* soap, struct _tds__GetAccessPolicy *tds__GetAccessPolicy, struct _tds__GetAccessPolicyResponse *tds__GetAccessPolicyResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetAccessPolicy' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetAccessPolicy(struct soap* soap, struct _tds__SetAccessPolicy *tds__SetAccessPolicy, struct _tds__SetAccessPolicyResponse *tds__SetAccessPolicyResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__CreateCertificate' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__CreateCertificate(struct soap* soap, struct _tds__CreateCertificate *tds__CreateCertificate, struct _tds__CreateCertificateResponse *tds__CreateCertificateResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetCertificates' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCertificates(struct soap* soap, struct _tds__GetCertificates *tds__GetCertificates, struct _tds__GetCertificatesResponse *tds__GetCertificatesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetCertificatesStatus' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCertificatesStatus(struct soap* soap, struct _tds__GetCertificatesStatus *tds__GetCertificatesStatus, struct _tds__GetCertificatesStatusResponse *tds__GetCertificatesStatusResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetCertificatesStatus' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetCertificatesStatus(struct soap* soap, struct _tds__SetCertificatesStatus *tds__SetCertificatesStatus, struct _tds__SetCertificatesStatusResponse *tds__SetCertificatesStatusResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__DeleteCertificates' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteCertificates(struct soap* soap, struct _tds__DeleteCertificates *tds__DeleteCertificates, struct _tds__DeleteCertificatesResponse *tds__DeleteCertificatesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetPkcs10Request' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetPkcs10Request(struct soap* soap, struct _tds__GetPkcs10Request *tds__GetPkcs10Request, struct _tds__GetPkcs10RequestResponse *tds__GetPkcs10RequestResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__LoadCertificates' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__LoadCertificates(struct soap* soap, struct _tds__LoadCertificates *tds__LoadCertificates, struct _tds__LoadCertificatesResponse *tds__LoadCertificatesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetClientCertificateMode' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetClientCertificateMode(struct soap* soap, struct _tds__GetClientCertificateMode *tds__GetClientCertificateMode, struct _tds__GetClientCertificateModeResponse *tds__GetClientCertificateModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetClientCertificateMode' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetClientCertificateMode(struct soap* soap, struct _tds__SetClientCertificateMode *tds__SetClientCertificateMode, struct _tds__SetClientCertificateModeResponse *tds__SetClientCertificateModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetRelayOutputs' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetRelayOutputs(struct soap* soap, struct _tds__GetRelayOutputs *tds__GetRelayOutputs, struct _tds__GetRelayOutputsResponse *tds__GetRelayOutputsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetRelayOutputSettings' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRelayOutputSettings(struct soap* soap, struct _tds__SetRelayOutputSettings *tds__SetRelayOutputSettings, struct _tds__SetRelayOutputSettingsResponse *tds__SetRelayOutputSettingsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetRelayOutputState' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRelayOutputState(struct soap* soap, struct _tds__SetRelayOutputState *tds__SetRelayOutputState, struct _tds__SetRelayOutputStateResponse *tds__SetRelayOutputStateResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SendAuxiliaryCommand' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SendAuxiliaryCommand(struct soap* soap, struct _tds__SendAuxiliaryCommand *tds__SendAuxiliaryCommand, struct _tds__SendAuxiliaryCommandResponse *tds__SendAuxiliaryCommandResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetCACertificates' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCACertificates(struct soap* soap, struct _tds__GetCACertificates *tds__GetCACertificates, struct _tds__GetCACertificatesResponse *tds__GetCACertificatesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__LoadCertificateWithPrivateKey' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__LoadCertificateWithPrivateKey(struct soap* soap, struct _tds__LoadCertificateWithPrivateKey *tds__LoadCertificateWithPrivateKey, struct _tds__LoadCertificateWithPrivateKeyResponse *tds__LoadCertificateWithPrivateKeyResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetCertificateInformation' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCertificateInformation(struct soap* soap, struct _tds__GetCertificateInformation *tds__GetCertificateInformation, struct _tds__GetCertificateInformationResponse *tds__GetCertificateInformationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__LoadCACertificates' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__LoadCACertificates(struct soap* soap, struct _tds__LoadCACertificates *tds__LoadCACertificates, struct _tds__LoadCACertificatesResponse *tds__LoadCACertificatesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__CreateDot1XConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__CreateDot1XConfiguration(struct soap* soap, struct _tds__CreateDot1XConfiguration *tds__CreateDot1XConfiguration, struct _tds__CreateDot1XConfigurationResponse *tds__CreateDot1XConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetDot1XConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDot1XConfiguration(struct soap* soap, struct _tds__SetDot1XConfiguration *tds__SetDot1XConfiguration, struct _tds__SetDot1XConfigurationResponse *tds__SetDot1XConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDot1XConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDot1XConfiguration(struct soap* soap, struct _tds__GetDot1XConfiguration *tds__GetDot1XConfiguration, struct _tds__GetDot1XConfigurationResponse *tds__GetDot1XConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDot1XConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDot1XConfigurations(struct soap* soap, struct _tds__GetDot1XConfigurations *tds__GetDot1XConfigurations, struct _tds__GetDot1XConfigurationsResponse *tds__GetDot1XConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__DeleteDot1XConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteDot1XConfiguration(struct soap* soap, struct _tds__DeleteDot1XConfiguration *tds__DeleteDot1XConfiguration, struct _tds__DeleteDot1XConfigurationResponse *tds__DeleteDot1XConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDot11Capabilities' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDot11Capabilities(struct soap* soap, struct _tds__GetDot11Capabilities *tds__GetDot11Capabilities, struct _tds__GetDot11CapabilitiesResponse *tds__GetDot11CapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDot11Status' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDot11Status(struct soap* soap, struct _tds__GetDot11Status *tds__GetDot11Status, struct _tds__GetDot11StatusResponse *tds__GetDot11StatusResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__ScanAvailableDot11Networks' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__ScanAvailableDot11Networks(struct soap* soap, struct _tds__ScanAvailableDot11Networks *tds__ScanAvailableDot11Networks, struct _tds__ScanAvailableDot11NetworksResponse *tds__ScanAvailableDot11NetworksResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetSystemUris' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemUris(struct soap* soap, struct _tds__GetSystemUris *tds__GetSystemUris, struct _tds__GetSystemUrisResponse *tds__GetSystemUrisResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__StartFirmwareUpgrade' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__StartFirmwareUpgrade(struct soap* soap, struct _tds__StartFirmwareUpgrade *tds__StartFirmwareUpgrade, struct _tds__StartFirmwareUpgradeResponse *tds__StartFirmwareUpgradeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__StartSystemRestore' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__StartSystemRestore(struct soap* soap, struct _tds__StartSystemRestore *tds__StartSystemRestore, struct _tds__StartSystemRestoreResponse *tds__StartSystemRestoreResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetStorageConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetStorageConfigurations(struct soap* soap, struct _tds__GetStorageConfigurations *tds__GetStorageConfigurations, struct _tds__GetStorageConfigurationsResponse *tds__GetStorageConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__CreateStorageConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__CreateStorageConfiguration(struct soap* soap, struct _tds__CreateStorageConfiguration *tds__CreateStorageConfiguration, struct _tds__CreateStorageConfigurationResponse *tds__CreateStorageConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetStorageConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetStorageConfiguration(struct soap* soap, struct _tds__GetStorageConfiguration *tds__GetStorageConfiguration, struct _tds__GetStorageConfigurationResponse *tds__GetStorageConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetStorageConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetStorageConfiguration(struct soap* soap, struct _tds__SetStorageConfiguration *tds__SetStorageConfiguration, struct _tds__SetStorageConfigurationResponse *tds__SetStorageConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__DeleteStorageConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteStorageConfiguration(struct soap* soap, struct _tds__DeleteStorageConfiguration *tds__DeleteStorageConfiguration, struct _tds__DeleteStorageConfigurationResponse *tds__DeleteStorageConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetGeoLocation' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetGeoLocation(struct soap* soap, struct _tds__GetGeoLocation *tds__GetGeoLocation, struct _tds__GetGeoLocationResponse *tds__GetGeoLocationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetGeoLocation' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetGeoLocation(struct soap* soap, struct _tds__SetGeoLocation *tds__SetGeoLocation, struct _tds__SetGeoLocationResponse *tds__SetGeoLocationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__DeleteGeoLocation' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteGeoLocation(struct soap* soap, struct _tds__DeleteGeoLocation *tds__DeleteGeoLocation, struct _tds__DeleteGeoLocationResponse *tds__DeleteGeoLocationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetServices_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetServices_(struct soap* soap, struct _tds__GetServices *tds__GetServices, struct _tds__GetServicesResponse *tds__GetServicesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetServiceCapabilities_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetServiceCapabilities_(struct soap* soap, struct _tds__GetServiceCapabilities *tds__GetServiceCapabilities, struct _tds__GetServiceCapabilitiesResponse *tds__GetServiceCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDeviceInformation_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDeviceInformation_(struct soap* soap, struct _tds__GetDeviceInformation *tds__GetDeviceInformation, struct _tds__GetDeviceInformationResponse *tds__GetDeviceInformationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetSystemDateAndTime_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetSystemDateAndTime_(struct soap* soap, struct _tds__SetSystemDateAndTime *tds__SetSystemDateAndTime, struct _tds__SetSystemDateAndTimeResponse *tds__SetSystemDateAndTimeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetSystemDateAndTime_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemDateAndTime_(struct soap* soap, struct _tds__GetSystemDateAndTime *tds__GetSystemDateAndTime, struct _tds__GetSystemDateAndTimeResponse *tds__GetSystemDateAndTimeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetSystemFactoryDefault_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetSystemFactoryDefault_(struct soap* soap, struct _tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault, struct _tds__SetSystemFactoryDefaultResponse *tds__SetSystemFactoryDefaultResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__UpgradeSystemFirmware_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__UpgradeSystemFirmware_(struct soap* soap, struct _tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware, struct _tds__UpgradeSystemFirmwareResponse *tds__UpgradeSystemFirmwareResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SystemReboot_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SystemReboot_(struct soap* soap, struct _tds__SystemReboot *tds__SystemReboot, struct _tds__SystemRebootResponse *tds__SystemRebootResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__RestoreSystem_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__RestoreSystem_(struct soap* soap, struct _tds__RestoreSystem *tds__RestoreSystem, struct _tds__RestoreSystemResponse *tds__RestoreSystemResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetSystemBackup_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemBackup_(struct soap* soap, struct _tds__GetSystemBackup *tds__GetSystemBackup, struct _tds__GetSystemBackupResponse *tds__GetSystemBackupResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetSystemLog_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemLog_(struct soap* soap, struct _tds__GetSystemLog *tds__GetSystemLog, struct _tds__GetSystemLogResponse *tds__GetSystemLogResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetSystemSupportInformation_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemSupportInformation_(struct soap* soap, struct _tds__GetSystemSupportInformation *tds__GetSystemSupportInformation, struct _tds__GetSystemSupportInformationResponse *tds__GetSystemSupportInformationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetScopes_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetScopes_(struct soap* soap, struct _tds__GetScopes *tds__GetScopes, struct _tds__GetScopesResponse *tds__GetScopesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetScopes_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetScopes_(struct soap* soap, struct _tds__SetScopes *tds__SetScopes, struct _tds__SetScopesResponse *tds__SetScopesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__AddScopes_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__AddScopes_(struct soap* soap, struct _tds__AddScopes *tds__AddScopes, struct _tds__AddScopesResponse *tds__AddScopesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__RemoveScopes_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__RemoveScopes_(struct soap* soap, struct _tds__RemoveScopes *tds__RemoveScopes, struct _tds__RemoveScopesResponse *tds__RemoveScopesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDiscoveryMode_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDiscoveryMode_(struct soap* soap, struct _tds__GetDiscoveryMode *tds__GetDiscoveryMode, struct _tds__GetDiscoveryModeResponse *tds__GetDiscoveryModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetDiscoveryMode_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDiscoveryMode_(struct soap* soap, struct _tds__SetDiscoveryMode *tds__SetDiscoveryMode, struct _tds__SetDiscoveryModeResponse *tds__SetDiscoveryModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetRemoteDiscoveryMode_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetRemoteDiscoveryMode_(struct soap* soap, struct _tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode, struct _tds__GetRemoteDiscoveryModeResponse *tds__GetRemoteDiscoveryModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetRemoteDiscoveryMode_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRemoteDiscoveryMode_(struct soap* soap, struct _tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode, struct _tds__SetRemoteDiscoveryModeResponse *tds__SetRemoteDiscoveryModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDPAddresses_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDPAddresses_(struct soap* soap, struct _tds__GetDPAddresses *tds__GetDPAddresses, struct _tds__GetDPAddressesResponse *tds__GetDPAddressesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetEndpointReference_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetEndpointReference_(struct soap* soap, struct _tds__GetEndpointReference *tds__GetEndpointReference, struct _tds__GetEndpointReferenceResponse *tds__GetEndpointReferenceResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetRemoteUser_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetRemoteUser_(struct soap* soap, struct _tds__GetRemoteUser *tds__GetRemoteUser, struct _tds__GetRemoteUserResponse *tds__GetRemoteUserResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetRemoteUser_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRemoteUser_(struct soap* soap, struct _tds__SetRemoteUser *tds__SetRemoteUser, struct _tds__SetRemoteUserResponse *tds__SetRemoteUserResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetUsers_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetUsers_(struct soap* soap, struct _tds__GetUsers *tds__GetUsers, struct _tds__GetUsersResponse *tds__GetUsersResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__CreateUsers_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__CreateUsers_(struct soap* soap, struct _tds__CreateUsers *tds__CreateUsers, struct _tds__CreateUsersResponse *tds__CreateUsersResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__DeleteUsers_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteUsers_(struct soap* soap, struct _tds__DeleteUsers *tds__DeleteUsers, struct _tds__DeleteUsersResponse *tds__DeleteUsersResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetUser_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetUser_(struct soap* soap, struct _tds__SetUser *tds__SetUser, struct _tds__SetUserResponse *tds__SetUserResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetWsdlUrl_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetWsdlUrl_(struct soap* soap, struct _tds__GetWsdlUrl *tds__GetWsdlUrl, struct _tds__GetWsdlUrlResponse *tds__GetWsdlUrlResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetCapabilities_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCapabilities_(struct soap* soap, struct _tds__GetCapabilities *tds__GetCapabilities, struct _tds__GetCapabilitiesResponse *tds__GetCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetDPAddresses_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDPAddresses_(struct soap* soap, struct _tds__SetDPAddresses *tds__SetDPAddresses, struct _tds__SetDPAddressesResponse *tds__SetDPAddressesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetHostname_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetHostname_(struct soap* soap, struct _tds__GetHostname *tds__GetHostname, struct _tds__GetHostnameResponse *tds__GetHostnameResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetHostname_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetHostname_(struct soap* soap, struct _tds__SetHostname *tds__SetHostname, struct _tds__SetHostnameResponse *tds__SetHostnameResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetHostnameFromDHCP_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetHostnameFromDHCP_(struct soap* soap, struct _tds__SetHostnameFromDHCP *tds__SetHostnameFromDHCP, struct _tds__SetHostnameFromDHCPResponse *tds__SetHostnameFromDHCPResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDNS_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDNS_(struct soap* soap, struct _tds__GetDNS *tds__GetDNS, struct _tds__GetDNSResponse *tds__GetDNSResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetDNS_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDNS_(struct soap* soap, struct _tds__SetDNS *tds__SetDNS, struct _tds__SetDNSResponse *tds__SetDNSResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetNTP_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNTP_(struct soap* soap, struct _tds__GetNTP *tds__GetNTP, struct _tds__GetNTPResponse *tds__GetNTPResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetNTP_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNTP_(struct soap* soap, struct _tds__SetNTP *tds__SetNTP, struct _tds__SetNTPResponse *tds__SetNTPResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDynamicDNS_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDynamicDNS_(struct soap* soap, struct _tds__GetDynamicDNS *tds__GetDynamicDNS, struct _tds__GetDynamicDNSResponse *tds__GetDynamicDNSResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetDynamicDNS_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDynamicDNS_(struct soap* soap, struct _tds__SetDynamicDNS *tds__SetDynamicDNS, struct _tds__SetDynamicDNSResponse *tds__SetDynamicDNSResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetNetworkInterfaces_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNetworkInterfaces_(struct soap* soap, struct _tds__GetNetworkInterfaces *tds__GetNetworkInterfaces, struct _tds__GetNetworkInterfacesResponse *tds__GetNetworkInterfacesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetNetworkInterfaces_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNetworkInterfaces_(struct soap* soap, struct _tds__SetNetworkInterfaces *tds__SetNetworkInterfaces, struct _tds__SetNetworkInterfacesResponse *tds__SetNetworkInterfacesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetNetworkProtocols_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNetworkProtocols_(struct soap* soap, struct _tds__GetNetworkProtocols *tds__GetNetworkProtocols, struct _tds__GetNetworkProtocolsResponse *tds__GetNetworkProtocolsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetNetworkProtocols_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNetworkProtocols_(struct soap* soap, struct _tds__SetNetworkProtocols *tds__SetNetworkProtocols, struct _tds__SetNetworkProtocolsResponse *tds__SetNetworkProtocolsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetNetworkDefaultGateway_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNetworkDefaultGateway_(struct soap* soap, struct _tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway, struct _tds__GetNetworkDefaultGatewayResponse *tds__GetNetworkDefaultGatewayResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetNetworkDefaultGateway_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNetworkDefaultGateway_(struct soap* soap, struct _tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway, struct _tds__SetNetworkDefaultGatewayResponse *tds__SetNetworkDefaultGatewayResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetZeroConfiguration_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetZeroConfiguration_(struct soap* soap, struct _tds__GetZeroConfiguration *tds__GetZeroConfiguration, struct _tds__GetZeroConfigurationResponse *tds__GetZeroConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetZeroConfiguration_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetZeroConfiguration_(struct soap* soap, struct _tds__SetZeroConfiguration *tds__SetZeroConfiguration, struct _tds__SetZeroConfigurationResponse *tds__SetZeroConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetIPAddressFilter_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetIPAddressFilter_(struct soap* soap, struct _tds__GetIPAddressFilter *tds__GetIPAddressFilter, struct _tds__GetIPAddressFilterResponse *tds__GetIPAddressFilterResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetIPAddressFilter_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetIPAddressFilter_(struct soap* soap, struct _tds__SetIPAddressFilter *tds__SetIPAddressFilter, struct _tds__SetIPAddressFilterResponse *tds__SetIPAddressFilterResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__AddIPAddressFilter_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__AddIPAddressFilter_(struct soap* soap, struct _tds__AddIPAddressFilter *tds__AddIPAddressFilter, struct _tds__AddIPAddressFilterResponse *tds__AddIPAddressFilterResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__RemoveIPAddressFilter_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__RemoveIPAddressFilter_(struct soap* soap, struct _tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter, struct _tds__RemoveIPAddressFilterResponse *tds__RemoveIPAddressFilterResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetAccessPolicy_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetAccessPolicy_(struct soap* soap, struct _tds__GetAccessPolicy *tds__GetAccessPolicy, struct _tds__GetAccessPolicyResponse *tds__GetAccessPolicyResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetAccessPolicy_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetAccessPolicy_(struct soap* soap, struct _tds__SetAccessPolicy *tds__SetAccessPolicy, struct _tds__SetAccessPolicyResponse *tds__SetAccessPolicyResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__CreateCertificate_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__CreateCertificate_(struct soap* soap, struct _tds__CreateCertificate *tds__CreateCertificate, struct _tds__CreateCertificateResponse *tds__CreateCertificateResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetCertificates_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCertificates_(struct soap* soap, struct _tds__GetCertificates *tds__GetCertificates, struct _tds__GetCertificatesResponse *tds__GetCertificatesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetCertificatesStatus_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCertificatesStatus_(struct soap* soap, struct _tds__GetCertificatesStatus *tds__GetCertificatesStatus, struct _tds__GetCertificatesStatusResponse *tds__GetCertificatesStatusResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetCertificatesStatus_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetCertificatesStatus_(struct soap* soap, struct _tds__SetCertificatesStatus *tds__SetCertificatesStatus, struct _tds__SetCertificatesStatusResponse *tds__SetCertificatesStatusResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__DeleteCertificates_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteCertificates_(struct soap* soap, struct _tds__DeleteCertificates *tds__DeleteCertificates, struct _tds__DeleteCertificatesResponse *tds__DeleteCertificatesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetPkcs10Request_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetPkcs10Request_(struct soap* soap, struct _tds__GetPkcs10Request *tds__GetPkcs10Request, struct _tds__GetPkcs10RequestResponse *tds__GetPkcs10RequestResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__LoadCertificates_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__LoadCertificates_(struct soap* soap, struct _tds__LoadCertificates *tds__LoadCertificates, struct _tds__LoadCertificatesResponse *tds__LoadCertificatesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetClientCertificateMode_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetClientCertificateMode_(struct soap* soap, struct _tds__GetClientCertificateMode *tds__GetClientCertificateMode, struct _tds__GetClientCertificateModeResponse *tds__GetClientCertificateModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetClientCertificateMode_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetClientCertificateMode_(struct soap* soap, struct _tds__SetClientCertificateMode *tds__SetClientCertificateMode, struct _tds__SetClientCertificateModeResponse *tds__SetClientCertificateModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetRelayOutputs_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetRelayOutputs_(struct soap* soap, struct _tds__GetRelayOutputs *tds__GetRelayOutputs, struct _tds__GetRelayOutputsResponse *tds__GetRelayOutputsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetRelayOutputSettings_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRelayOutputSettings_(struct soap* soap, struct _tds__SetRelayOutputSettings *tds__SetRelayOutputSettings, struct _tds__SetRelayOutputSettingsResponse *tds__SetRelayOutputSettingsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetRelayOutputState_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRelayOutputState_(struct soap* soap, struct _tds__SetRelayOutputState *tds__SetRelayOutputState, struct _tds__SetRelayOutputStateResponse *tds__SetRelayOutputStateResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SendAuxiliaryCommand_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SendAuxiliaryCommand_(struct soap* soap, struct _tds__SendAuxiliaryCommand *tds__SendAuxiliaryCommand, struct _tds__SendAuxiliaryCommandResponse *tds__SendAuxiliaryCommandResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetCACertificates_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCACertificates_(struct soap* soap, struct _tds__GetCACertificates *tds__GetCACertificates, struct _tds__GetCACertificatesResponse *tds__GetCACertificatesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__LoadCertificateWithPrivateKey_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__LoadCertificateWithPrivateKey_(struct soap* soap, struct _tds__LoadCertificateWithPrivateKey *tds__LoadCertificateWithPrivateKey, struct _tds__LoadCertificateWithPrivateKeyResponse *tds__LoadCertificateWithPrivateKeyResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetCertificateInformation_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCertificateInformation_(struct soap* soap, struct _tds__GetCertificateInformation *tds__GetCertificateInformation, struct _tds__GetCertificateInformationResponse *tds__GetCertificateInformationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__LoadCACertificates_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__LoadCACertificates_(struct soap* soap, struct _tds__LoadCACertificates *tds__LoadCACertificates, struct _tds__LoadCACertificatesResponse *tds__LoadCACertificatesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__CreateDot1XConfiguration_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__CreateDot1XConfiguration_(struct soap* soap, struct _tds__CreateDot1XConfiguration *tds__CreateDot1XConfiguration, struct _tds__CreateDot1XConfigurationResponse *tds__CreateDot1XConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetDot1XConfiguration_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDot1XConfiguration_(struct soap* soap, struct _tds__SetDot1XConfiguration *tds__SetDot1XConfiguration, struct _tds__SetDot1XConfigurationResponse *tds__SetDot1XConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDot1XConfiguration_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDot1XConfiguration_(struct soap* soap, struct _tds__GetDot1XConfiguration *tds__GetDot1XConfiguration, struct _tds__GetDot1XConfigurationResponse *tds__GetDot1XConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDot1XConfigurations_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDot1XConfigurations_(struct soap* soap, struct _tds__GetDot1XConfigurations *tds__GetDot1XConfigurations, struct _tds__GetDot1XConfigurationsResponse *tds__GetDot1XConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__DeleteDot1XConfiguration_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteDot1XConfiguration_(struct soap* soap, struct _tds__DeleteDot1XConfiguration *tds__DeleteDot1XConfiguration, struct _tds__DeleteDot1XConfigurationResponse *tds__DeleteDot1XConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDot11Capabilities_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDot11Capabilities_(struct soap* soap, struct _tds__GetDot11Capabilities *tds__GetDot11Capabilities, struct _tds__GetDot11CapabilitiesResponse *tds__GetDot11CapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetDot11Status_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDot11Status_(struct soap* soap, struct _tds__GetDot11Status *tds__GetDot11Status, struct _tds__GetDot11StatusResponse *tds__GetDot11StatusResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__ScanAvailableDot11Networks_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__ScanAvailableDot11Networks_(struct soap* soap, struct _tds__ScanAvailableDot11Networks *tds__ScanAvailableDot11Networks, struct _tds__ScanAvailableDot11NetworksResponse *tds__ScanAvailableDot11NetworksResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetSystemUris_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemUris_(struct soap* soap, struct _tds__GetSystemUris *tds__GetSystemUris, struct _tds__GetSystemUrisResponse *tds__GetSystemUrisResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__StartFirmwareUpgrade_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__StartFirmwareUpgrade_(struct soap* soap, struct _tds__StartFirmwareUpgrade *tds__StartFirmwareUpgrade, struct _tds__StartFirmwareUpgradeResponse *tds__StartFirmwareUpgradeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__StartSystemRestore_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__StartSystemRestore_(struct soap* soap, struct _tds__StartSystemRestore *tds__StartSystemRestore, struct _tds__StartSystemRestoreResponse *tds__StartSystemRestoreResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetStorageConfigurations_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetStorageConfigurations_(struct soap* soap, struct _tds__GetStorageConfigurations *tds__GetStorageConfigurations, struct _tds__GetStorageConfigurationsResponse *tds__GetStorageConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__CreateStorageConfiguration_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__CreateStorageConfiguration_(struct soap* soap, struct _tds__CreateStorageConfiguration *tds__CreateStorageConfiguration, struct _tds__CreateStorageConfigurationResponse *tds__CreateStorageConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetStorageConfiguration_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetStorageConfiguration_(struct soap* soap, struct _tds__GetStorageConfiguration *tds__GetStorageConfiguration, struct _tds__GetStorageConfigurationResponse *tds__GetStorageConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetStorageConfiguration_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetStorageConfiguration_(struct soap* soap, struct _tds__SetStorageConfiguration *tds__SetStorageConfiguration, struct _tds__SetStorageConfigurationResponse *tds__SetStorageConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__DeleteStorageConfiguration_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteStorageConfiguration_(struct soap* soap, struct _tds__DeleteStorageConfiguration *tds__DeleteStorageConfiguration, struct _tds__DeleteStorageConfigurationResponse *tds__DeleteStorageConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__GetGeoLocation_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__GetGeoLocation_(struct soap* soap, struct _tds__GetGeoLocation *tds__GetGeoLocation, struct _tds__GetGeoLocationResponse *tds__GetGeoLocationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__SetGeoLocation_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__SetGeoLocation_(struct soap* soap, struct _tds__SetGeoLocation *tds__SetGeoLocation, struct _tds__SetGeoLocationResponse *tds__SetGeoLocationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tds__DeleteGeoLocation_' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteGeoLocation_(struct soap* soap, struct _tds__DeleteGeoLocation *tds__DeleteGeoLocation, struct _tds__DeleteGeoLocationResponse *tds__DeleteGeoLocationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
diff --git a/server_interface/deviceIO.c b/server_interface/deviceIO.c
new file mode 100644
index 0000000..87d971b
--- /dev/null
+++ b/server_interface/deviceIO.c
@@ -0,0 +1,148 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include "../utils/mpapi.h"
+/** Web service operation '__tmd__GetServiceCapabilities' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetServiceCapabilities(struct soap* soap, struct _tmd__GetServiceCapabilities *tmd__GetServiceCapabilities, struct _tmd__GetServiceCapabilitiesResponse *tmd__GetServiceCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetRelayOutputOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetRelayOutputOptions(struct soap* soap, struct _tmd__GetRelayOutputOptions *tmd__GetRelayOutputOptions, struct _tmd__GetRelayOutputOptionsResponse *tmd__GetRelayOutputOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetAudioSources' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetAudioSources(struct soap* soap, struct tmd__Get *tmd__GetAudioSources, struct tmd__GetResponse *tmd__GetAudioSourcesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetAudioOutputs' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetAudioOutputs(struct soap* soap, struct tmd__Get *tmd__GetAudioOutputs, struct tmd__GetResponse *tmd__GetAudioOutputsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetVideoSources' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetVideoSources(struct soap* soap, struct tmd__Get *tmd__GetVideoSources, struct tmd__GetResponse *tmd__GetVideoSourcesResponse)
+{ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/*
+{
+printf("[%s],[%d],[%s],[%s] start \n", __FILE__, __LINE__, __TIME__, __func__);
+trt__GetVideoSourcesResponse->__sizeVideoSources = 1;
+if((trt__GetVideoSourcesResponse->VideoSources = (struct tt__VideoSource*)soap_malloc(soap, sizeof(struct tt__VideoSource)*(trt__GetVideoSourcesResponse->__sizeVideoSources))))
+{
+    if((trt__GetVideoSourcesResponse->VideoSources[0].token = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+        strcpy(trt__GetVideoSourcesResponse->VideoSources[0].token,"VideoSource_token");
+    trt__GetVideoSourcesResponse->VideoSources[0].Framerate = 25;
+    if((trt__GetVideoSourcesResponse->VideoSources[0].Resolution = (struct tt__VideoResolution*)soap_malloc(soap, sizeof(struct tt__VideoResolution))))
+    {
+        trt__GetVideoSourcesResponse->VideoSources[0].Resolution->Height = 1080;
+        trt__GetVideoSourcesResponse->VideoSources[0].Resolution->Width = 1920;
+    }
+
+    if(trt__GetVideoSourcesResponse->VideoSources[0].Imaging =(struct tt__ImagingSettings*)soap_malloc(soap, sizeof(struct tt__ImagingSettings)))
+    {
+        if(trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Brightness = (float*)soap_malloc(soap,sizeof(float)))
+            *trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Brightness = 50;
+        if(trt__GetVideoSourcesResponse->VideoSources[0].Imaging->ColorSaturation = (float*)soap_malloc(soap,sizeof(float)))
+            *trt__GetVideoSourcesResponse->VideoSources[0].Imaging->ColorSaturation = 50;
+        if(trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Contrast = (float*)soap_malloc(soap,sizeof(float)))
+            *trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Contrast = 50;
+        trt__GetVideoSourcesResponse->VideoSources[0].Imaging->IrCutFilter = NULL;
+        if(trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Sharpness = (float*)soap_malloc(soap,sizeof(float)))
+            *trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Sharpness = 50;
+        trt__GetVideoSourcesResponse->VideoSources[0].Imaging->BacklightCompensation = NULL;
+        trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Exposure = NULL;
+        trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Focus = NULL;
+        trt__GetVideoSourcesResponse->VideoSources[0].Imaging->WideDynamicRange = NULL;
+        trt__GetVideoSourcesResponse->VideoSources[0].Imaging->WhiteBalance = NULL;
+        trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Extension = NULL;
+        trt__GetVideoSourcesResponse->VideoSources[0].Imaging->__anyAttribute = NULL;
+    }
+    trt__GetVideoSourcesResponse->VideoSources[0].Extension = NULL;
+    trt__GetVideoSourcesResponse->VideoSources[0].__anyAttribute = NULL;
+
+    return SOAP_OK;
+}
+return SOAP_ERR;
+}
+*/
+/** Web service operation '__tmd__GetVideoOutputs' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetVideoOutputs(struct soap* soap, struct _tmd__GetVideoOutputs *tmd__GetVideoOutputs, struct _tmd__GetVideoOutputsResponse *tmd__GetVideoOutputsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetVideoSourceConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetVideoSourceConfiguration(struct soap* soap, struct _tmd__GetVideoSourceConfiguration *tmd__GetVideoSourceConfiguration, struct _tmd__GetVideoSourceConfigurationResponse *tmd__GetVideoSourceConfigurationResponse)
+{
+LOG(INFO,"start !\n");
+return SOAP_OK;
+}
+
+/** Web service operation '__tmd__GetVideoOutputConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetVideoOutputConfiguration(struct soap* soap, struct _tmd__GetVideoOutputConfiguration *tmd__GetVideoOutputConfiguration, struct _tmd__GetVideoOutputConfigurationResponse *tmd__GetVideoOutputConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetAudioSourceConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetAudioSourceConfiguration(struct soap* soap, struct _tmd__GetAudioSourceConfiguration *tmd__GetAudioSourceConfiguration, struct _tmd__GetAudioSourceConfigurationResponse *tmd__GetAudioSourceConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetAudioOutputConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetAudioOutputConfiguration(struct soap* soap, struct _tmd__GetAudioOutputConfiguration *tmd__GetAudioOutputConfiguration, struct _tmd__GetAudioOutputConfigurationResponse *tmd__GetAudioOutputConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__SetVideoSourceConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetVideoSourceConfiguration(struct soap* soap, struct _tmd__SetVideoSourceConfiguration *tmd__SetVideoSourceConfiguration, struct _tmd__SetVideoSourceConfigurationResponse *tmd__SetVideoSourceConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__SetVideoOutputConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetVideoOutputConfiguration(struct soap* soap, struct _tmd__SetVideoOutputConfiguration *tmd__SetVideoOutputConfiguration, struct _tmd__SetVideoOutputConfigurationResponse *tmd__SetVideoOutputConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__SetAudioSourceConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetAudioSourceConfiguration(struct soap* soap, struct _tmd__SetAudioSourceConfiguration *tmd__SetAudioSourceConfiguration, struct _tmd__SetAudioSourceConfigurationResponse *tmd__SetAudioSourceConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__SetAudioOutputConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetAudioOutputConfiguration(struct soap* soap, struct _tmd__SetAudioOutputConfiguration *tmd__SetAudioOutputConfiguration, struct _tmd__SetAudioOutputConfigurationResponse *tmd__SetAudioOutputConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetVideoSourceConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetVideoSourceConfigurationOptions(struct soap* soap, struct _tmd__GetVideoSourceConfigurationOptions *tmd__GetVideoSourceConfigurationOptions, struct _tmd__GetVideoSourceConfigurationOptionsResponse *tmd__GetVideoSourceConfigurationOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetVideoOutputConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetVideoOutputConfigurationOptions(struct soap* soap, struct _tmd__GetVideoOutputConfigurationOptions *tmd__GetVideoOutputConfigurationOptions, struct _tmd__GetVideoOutputConfigurationOptionsResponse *tmd__GetVideoOutputConfigurationOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetAudioSourceConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetAudioSourceConfigurationOptions(struct soap* soap, struct _tmd__GetAudioSourceConfigurationOptions *tmd__GetAudioSourceConfigurationOptions, struct _tmd__GetAudioSourceConfigurationOptionsResponse *tmd__GetAudioSourceConfigurationOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetAudioOutputConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetAudioOutputConfigurationOptions(struct soap* soap, struct _tmd__GetAudioOutputConfigurationOptions *tmd__GetAudioOutputConfigurationOptions, struct _tmd__GetAudioOutputConfigurationOptionsResponse *tmd__GetAudioOutputConfigurationOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetRelayOutputs' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetRelayOutputs(struct soap* soap, struct _tds__GetRelayOutputs *tds__GetRelayOutputs, struct _tds__GetRelayOutputsResponse *tds__GetRelayOutputsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__SetRelayOutputSettings' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetRelayOutputSettings(struct soap* soap, struct _tmd__SetRelayOutputSettings *tmd__SetRelayOutputSettings, struct _tmd__SetRelayOutputSettingsResponse *tmd__SetRelayOutputSettingsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__SetRelayOutputState' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetRelayOutputState(struct soap* soap, struct _tds__SetRelayOutputState *tds__SetRelayOutputState, struct _tds__SetRelayOutputStateResponse *tds__SetRelayOutputStateResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetDigitalInputs' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetDigitalInputs(struct soap* soap, struct _tmd__GetDigitalInputs *tmd__GetDigitalInputs, struct _tmd__GetDigitalInputsResponse *tmd__GetDigitalInputsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetDigitalInputConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetDigitalInputConfigurationOptions(struct soap* soap, struct _tmd__GetDigitalInputConfigurationOptions *tmd__GetDigitalInputConfigurationOptions, struct _tmd__GetDigitalInputConfigurationOptionsResponse *tmd__GetDigitalInputConfigurationOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__SetDigitalInputConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetDigitalInputConfigurations(struct soap* soap, struct _tmd__SetDigitalInputConfigurations *tmd__SetDigitalInputConfigurations, struct _tmd__SetDigitalInputConfigurationsResponse *tmd__SetDigitalInputConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetSerialPorts' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetSerialPorts(struct soap* soap, struct _tmd__GetSerialPorts *tmd__GetSerialPorts, struct _tmd__GetSerialPortsResponse *tmd__GetSerialPortsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetSerialPortConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetSerialPortConfiguration(struct soap* soap, struct _tmd__GetSerialPortConfiguration *tmd__GetSerialPortConfiguration, struct _tmd__GetSerialPortConfigurationResponse *tmd__GetSerialPortConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__SetSerialPortConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetSerialPortConfiguration(struct soap* soap, struct _tmd__SetSerialPortConfiguration *tmd__SetSerialPortConfiguration, struct _tmd__SetSerialPortConfigurationResponse *tmd__SetSerialPortConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__GetSerialPortConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetSerialPortConfigurationOptions(struct soap* soap, struct _tmd__GetSerialPortConfigurationOptions *tmd__GetSerialPortConfigurationOptions, struct _tmd__GetSerialPortConfigurationOptionsResponse *tmd__GetSerialPortConfigurationOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tmd__SendReceiveSerialCommand' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tmd__SendReceiveSerialCommand(struct soap* soap, struct _tmd__SendReceiveSerialCommand *tmd__SendReceiveSerialCommand, struct _tmd__SendReceiveSerialCommandResponse *tmd__SendReceiveSerialCommandResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
diff --git a/server_interface/discovery.c b/server_interface/discovery.c
new file mode 100755
index 0000000..2a33b47
--- /dev/null
+++ b/server_interface/discovery.c
@@ -0,0 +1,247 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include "../utils/mpapi.h"
+/******************************************************************************\
+ *                                                                            *
+ * Server-Side Operations                                                     *
+ *                                                                            *
+\******************************************************************************/
+int iInterfaceNum=1;
+    /** Web service operation 'SOAP_ENV__Fault' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 SOAP_ENV__Fault(struct soap* soap, char *faultcode, char *faultstring, char *faultactor, struct SOAP_ENV__Detail *detail, struct SOAP_ENV__Code *SOAP_ENV__Code, struct SOAP_ENV__Reason *SOAP_ENV__Reason, char *SOAP_ENV__Node, char *SOAP_ENV__Role, struct SOAP_ENV__Detail *SOAP_ENV__Detail){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__wsdd__Hello' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __wsdd__Hello(struct soap* soap, struct wsdd__HelloType *wsdd__Hello){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__wsdd__Bye' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __wsdd__Bye(struct soap* soap, struct wsdd__ByeType *wsdd__Bye){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__wsdd__Probe' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __wsdd__Probe(struct soap* soap, struct wsdd__ProbeType *wsdd__Probe)
+    {
+        LOG(INFO,"start !\n");
+        char _IPAddr[INFO_LENGTH] = {0};
+        char _HwId[1024] = {0};
+        int i;
+
+        wsdd__ProbeMatchesType ProbeMatches;
+        ProbeMatches.__sizeProbeMatch = 1;
+
+        if((ProbeMatches.ProbeMatch = (struct wsdd__ProbeMatchType *)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchType))))
+        {
+            for(i = 0;i < iInterfaceNum; i++)
+            {
+                if((ProbeMatches.ProbeMatch[i].XAddrs = (char *)soap_malloc(soap, sizeof(char) * INFO_LENGTH)))
+                {
+                    //Server_Ip
+                    sprintf(_IPAddr, "http://%s/onvif/device_service", get_local_ip());
+                    LOG(INFO,"_IPAddr ==== %s\n", _IPAddr);
+                    strcpy(ProbeMatches.ProbeMatch[i].XAddrs, _IPAddr);
+                }
+                if((ProbeMatches.ProbeMatch[i].Types = (char *)soap_malloc(soap, sizeof(char) * INFO_LENGTH)))
+                {
+                    strcpy(ProbeMatches.ProbeMatch[i].Types, wsdd__Probe->Types);
+                }
+                if((ProbeMatches.ProbeMatch[i].Scopes = (struct wsdd__ScopesType*)soap_malloc(soap,sizeof(struct wsdd__ScopesType))))
+                {
+                    if((ProbeMatches.ProbeMatch[i].Scopes->__item =(char *)soap_malloc(soap, 1024)))
+                        strcpy(ProbeMatches.ProbeMatch[i].Scopes->__item, "onvif://www.onvif.org/type/NetworkVideoTransmitter");
+                    ProbeMatches.ProbeMatch[i].Scopes->MatchBy = NULL;
+                }
+                if((ProbeMatches.ProbeMatch[i].wsa__EndpointReference.ReferenceProperties = (struct wsa__ReferencePropertiesType*)soap_malloc(soap,sizeof(struct wsa__ReferencePropertiesType))))
+                {
+                    ProbeMatches.ProbeMatch[i].wsa__EndpointReference.ReferenceProperties->__size = 0;
+                    ProbeMatches.ProbeMatch[i].wsa__EndpointReference.ReferenceProperties->__any = NULL;
+                }
+                if((ProbeMatches.ProbeMatch[i].wsa__EndpointReference.ReferenceParameters = (struct wsa__ReferenceParametersType*)soap_malloc(soap,sizeof(struct wsa__ReferenceParametersType))))
+                {
+                    ProbeMatches.ProbeMatch[i].wsa__EndpointReference.ReferenceParameters->__size = 0;
+                    ProbeMatches.ProbeMatch[i].wsa__EndpointReference.ReferenceParameters->__any = NULL;
+                }
+                if((ProbeMatches.ProbeMatch[i].wsa__EndpointReference.ServiceName = (struct wsa__ServiceNameType*)soap_malloc(soap,sizeof(struct wsa__ServiceNameType))))
+                {
+                    ProbeMatches.ProbeMatch[i].wsa__EndpointReference.ServiceName->__item = NULL;
+                    ProbeMatches.ProbeMatch[i].wsa__EndpointReference.ServiceName->PortName = NULL;
+                    ProbeMatches.ProbeMatch[i].wsa__EndpointReference.ServiceName->__anyAttribute = NULL;
+                }
+                if((ProbeMatches.ProbeMatch[i].wsa__EndpointReference.PortType = (char **)soap_malloc(soap, sizeof(char *) * SMALL_INFO_LENGTH)))
+                    if((ProbeMatches.ProbeMatch[i].wsa__EndpointReference.PortType[0] = (char *)soap_malloc(soap, sizeof(char) * SMALL_INFO_LENGTH)))
+                        strcpy(ProbeMatches.ProbeMatch[i].wsa__EndpointReference.PortType[0], "ttl");
+                ProbeMatches.ProbeMatch[i].wsa__EndpointReference.__size = 0;
+                if((ProbeMatches.ProbeMatch[i].wsa__EndpointReference.__any = (char **)soap_malloc(soap, sizeof(char*) * SMALL_INFO_LENGTH)))
+                    if((ProbeMatches.ProbeMatch[i].wsa__EndpointReference.__any[0] = (char *)soap_malloc(soap, sizeof(char) * SMALL_INFO_LENGTH)))
+                        strcpy(ProbeMatches.ProbeMatch[i].wsa__EndpointReference.__any[0], "Any");
+                if((ProbeMatches.ProbeMatch[i].wsa__EndpointReference.__anyAttribute = (char *)soap_malloc(soap, sizeof(char) * SMALL_INFO_LENGTH)))
+                    strcpy(ProbeMatches.ProbeMatch[i].wsa__EndpointReference.__anyAttribute, "Attribute");
+                if((ProbeMatches.ProbeMatch[i].wsa__EndpointReference.Address = (char *)soap_malloc(soap, sizeof(char) * INFO_LENGTH)))
+                {
+                    snprintf(_HwId, 128, "%s", soap_rand_uuid(soap, "urn:uuid:2419d68a-2dd2-21b2-a205-"));
+                    strcpy(ProbeMatches.ProbeMatch[i].wsa__EndpointReference.Address, _HwId);
+                }
+                ProbeMatches.ProbeMatch[i].MetadataVersion = 1;
+            }
+        }
+        if((soap->header->wsa__To = (char*)soap_malloc(soap,sizeof(char) * INFO_LENGTH)))
+            soap->header->wsa__To = "http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous";
+        if((soap->header->wsa__Action = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            soap->header->wsa__Action = "http://schemas.xmlsoap.org/ws/2005/04/discovery/ProbeMatches";
+        if((soap->header->wsa__RelatesTo = (struct wsa__Relationship*)soap_malloc(soap, sizeof(struct wsa__Relationship))))
+        {
+            soap->header->wsa__RelatesTo->__item = soap->header->wsa__MessageID;
+            soap->header->wsa__RelatesTo->RelationshipType = NULL;
+            soap->header->wsa__RelatesTo->__anyAttribute = NULL;
+        }
+        if((soap->header->wsa__MessageID =(char *)soap_malloc(soap, sizeof(char) * INFO_LENGTH)))
+            strcpy(soap->header->wsa__MessageID,_HwId+4);
+        if (SOAP_OK == soap_send___wsdd__ProbeMatches(soap, "http://", NULL, &ProbeMatches))
+        {
+            LOG(INFO,"send ProbeMatches success !\n");
+            return SOAP_OK;
+        }
+        LOG(INFO," soap error: %d, %s, %s\n", soap->error, *soap_faultcode(soap), *soap_faultstring(soap));
+        return soap->error;
+    }
+    /** Web service operation '__wsdd__ProbeMatches' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __wsdd__ProbeMatches(struct soap* soap, struct wsdd__ProbeMatchesType *wsdd__ProbeMatches){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__wsdd__Resolve' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __wsdd__Resolve(struct soap* soap, struct wsdd__ResolveType *wsdd__Resolve){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__wsdd__ResolveMatches' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __wsdd__ResolveMatches(struct soap* soap, struct wsdd__ResolveMatchesType *wsdd__ResolveMatches){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns1__GetSupportedActions' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetSupportedActions(struct soap* soap, struct _ns1__GetSupportedActions *ns1__GetSupportedActions, struct _ns1__GetSupportedActionsResponse *ns1__GetSupportedActionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns1__GetActions' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetActions(struct soap* soap, struct _ns1__GetActions *ns1__GetActions, struct _ns1__GetActionsResponse *ns1__GetActionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns1__CreateActions' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns1__CreateActions(struct soap* soap, struct _ns1__CreateActions *ns1__CreateActions, struct _ns1__CreateActionsResponse *ns1__CreateActionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns1__DeleteActions' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns1__DeleteActions(struct soap* soap, struct _ns1__DeleteActions *ns1__DeleteActions, struct _ns1__DeleteActionsResponse *ns1__DeleteActionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns1__ModifyActions' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ModifyActions(struct soap* soap, struct _ns1__ModifyActions *ns1__ModifyActions, struct _ns1__ModifyActionsResponse *ns1__ModifyActionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns1__GetServiceCapabilities' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetServiceCapabilities(struct soap* soap, struct _ns1__GetServiceCapabilities *ns1__GetServiceCapabilities, struct _ns1__GetServiceCapabilitiesResponse *ns1__GetServiceCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns1__GetActionTriggers' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetActionTriggers(struct soap* soap, struct _ns1__GetActionTriggers *ns1__GetActionTriggers, struct _ns1__GetActionTriggersResponse *ns1__GetActionTriggersResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns1__CreateActionTriggers' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns1__CreateActionTriggers(struct soap* soap, struct _ns1__CreateActionTriggers *ns1__CreateActionTriggers, struct _ns1__CreateActionTriggersResponse *ns1__CreateActionTriggersResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns1__DeleteActionTriggers' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns1__DeleteActionTriggers(struct soap* soap, struct _ns1__DeleteActionTriggers *ns1__DeleteActionTriggers, struct _ns1__DeleteActionTriggersResponse *ns1__DeleteActionTriggersResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns1__ModifyActionTriggers' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ModifyActionTriggers(struct soap* soap, struct _ns1__ModifyActionTriggers *ns1__ModifyActionTriggers, struct _ns1__ModifyActionTriggersResponse *ns1__ModifyActionTriggersResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns10__Hello' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns10__Hello(struct soap* soap, struct wsdd__HelloType tdn__Hello, struct wsdd__ResolveType *tdn__HelloResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns10__Bye' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns10__Bye(struct soap* soap, struct wsdd__ByeType tdn__Bye, struct wsdd__ResolveType *tdn__ByeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns11__Probe' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns11__Probe(struct soap* soap, struct wsdd__ProbeType tdn__Probe, struct wsdd__ProbeMatchesType *tdn__ProbeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns12__GetSupportedRules' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns12__GetSupportedRules(struct soap* soap, struct _tan__GetSupportedRules *tan__GetSupportedRules, struct _tan__GetSupportedRulesResponse *tan__GetSupportedRulesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns12__CreateRules' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns12__CreateRules(struct soap* soap, struct _tan__CreateRules *tan__CreateRules, struct _tan__CreateRulesResponse *tan__CreateRulesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns12__DeleteRules' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns12__DeleteRules(struct soap* soap, struct _tan__DeleteRules *tan__DeleteRules, struct _tan__DeleteRulesResponse *tan__DeleteRulesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns12__GetRules' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns12__GetRules(struct soap* soap, struct _tan__GetRules *tan__GetRules, struct _tan__GetRulesResponse *tan__GetRulesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns12__GetRuleOptions' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns12__GetRuleOptions(struct soap* soap, struct _tan__GetRuleOptions *tan__GetRuleOptions, struct _tan__GetRuleOptionsResponse *tan__GetRuleOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns12__ModifyRules' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns12__ModifyRules(struct soap* soap, struct _tan__ModifyRules *tan__ModifyRules, struct _tan__ModifyRulesResponse *tan__ModifyRulesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns13__GetServiceCapabilities' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns13__GetServiceCapabilities(struct soap* soap, struct _tan__GetServiceCapabilities *tan__GetServiceCapabilities, struct _tan__GetServiceCapabilitiesResponse *tan__GetServiceCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns13__GetSupportedAnalyticsModules' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns13__GetSupportedAnalyticsModules(struct soap* soap, struct _tan__GetSupportedAnalyticsModules *tan__GetSupportedAnalyticsModules, struct _tan__GetSupportedAnalyticsModulesResponse *tan__GetSupportedAnalyticsModulesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns13__CreateAnalyticsModules' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns13__CreateAnalyticsModules(struct soap* soap, struct _tan__CreateAnalyticsModules *tan__CreateAnalyticsModules, struct _tan__CreateAnalyticsModulesResponse *tan__CreateAnalyticsModulesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns13__DeleteAnalyticsModules' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns13__DeleteAnalyticsModules(struct soap* soap, struct _tan__DeleteAnalyticsModules *tan__DeleteAnalyticsModules, struct _tan__DeleteAnalyticsModulesResponse *tan__DeleteAnalyticsModulesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns13__GetAnalyticsModules' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns13__GetAnalyticsModules(struct soap* soap, struct _tan__GetAnalyticsModules *tan__GetAnalyticsModules, struct _tan__GetAnalyticsModulesResponse *tan__GetAnalyticsModulesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns13__GetAnalyticsModuleOptions' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns13__GetAnalyticsModuleOptions(struct soap* soap, struct _tan__GetAnalyticsModuleOptions *tan__GetAnalyticsModuleOptions, struct _tan__GetAnalyticsModuleOptionsResponse *tan__GetAnalyticsModuleOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns13__ModifyAnalyticsModules' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns13__ModifyAnalyticsModules(struct soap* soap, struct _tan__ModifyAnalyticsModules *tan__ModifyAnalyticsModules, struct _tan__ModifyAnalyticsModulesResponse *tan__ModifyAnalyticsModulesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns2__PullMessages' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns2__PullMessages(struct soap* soap, struct _tev__PullMessages *tev__PullMessages, struct _tev__PullMessagesResponse *tev__PullMessagesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns2__Seek' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns2__Seek(struct soap* soap, struct _tev__Seek *tev__Seek, struct _tev__SeekResponse *tev__SeekResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns2__SetSynchronizationPoint' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns2__SetSynchronizationPoint(struct soap* soap, struct _tev__SetSynchronizationPoint *tev__SetSynchronizationPoint, struct _tev__SetSynchronizationPointResponse *tev__SetSynchronizationPointResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns3__GetServiceCapabilities' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns3__GetServiceCapabilities(struct soap* soap, struct _tev__GetServiceCapabilities *tev__GetServiceCapabilities, struct _tev__GetServiceCapabilitiesResponse *tev__GetServiceCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns3__CreatePullPointSubscription' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns3__CreatePullPointSubscription(struct soap* soap, struct _tev__CreatePullPointSubscription *tev__CreatePullPointSubscription, struct _tev__CreatePullPointSubscriptionResponse *tev__CreatePullPointSubscriptionResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns3__GetEventProperties' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns3__GetEventProperties(struct soap* soap, struct _tev__GetEventProperties *tev__GetEventProperties, struct _tev__GetEventPropertiesResponse *tev__GetEventPropertiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns4__Renew' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns4__Renew(struct soap* soap, struct _wsnt__Renew *wsnt__Renew, struct _wsnt__RenewResponse *wsnt__RenewResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns4__Unsubscribe' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns4__Unsubscribe(struct soap* soap, struct _wsnt__Unsubscribe *wsnt__Unsubscribe, struct _wsnt__UnsubscribeResponse *wsnt__UnsubscribeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns2__Unsubscribe' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns2__Unsubscribe(struct soap* soap, struct _wsnt__Unsubscribe *wsnt__Unsubscribe, struct _wsnt__UnsubscribeResponse *wsnt__UnsubscribeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns5__Subscribe' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns5__Subscribe(struct soap* soap, struct _wsnt__Subscribe *wsnt__Subscribe, struct _wsnt__SubscribeResponse *wsnt__SubscribeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns5__GetCurrentMessage' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns5__GetCurrentMessage(struct soap* soap, struct _wsnt__GetCurrentMessage *wsnt__GetCurrentMessage, struct _wsnt__GetCurrentMessageResponse *wsnt__GetCurrentMessageResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns6__Notify' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns6__Notify(struct soap* soap, struct _wsnt__Notify *wsnt__Notify){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns7__GetMessages' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns7__GetMessages(struct soap* soap, struct _wsnt__GetMessages *wsnt__GetMessages, struct _wsnt__GetMessagesResponse *wsnt__GetMessagesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns7__DestroyPullPoint' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns7__DestroyPullPoint(struct soap* soap, struct _wsnt__DestroyPullPoint *wsnt__DestroyPullPoint, struct _wsnt__DestroyPullPointResponse *wsnt__DestroyPullPointResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns7__Notify' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns7__Notify(struct soap* soap, struct _wsnt__Notify *wsnt__Notify){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns8__CreatePullPoint' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns8__CreatePullPoint(struct soap* soap, struct _wsnt__CreatePullPoint *wsnt__CreatePullPoint, struct _wsnt__CreatePullPointResponse *wsnt__CreatePullPointResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns9__Renew' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns9__Renew(struct soap* soap, struct _wsnt__Renew *wsnt__Renew, struct _wsnt__RenewResponse *wsnt__RenewResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns9__Unsubscribe' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns9__Unsubscribe(struct soap* soap, struct _wsnt__Unsubscribe *wsnt__Unsubscribe, struct _wsnt__UnsubscribeResponse *wsnt__UnsubscribeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns9__PauseSubscription' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns9__PauseSubscription(struct soap* soap, struct _wsnt__PauseSubscription *wsnt__PauseSubscription, struct _wsnt__PauseSubscriptionResponse *wsnt__PauseSubscriptionResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+    /** Web service operation '__ns9__ResumeSubscription' (returns SOAP_OK or error code) */
+    SOAP_FMAC5 int SOAP_FMAC6 __ns9__ResumeSubscription(struct soap* soap, struct _wsnt__ResumeSubscription *wsnt__ResumeSubscription, struct _wsnt__ResumeSubscriptionResponse *wsnt__ResumeSubscriptionResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Server-Side Skeletons to Invoke Service Operations                         *
+ *                                                                            *
+\******************************************************************************/
+
+
+
diff --git a/server_interface/display.c b/server_interface/display.c
new file mode 100644
index 0000000..3b0d06e
--- /dev/null
+++ b/server_interface/display.c
@@ -0,0 +1,62 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include "../utils/mpapi.h"
+/** Web service operation '__tls__GetServiceCapabilities' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tls__GetServiceCapabilities(struct soap* soap, struct _tls__GetServiceCapabilities *tls__GetServiceCapabilities, struct _tls__GetServiceCapabilitiesResponse *tls__GetServiceCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tls__GetLayout' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tls__GetLayout(struct soap* soap, struct _tls__GetLayout *tls__GetLayout, struct _tls__GetLayoutResponse *tls__GetLayoutResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tls__SetLayout' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tls__SetLayout(struct soap* soap, struct _tls__SetLayout *tls__SetLayout, struct _tls__SetLayoutResponse *tls__SetLayoutResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tls__GetDisplayOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tls__GetDisplayOptions(struct soap* soap, struct _tls__GetDisplayOptions *tls__GetDisplayOptions, struct _tls__GetDisplayOptionsResponse *tls__GetDisplayOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tls__GetPaneConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tls__GetPaneConfigurations(struct soap* soap, struct _tls__GetPaneConfigurations *tls__GetPaneConfigurations, struct _tls__GetPaneConfigurationsResponse *tls__GetPaneConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tls__GetPaneConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tls__GetPaneConfiguration(struct soap* soap, struct _tls__GetPaneConfiguration *tls__GetPaneConfiguration, struct _tls__GetPaneConfigurationResponse *tls__GetPaneConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tls__SetPaneConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tls__SetPaneConfigurations(struct soap* soap, struct _tls__SetPaneConfigurations *tls__SetPaneConfigurations, struct _tls__SetPaneConfigurationsResponse *tls__SetPaneConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tls__SetPaneConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tls__SetPaneConfiguration(struct soap* soap, struct _tls__SetPaneConfiguration *tls__SetPaneConfiguration, struct _tls__SetPaneConfigurationResponse *tls__SetPaneConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tls__CreatePaneConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tls__CreatePaneConfiguration(struct soap* soap, struct _tls__CreatePaneConfiguration *tls__CreatePaneConfiguration, struct _tls__CreatePaneConfigurationResponse *tls__CreatePaneConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tls__DeletePaneConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tls__DeletePaneConfiguration(struct soap* soap, struct _tls__DeletePaneConfiguration *tls__DeletePaneConfiguration, struct _tls__DeletePaneConfigurationResponse *tls__DeletePaneConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
diff --git a/server_interface/imaging.c b/server_interface/imaging.c
new file mode 100644
index 0000000..64fed17
--- /dev/null
+++ b/server_interface/imaging.c
@@ -0,0 +1,349 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include "../utils/mpapi.h"
+/** Web service operation '__timg__GetServiceCapabilities' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __timg__GetServiceCapabilities(struct soap* soap, struct _timg__GetServiceCapabilities *timg__GetServiceCapabilities, struct _timg__GetServiceCapabilitiesResponse *timg__GetServiceCapabilitiesResponse)
+{
+    LOG(INFO,"start !\n");
+    if((timg__GetServiceCapabilitiesResponse->Capabilities = (struct timg__Capabilities*)soap_malloc(soap,sizeof(struct timg__Capabilities))))
+    {
+        if((timg__GetServiceCapabilitiesResponse->Capabilities->ImageStabilization = (enum xsd__boolean*)soap_malloc(soap,sizeof(enum xsd__boolean))))
+            *timg__GetServiceCapabilitiesResponse->Capabilities->ImageStabilization = xsd__boolean__true_;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__timg__GetImagingSettings' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __timg__GetImagingSettings(struct soap* soap, struct _timg__GetImagingSettings *timg__GetImagingSettings, struct _timg__GetImagingSettingsResponse *timg__GetImagingSettingsResponse)
+{
+    LOG(INFO,"start !\n");
+
+    ImagingSetting img = {0,0,0,0,0,0,0,0};
+    int res_status = 0;
+    _get_image_config(&img,&res_status);
+    if(res_status) {
+        return SOAP_ERR;
+    }
+
+#ifdef _DEBUG_
+    if(timg__GetImagingSettings!=NULL&&timg__GetImagingSettings->VideoSourceToken!=NULL)
+        LOG(DBG,"timg__GetImagingSettings->VideoSourceToken is %s\n",timg__GetImagingSettings->VideoSourceToken);
+#endif
+    if((timg__GetImagingSettingsResponse->ImagingSettings = (struct tt__ImagingSettings20*)soap_malloc(soap,sizeof(struct tt__ImagingSettings20))))
+    {
+        timg__GetImagingSettingsResponse->ImagingSettings->BacklightCompensation = NULL;
+        if((timg__GetImagingSettingsResponse->ImagingSettings->Brightness = (float*)soap_malloc(soap,sizeof(float))))
+            *timg__GetImagingSettingsResponse->ImagingSettings->Brightness = img.brightness;
+        if((timg__GetImagingSettingsResponse->ImagingSettings->ColorSaturation = (float*)soap_malloc(soap,sizeof(float))))
+            *timg__GetImagingSettingsResponse->ImagingSettings->ColorSaturation = img.colorsaturation;
+        if((timg__GetImagingSettingsResponse->ImagingSettings->Contrast = (float*)soap_malloc(soap,sizeof(float))))
+            *timg__GetImagingSettingsResponse->ImagingSettings->Contrast = img.contrast;
+        if((timg__GetImagingSettingsResponse->ImagingSettings->Sharpness = (float*)soap_malloc(soap,sizeof(float))))
+            *timg__GetImagingSettingsResponse->ImagingSettings->Sharpness = img.sharpness;
+
+        if((timg__GetImagingSettingsResponse->ImagingSettings->Exposure = (struct tt__Exposure20*)soap_malloc(soap,sizeof(struct tt__Exposure20))))
+        {
+            if(img.exposuremode!=0)
+            {
+                timg__GetImagingSettingsResponse->ImagingSettings->Exposure->Mode = tt__ExposureMode__MANUAL;
+            }else{
+                timg__GetImagingSettingsResponse->ImagingSettings->Exposure->Mode = tt__ExposureMode__AUTO;
+            }
+
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Exposure->Priority = (enum tt__ExposurePriority*)soap_malloc(soap,sizeof(enum tt__ExposurePriority))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Exposure->Priority = tt__ExposurePriority__FrameRate;
+            timg__GetImagingSettingsResponse->ImagingSettings->Exposure->Window = NULL;
+
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MinExposureTime = (float*)soap_malloc(soap,sizeof(float))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MinExposureTime = 1;
+
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MaxExposureTime = (float*)soap_malloc(soap,sizeof(float))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MaxExposureTime = (img.exposuretime - 90);
+
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MinGain = (float*)soap_malloc(soap,sizeof(float))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MinGain = 1;
+
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MaxGain = (float*)soap_malloc(soap,sizeof(float))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MaxGain = (img.exposuretime - 90);
+
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MinIris = (float*)soap_malloc(soap,sizeof(float))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MinIris = 1;
+
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MaxIris = (float*)soap_malloc(soap,sizeof(float))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MaxIris = (img.exposuretime - 90);
+
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Exposure->ExposureTime= (float*)soap_malloc(soap,sizeof(float))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Exposure->ExposureTime = 1;
+
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MaxIris = (float*)soap_malloc(soap,sizeof(float))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Exposure->MaxIris = (img.exposuretime - 90);
+
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Exposure->Gain= (float*)soap_malloc(soap,sizeof(float))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Exposure->Gain = (img.exposuretime - 90);
+
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Exposure->Iris= (float*)soap_malloc(soap,sizeof(float))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Exposure->Iris = (img.exposuretime - 90);
+        }
+        if((timg__GetImagingSettingsResponse->ImagingSettings->Focus = (struct tt__FocusConfiguration20*)soap_malloc(soap,sizeof(struct tt__FocusConfiguration20))))
+        {
+            timg__GetImagingSettingsResponse->ImagingSettings->Focus->AutoFocusMode = tt__AutoFocusMode__AUTO;
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Focus->DefaultSpeed = (float*)soap_malloc(soap,sizeof(float))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Focus->DefaultSpeed = 1;
+            timg__GetImagingSettingsResponse->ImagingSettings->Focus->Extension = NULL;
+            // add by wq
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Focus->NearLimit = (float*)soap_malloc(soap,sizeof(float))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Focus->NearLimit = 1;
+            if((timg__GetImagingSettingsResponse->ImagingSettings->Focus->FarLimit= (float*)soap_malloc(soap,sizeof(float))))
+                *timg__GetImagingSettingsResponse->ImagingSettings->Focus->FarLimit= 1;
+        }
+        timg__GetImagingSettingsResponse->ImagingSettings->IrCutFilter = NULL;
+        timg__GetImagingSettingsResponse->ImagingSettings->WideDynamicRange = NULL;
+        timg__GetImagingSettingsResponse->ImagingSettings->WhiteBalance = NULL;
+        timg__GetImagingSettingsResponse->ImagingSettings->Extension = NULL;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__timg__SetImagingSettings' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __timg__SetImagingSettings(struct soap* soap, struct _timg__SetImagingSettings *timg__SetImagingSettings, struct _timg__SetImagingSettingsResponse *timg__SetImagingSettingsResponse)
+{
+    LOG(INFO,"start !\n");
+    ImagingSetting img = {0,0,0,0,0,0,0,0};
+    int res_status = 0;
+
+    if(timg__SetImagingSettings!=NULL)
+    {
+        if(timg__SetImagingSettings->VideoSourceToken!=NULL)
+        {
+            LOG(INFO,"timg__SetImagingSettings->VideoSourceToken is %s\r\n",timg__SetImagingSettings->VideoSourceToken);
+            if(timg__SetImagingSettings->ImagingSettings!=NULL)
+            {
+                if(timg__SetImagingSettings->ImagingSettings->BacklightCompensation!=NULL)
+                {
+                    LOG(INFO,"timg__SetImagingSettings->ImagingSettings->BacklightCompensation->Mode is %d\r\n",timg__SetImagingSettings->ImagingSettings->BacklightCompensation->Mode);
+                    if(timg__SetImagingSettings->ImagingSettings->BacklightCompensation->Level!=NULL)
+                        LOG(INFO,"timg__SetImagingSettings->ImagingSettings->BacklightCompensation->Level is %f\r\n",*timg__SetImagingSettings->ImagingSettings->BacklightCompensation->Level);
+                }
+                if(timg__SetImagingSettings->ImagingSettings->Brightness!=NULL)
+                {
+                    img.brightness = (int)(*timg__SetImagingSettings->ImagingSettings->Brightness>0 ? *timg__SetImagingSettings->ImagingSettings->Brightness+0.5:*timg__SetImagingSettings->ImagingSettings->Brightness-0.5 );
+                    LOG(INFO,"timg__SetImagingSettings->ImagingSettings->brightness is %lf\r\n",*timg__SetImagingSettings->ImagingSettings->Brightness);
+                }
+                if(timg__SetImagingSettings->ImagingSettings->ColorSaturation!=NULL)
+                {
+                    img.colorsaturation = (int)(*timg__SetImagingSettings->ImagingSettings->ColorSaturation>0 ? *timg__SetImagingSettings->ImagingSettings->ColorSaturation+0.5 : *timg__SetImagingSettings->ImagingSettings->ColorSaturation-0.5);
+                    LOG(INFO,"timg__SetImagingSettings->ImagingSettings->colorsaturation is %lf\r\n",*timg__SetImagingSettings->ImagingSettings->ColorSaturation);
+                }
+                if(timg__SetImagingSettings->ImagingSettings->Contrast!=NULL)
+                {
+                    img.contrast = (int)(*timg__SetImagingSettings->ImagingSettings->Contrast>0 ? *timg__SetImagingSettings->ImagingSettings->Contrast+0.5 : *timg__SetImagingSettings->ImagingSettings->Contrast-0.5);
+                    LOG(INFO,"timg__SetImagingSettings->ImagingSettings->contrast is %lf\r\n",*timg__SetImagingSettings->ImagingSettings->Contrast);
+                }
+                if(timg__SetImagingSettings->ImagingSettings->Exposure!=NULL)
+                {
+                    img.exposuremode = timg__SetImagingSettings->ImagingSettings->Exposure->Mode;
+                    LOG(INFO,"timg__SetImagingSettings->ImagingSettings->Exposure->Mode is %d\r\n",timg__SetImagingSettings->ImagingSettings->Exposure->Mode);
+                    if(timg__SetImagingSettings->ImagingSettings->Exposure->Priority!=NULL)
+                        LOG(INFO,"timg__SetImagingSettings->ImagingSettings->Exposure->Priority is %d\r\n",*timg__SetImagingSettings->ImagingSettings->Exposure->Priority);
+                    if(timg__SetImagingSettings->ImagingSettings->Exposure->MinExposureTime!=NULL)
+                        LOG(INFO,"timg__SetImagingSettings->ImagingSettings->Exposure->Minexposuretime is %lf\r\n",*timg__SetImagingSettings->ImagingSettings->Exposure->MinExposureTime);
+                    if(timg__SetImagingSettings->ImagingSettings->Exposure->ExposureTime!=NULL)
+                    {
+                        //                      img.exposuretime = (int)(*timg__SetImagingSettings->ImagingSettings->Exposure->ExposureTime>0 ?*timg__SetImagingSettings->ImagingSettings->Exposure->ExposureTime+0.5 : *timg__SetImagingSettings->ImagingSettings->Exposure->ExposureTime-0.5);
+                        LOG(INFO,"timg__SetImagingSettings->ImagingSettings->Exposure->exposuretime is %lf\r\n",*timg__SetImagingSettings->ImagingSettings->Exposure->ExposureTime);
+                    }
+                    if(timg__SetImagingSettings->ImagingSettings->Exposure->Gain!=NULL)
+                        LOG(INFO,"timg__SetImagingSettings->ImagingSettings->Exposure->Gain is %lf\r\n",*timg__SetImagingSettings->ImagingSettings->Exposure->Gain);
+                    if(timg__SetImagingSettings->ImagingSettings->Exposure->Iris!=NULL)
+                    {
+                        //                      img.irislevel = (int)(*timg__SetImagingSettings->ImagingSettings->Exposure->Iris>0 ? *timg__SetImagingSettings->ImagingSettings->Exposure->Iris+0.5 : *timg__SetImagingSettings->ImagingSettings->Exposure->Iris-0.5);
+                        img.exposuretime = (int)(*timg__SetImagingSettings->ImagingSettings->Exposure->Iris>0 ? *timg__SetImagingSettings->ImagingSettings->Exposure->Iris+0.5 : *timg__SetImagingSettings->ImagingSettings->Exposure->Iris-0.5);
+                        img.exposuretime = img.exposuretime + 90;
+                        LOG(INFO,"timg__SetImagingSettings->ImagingSettings->Exposure->Iris is %lf\r\n",*timg__SetImagingSettings->ImagingSettings->Exposure->Iris);
+                    }
+                }
+                if(timg__SetImagingSettings->ImagingSettings->Focus!=NULL)
+                {
+                    LOG(INFO,"timg__SetImagingSettings->ImagingSettings->Focus->AutoFocusMode is %d\r\n",timg__SetImagingSettings->ImagingSettings->Focus->AutoFocusMode);
+                    if(timg__SetImagingSettings->ImagingSettings->Focus->DefaultSpeed!=NULL)
+                        LOG(INFO,"timg__SetImagingSettings->ImagingSettings->Focus->DefaultSpeed is %lf\r\n",*timg__SetImagingSettings->ImagingSettings->Focus->DefaultSpeed);
+                    if(timg__SetImagingSettings->ImagingSettings->Focus->NearLimit!=NULL)
+                        LOG(INFO,"timg__SetImagingSettings->ImagingSettings->Focus->NearLimit is %lf\r\n",*timg__SetImagingSettings->ImagingSettings->Focus->NearLimit);
+                    if(timg__SetImagingSettings->ImagingSettings->Focus->FarLimit!=NULL)
+                        LOG(INFO,"timg__SetImagingSettings->ImagingSettings->Focus->FarLimit is %lf\r\n",*timg__SetImagingSettings->ImagingSettings->Focus->FarLimit);
+                }
+                if(timg__SetImagingSettings->ImagingSettings->IrCutFilter!=NULL)
+                {
+                    if(*timg__SetImagingSettings->ImagingSettings->IrCutFilter == 1){
+                        img.irismode = 1;
+                    }else if(*timg__SetImagingSettings->ImagingSettings->IrCutFilter == 2){
+                        img.irismode = 0;
+                    }else if(*timg__SetImagingSettings->ImagingSettings->IrCutFilter == 3){
+                        img.irismode = 2;
+                    }
+
+                    LOG(INFO,"timg__SetImagingSettings->ImagingSettings->IrCutFilter is %d\r\n",*timg__SetImagingSettings->ImagingSettings->IrCutFilter);
+                }
+                if(timg__SetImagingSettings->ImagingSettings->Sharpness!=NULL)
+                {
+                    img.sharpness = (int)(*timg__SetImagingSettings->ImagingSettings->Sharpness>0 ? *timg__SetImagingSettings->ImagingSettings->Sharpness+0.5 : *timg__SetImagingSettings->ImagingSettings->Sharpness-0.5);
+                    LOG(INFO,"timg__SetImagingSettings->ImagingSettings->sharpness is %lf\r\n",*timg__SetImagingSettings->ImagingSettings->Sharpness);
+                }
+                if(timg__SetImagingSettings->ImagingSettings->WideDynamicRange!=NULL)
+                {
+                    LOG(INFO,"timg__SetImagingSettings->ImagingSettings->WideDynamicRange->Mode is %d\r\n",timg__SetImagingSettings->ImagingSettings->WideDynamicRange->Mode);
+                    if(timg__SetImagingSettings->ImagingSettings->WideDynamicRange->Level)
+                        LOG(INFO,"timg__SetImagingSettings->ImagingSettings->WideDynamicRange->Level is %lf\r\n",*timg__SetImagingSettings->ImagingSettings->WideDynamicRange->Level);
+                }
+            }
+        }
+
+        _set_image_config(&img,&res_status);
+        if(!res_status)
+            return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__timg__GetOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __timg__GetOptions(struct soap* soap, struct _timg__GetOptions *timg__GetOptions, struct _timg__GetOptionsResponse *timg__GetOptionsResponse)
+{
+    LOG(INFO,"start !\n");
+    Options opt = {0,0,0,0,0,0,0,0,0,0,0,0} ;
+    int res_status = 0;
+    _get_range(&opt, &res_status);
+    if(res_status) {
+        return SOAP_ERR;
+    }
+#ifdef _DEBUG_
+    if(timg__GetOptions!=NULL&&timg__GetOptions->VideoSourceToken!=NULL)
+        LOG(DBG,"timg__GetOptions->VideoSourceToken is %s\n",timg__GetOptions->VideoSourceToken);
+#endif
+    if((timg__GetOptionsResponse->ImagingOptions = (struct tt__ImagingOptions20*)soap_malloc(soap,sizeof(struct tt__ImagingOptions20))))
+    {
+        timg__GetOptionsResponse->ImagingOptions->BacklightCompensation = NULL;
+
+        if((timg__GetOptionsResponse->ImagingOptions->Brightness = (struct tt__FloatRange*)soap_malloc(soap,sizeof(struct tt__FloatRange))))
+        {
+            timg__GetOptionsResponse->ImagingOptions->Brightness->Min = opt.brightness_min;
+            timg__GetOptionsResponse->ImagingOptions->Brightness->Max = opt.brightness_max;
+        }
+        if((timg__GetOptionsResponse->ImagingOptions->ColorSaturation = (struct tt__FloatRange*)soap_malloc(soap,sizeof(struct tt__FloatRange))))
+        {
+            timg__GetOptionsResponse->ImagingOptions->ColorSaturation->Min = opt.colorsaturation_min;
+            timg__GetOptionsResponse->ImagingOptions->ColorSaturation->Max = opt.colorsaturation_max;
+        }
+        if((timg__GetOptionsResponse->ImagingOptions->Contrast = (struct tt__FloatRange*)soap_malloc(soap,sizeof(struct tt__FloatRange))))
+        {
+            timg__GetOptionsResponse->ImagingOptions->Contrast->Min = opt.contrast_min;
+            timg__GetOptionsResponse->ImagingOptions->Contrast->Max = opt.contrast_max;
+        }
+        if((timg__GetOptionsResponse->ImagingOptions->Exposure = (struct tt__ExposureOptions20*)soap_malloc(soap,sizeof(struct tt__ExposureOptions20))))
+        {
+            timg__GetOptionsResponse->ImagingOptions->Exposure->__sizeMode = 1;
+            if((timg__GetOptionsResponse->ImagingOptions->Exposure->Mode = (enum tt__ExposureMode*)soap_malloc(soap,sizeof(enum tt__ExposureMode)*(timg__GetOptionsResponse->ImagingOptions->Exposure->__sizeMode))))
+                timg__GetOptionsResponse->ImagingOptions->Exposure->Mode[0] = tt__ExposureMode__MANUAL;
+            timg__GetOptionsResponse->ImagingOptions->Exposure->__sizePriority = 1;
+            if((timg__GetOptionsResponse->ImagingOptions->Exposure->Priority = (enum tt__ExposurePriority*)soap_malloc(soap,sizeof(enum tt__ExposurePriority)*(timg__GetOptionsResponse->ImagingOptions->Exposure->__sizePriority))))
+                timg__GetOptionsResponse->ImagingOptions->Exposure->Priority[0] = tt__ExposurePriority__FrameRate;
+            timg__GetOptionsResponse->ImagingOptions->Exposure->MinExposureTime = NULL;
+            timg__GetOptionsResponse->ImagingOptions->Exposure->MaxExposureTime = NULL;
+            timg__GetOptionsResponse->ImagingOptions->Exposure->MinGain = NULL;
+            timg__GetOptionsResponse->ImagingOptions->Exposure->MaxGain = NULL;
+            timg__GetOptionsResponse->ImagingOptions->Exposure->MinIris = NULL;
+            timg__GetOptionsResponse->ImagingOptions->Exposure->MaxIris = NULL;
+            timg__GetOptionsResponse->ImagingOptions->Exposure->ExposureTime = NULL;
+            timg__GetOptionsResponse->ImagingOptions->Exposure->Gain = NULL;
+            if((timg__GetOptionsResponse->ImagingOptions->Exposure->Iris = (struct tt__FloatRange*)soap_malloc(soap,sizeof( struct tt__FloatRange))))
+            {
+                timg__GetOptionsResponse->ImagingOptions->Exposure->Iris->Min = opt.iris_min;
+                timg__GetOptionsResponse->ImagingOptions->Exposure->Iris->Max = opt.iris_max;
+            }
+        }
+        if(( timg__GetOptionsResponse->ImagingOptions->Focus = (struct tt__FocusOptions20*)soap_malloc(soap,sizeof(struct tt__FocusOptions20))))
+        {
+            timg__GetOptionsResponse->ImagingOptions->Focus->__sizeAutoFocusModes = 1;
+            if((timg__GetOptionsResponse->ImagingOptions->Focus->AutoFocusModes = (enum tt__AutoFocusMode*)soap_malloc(soap,sizeof(enum tt__AutoFocusMode)*(timg__GetOptionsResponse->ImagingOptions->Focus->__sizeAutoFocusModes))))
+                timg__GetOptionsResponse->ImagingOptions->Focus->AutoFocusModes[0] = tt__AutoFocusMode__MANUAL;
+            if((timg__GetOptionsResponse->ImagingOptions->Focus->DefaultSpeed = (struct tt__FloatRange*)soap_malloc(soap,sizeof(struct tt__FloatRange))))
+            {
+                timg__GetOptionsResponse->ImagingOptions->Focus->DefaultSpeed->Min = -1;
+                timg__GetOptionsResponse->ImagingOptions->Focus->DefaultSpeed->Max = 1;
+            }
+            timg__GetOptionsResponse->ImagingOptions->Focus->NearLimit = NULL;
+            timg__GetOptionsResponse->ImagingOptions->Focus->FarLimit = NULL;
+            timg__GetOptionsResponse->ImagingOptions->Focus->Extension = NULL;
+        }
+        timg__GetOptionsResponse->ImagingOptions->__sizeIrCutFilterModes = 0;
+        timg__GetOptionsResponse->ImagingOptions->IrCutFilterModes = NULL;
+        if((timg__GetOptionsResponse->ImagingOptions->Sharpness = (struct tt__FloatRange *)soap_malloc(soap,sizeof(struct tt__FloatRange))))
+        {
+            timg__GetOptionsResponse->ImagingOptions->Sharpness->Min = opt.sharpness_min;
+            timg__GetOptionsResponse->ImagingOptions->Sharpness->Max = opt.sharpness_max;
+        }
+        timg__GetOptionsResponse->ImagingOptions->WideDynamicRange = NULL;
+        timg__GetOptionsResponse->ImagingOptions->WhiteBalance = NULL;
+        timg__GetOptionsResponse->ImagingOptions->Extension = NULL;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__timg__Move' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __timg__Move(struct soap* soap, struct _timg__Move *timg__Move, struct _timg__MoveResponse *timg__MoveResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__timg__Stop' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __timg__Stop(struct soap* soap, struct _timg__Stop *timg__Stop, struct _timg__StopResponse *timg__StopResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__timg__GetStatus' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __timg__GetStatus(struct soap* soap, struct _timg__GetStatus *timg__GetStatus, struct _timg__GetStatusResponse *timg__GetStatusResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__timg__GetMoveOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __timg__GetMoveOptions(struct soap* soap, struct _timg__GetMoveOptions *timg__GetMoveOptions, struct _timg__GetMoveOptionsResponse *timg__GetMoveOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__timg__GetPresets' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __timg__GetPresets(struct soap* soap, struct _timg__GetPresets *timg__GetPresets, struct _timg__GetPresetsResponse *timg__GetPresetsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__timg__GetCurrentPreset' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __timg__GetCurrentPreset(struct soap* soap, struct _timg__GetCurrentPreset *timg__GetCurrentPreset, struct _timg__GetCurrentPresetResponse *timg__GetCurrentPresetResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__timg__SetCurrentPreset' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __timg__SetCurrentPreset(struct soap* soap, struct _timg__SetCurrentPreset *timg__SetCurrentPreset, struct _timg__SetCurrentPresetResponse *timg__SetCurrentPresetResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
diff --git a/server_interface/media.c b/server_interface/media.c
new file mode 100755
index 0000000..00ad432
--- /dev/null
+++ b/server_interface/media.c
@@ -0,0 +1,1057 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include "../utils/mpapi.h"
+
+char rtsp_server_addr[INFO_LENGTH];
+static char szLocalIp[128];
+static char* pLocalIp = szLocalIp;
+
+#define MEM_LENGTH 100
+
+/** Web service operation '__trt__GetVideoSources' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoSources(struct soap* soap, struct _trt__GetVideoSources *trt__GetVideoSources, struct _trt__GetVideoSourcesResponse *trt__GetVideoSourcesResponse)
+{
+    LOG(INFO,"start !\n");
+    trt__GetVideoSourcesResponse->__sizeVideoSources = 1;
+    if((trt__GetVideoSourcesResponse->VideoSources = (struct tt__VideoSource*)soap_malloc(soap, sizeof(struct tt__VideoSource)*(trt__GetVideoSourcesResponse->__sizeVideoSources))))
+    {
+        if((trt__GetVideoSourcesResponse->VideoSources[0].token = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoSourcesResponse->VideoSources[0].token,"VideoSource_token");
+        trt__GetVideoSourcesResponse->VideoSources[0].Framerate = 25;
+        if((trt__GetVideoSourcesResponse->VideoSources[0].Resolution = (struct tt__VideoResolution*)soap_malloc(soap, sizeof(struct tt__VideoResolution))))
+        {
+            trt__GetVideoSourcesResponse->VideoSources[0].Resolution->Height = 1080;
+            trt__GetVideoSourcesResponse->VideoSources[0].Resolution->Width = 1920;
+        }
+
+        if((trt__GetVideoSourcesResponse->VideoSources[0].Imaging =(struct tt__ImagingSettings*)soap_malloc(soap, sizeof(struct tt__ImagingSettings))))
+        {
+            if((trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Brightness = (float*)soap_malloc(soap,sizeof(float))))
+                *trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Brightness = 50;
+            if((trt__GetVideoSourcesResponse->VideoSources[0].Imaging->ColorSaturation = (float*)soap_malloc(soap,sizeof(float))))
+                *trt__GetVideoSourcesResponse->VideoSources[0].Imaging->ColorSaturation = 50;
+            if((trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Contrast = (float*)soap_malloc(soap,sizeof(float))))
+                *trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Contrast = 50;
+            trt__GetVideoSourcesResponse->VideoSources[0].Imaging->IrCutFilter = NULL;
+            if((trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Sharpness = (float*)soap_malloc(soap,sizeof(float))))
+                *trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Sharpness = 50;
+            trt__GetVideoSourcesResponse->VideoSources[0].Imaging->BacklightCompensation = NULL;
+            trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Exposure = NULL;
+            trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Focus = NULL;
+            trt__GetVideoSourcesResponse->VideoSources[0].Imaging->WideDynamicRange = NULL;
+            trt__GetVideoSourcesResponse->VideoSources[0].Imaging->WhiteBalance = NULL;
+            trt__GetVideoSourcesResponse->VideoSources[0].Imaging->Extension = NULL;
+        }
+        trt__GetVideoSourcesResponse->VideoSources[0].Extension = NULL;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetProfile' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetProfile(struct soap* soap, struct _trt__GetProfile *trt__GetProfile, struct _trt__GetProfileResponse *trt__GetProfileResponse)
+{
+    LOG(INFO,"start !\n");
+
+    if((trt__GetProfileResponse->Profile = (struct tt__Profile *)soap_malloc(soap,sizeof(struct tt__Profile))))
+    {
+        usleep(20000);
+        if((trt__GetProfileResponse->Profile->Name = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetProfileResponse->Profile->Name,"MediaProfile_Channel1_MainStream");
+        if((trt__GetProfileResponse->Profile->token = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetProfileResponse->Profile->token,"MediaProfile000");
+        if((trt__GetProfileResponse->Profile->fixed = (enum xsd__boolean*)soap_malloc(soap,sizeof(enum xsd__boolean))))
+            *trt__GetProfileResponse->Profile->fixed = xsd__boolean__true_;
+        //VideoSourceConfiguration
+        struct _trt__GetVideoSourceConfiguration trt__GetVideoSourceConfiguration;
+        struct _trt__GetVideoSourceConfigurationResponse trt__GetVideoSourceConfigurationResponse;
+        if((trt__GetVideoSourceConfiguration.ConfigurationToken = (char*)SOAP_MALLOC(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoSourceConfiguration.ConfigurationToken,"VS_Token");
+        if(!__trt__GetVideoSourceConfiguration(soap,&trt__GetVideoSourceConfiguration,&trt__GetVideoSourceConfigurationResponse))
+            trt__GetProfileResponse->Profile->VideoSourceConfiguration = trt__GetVideoSourceConfigurationResponse.Configuration;
+        //AudioSourceConfiguration
+        trt__GetProfileResponse->Profile->AudioSourceConfiguration = NULL;
+        //VideoEncoderConfiguration
+        struct _trt__GetVideoEncoderConfiguration trt__GetVideoEncoderConfiguration;
+        struct _trt__GetVideoEncoderConfigurationResponse trt__GetVideoEncoderConfigurationResponse;
+        if((trt__GetVideoEncoderConfiguration.ConfigurationToken = (char*)SOAP_MALLOC(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoEncoderConfiguration.ConfigurationToken,"VE_Token1");
+        if(!__trt__GetVideoEncoderConfiguration(soap,&trt__GetVideoEncoderConfiguration,&trt__GetVideoEncoderConfigurationResponse))
+            trt__GetProfileResponse->Profile->VideoEncoderConfiguration = trt__GetVideoEncoderConfigurationResponse.Configuration;
+        //AudioEncoderConfiguration
+        trt__GetProfileResponse->Profile->AudioEncoderConfiguration = NULL;
+        //VideoAnalyticsConfiguration
+        struct _trt__GetVideoAnalyticsConfiguration trt__GetVideoAnalyticsConfiguration;
+        struct _trt__GetVideoAnalyticsConfigurationResponse trt__GetVideoAnalyticsConfigurationResponse;
+        if((trt__GetVideoAnalyticsConfiguration.ConfigurationToken = (char*)SOAP_MALLOC(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoAnalyticsConfiguration.ConfigurationToken,"VA_Token");
+        if(!__trt__GetVideoAnalyticsConfiguration(soap,&trt__GetVideoAnalyticsConfiguration,&trt__GetVideoAnalyticsConfigurationResponse))
+            trt__GetProfileResponse->Profile->VideoAnalyticsConfiguration = trt__GetVideoAnalyticsConfigurationResponse.Configuration;
+        //PTZConfiguration
+        trt__GetProfileResponse->Profile->PTZConfiguration = NULL;
+        //MetadataConfiguration
+        struct _trt__GetMetadataConfiguration trt__GetMetadataConfiguration;
+        struct _trt__GetMetadataConfigurationResponse trt__GetMetadataConfigurationResponse;
+        if((trt__GetMetadataConfiguration.ConfigurationToken = (char*)SOAP_MALLOC(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetMetadataConfiguration.ConfigurationToken,"MetadataConfig_Token");
+        if(!__trt__GetMetadataConfiguration(soap,&trt__GetMetadataConfiguration,&trt__GetMetadataConfigurationResponse))
+            trt__GetProfileResponse->Profile->MetadataConfiguration = trt__GetMetadataConfigurationResponse.Configuration;
+        usleep(20000);
+	SOAP_FREE(soap, trt__GetMetadataConfiguration.ConfigurationToken);
+	SOAP_FREE(soap, trt__GetVideoAnalyticsConfiguration.ConfigurationToken);
+	SOAP_FREE(soap, trt__GetVideoSourceConfiguration.ConfigurationToken);
+	SOAP_FREE(soap, trt__GetVideoEncoderConfiguration.ConfigurationToken );
+        //Extension
+        trt__GetProfileResponse->Profile->Extension = NULL;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetProfiles' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetProfiles(struct soap* soap, struct _trt__GetProfiles *trt__GetProfiles, struct _trt__GetProfilesResponse *trt__GetProfilesResponse)
+{
+    char _IPAddr[LARGE_INFO_LENGTH];
+    sprintf(_IPAddr, "%d.%d.%d.%d", 10, 239, 201, 99);
+    LOG(INFO,"start !\n");
+    trt__GetProfilesResponse->__sizeProfiles = 1;
+    if((trt__GetProfilesResponse->Profiles =(struct tt__Profile *)soap_malloc(soap,sizeof(struct tt__Profile)*trt__GetProfilesResponse->__sizeProfiles)))
+    {
+        if((trt__GetProfilesResponse->Profiles[0].Name = (char *)soap_malloc(soap,sizeof(char)*MAX_PROF_TOKEN)))
+            strcpy(trt__GetProfilesResponse->Profiles[0].Name,"MediaProfile_Channel1_MainStream");
+        if((trt__GetProfilesResponse->Profiles[0].token= (char *)soap_malloc(soap,sizeof(char)*MAX_PROF_TOKEN)))
+            strcpy(trt__GetProfilesResponse->Profiles[0].token,"MediaProfile000");
+        if((trt__GetProfilesResponse->Profiles[0].fixed = (enum xsd__boolean *)soap_malloc(soap,sizeof(enum xsd__boolean))))
+            *trt__GetProfilesResponse->Profiles[0].fixed = xsd__boolean__false_;
+        trt__GetProfilesResponse->Profiles[0].VideoAnalyticsConfiguration = NULL;
+
+        //VideoSourceConfiguration
+        struct _trt__GetVideoSourceConfigurationResponse trt__GetVideoSourceConfigurationResponse;
+        if(!__trt__GetVideoSourceConfiguration(soap,NULL,&trt__GetVideoSourceConfigurationResponse))
+            trt__GetProfilesResponse->Profiles[0].VideoSourceConfiguration = trt__GetVideoSourceConfigurationResponse.Configuration;
+        else
+            return SOAP_ERR;
+        //VideoEncoderConfiguration
+        struct _trt__GetVideoEncoderConfigurationResponse trt__GetVideoEncoderConfigurationResponse;
+        if(!__trt__GetVideoEncoderConfiguration(soap,NULL,&trt__GetVideoEncoderConfigurationResponse))
+            trt__GetProfilesResponse->Profiles[0].VideoEncoderConfiguration = trt__GetVideoEncoderConfigurationResponse.Configuration;
+        else
+            return SOAP_ERR;
+        //VideoAnalyticsConfiguration
+        struct _trt__GetVideoAnalyticsConfigurationResponse trt__GetVideoAnalyticsConfigurationResponse;
+        if(!__trt__GetVideoAnalyticsConfiguration(soap,NULL,&trt__GetVideoAnalyticsConfigurationResponse))
+            trt__GetProfilesResponse->Profiles[0].VideoAnalyticsConfiguration = trt__GetVideoAnalyticsConfigurationResponse.Configuration;
+        //MetadataConfiguration
+        struct _trt__GetMetadataConfigurationResponse trt__GetMetadataConfigurationResponse;
+        if(!__trt__GetMetadataConfiguration(soap,NULL,&trt__GetMetadataConfigurationResponse))
+            trt__GetProfilesResponse->Profiles[0].MetadataConfiguration = trt__GetMetadataConfigurationResponse.Configuration;
+        trt__GetProfilesResponse->Profiles[0].AudioEncoderConfiguration = NULL;
+        trt__GetProfilesResponse->Profiles[0].AudioSourceConfiguration= NULL;
+        trt__GetProfilesResponse->Profiles[0].PTZConfiguration = NULL;
+        trt__GetProfilesResponse->Profiles[0].Extension = NULL;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetStreamUri' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetStreamUri(struct soap* soap, struct _trt__GetStreamUri *trt__GetStreamUri, struct _trt__GetStreamUriResponse *trt__GetStreamUriResponse)
+{
+    int res_status = 0;
+    LOG(INFO," start!(Connection from IP =%lu.%lu.%lu.%lu)\n",((soap->ip)>>24)&0xFF, ((soap->ip)>>16)&0xFF, ((soap->ip)>>8)&0xFF, (soap->ip)&0xFF);
+    if((trt__GetStreamUriResponse->MediaUri = (struct tt__MediaUri*)soap_malloc(soap, sizeof(struct tt__MediaUri)))) {
+        memset(rtsp_server_addr, '\0', sizeof(rtsp_server_addr));
+        _get_stream_uri(rtsp_server_addr, &res_status);
+        if(res_status) {
+            return SOAP_ERR;
+        }
+        LOG(INFO,"rtsp_server_addr=%s\n", rtsp_server_addr);
+        if((trt__GetStreamUriResponse->MediaUri->Uri = (char*)soap_malloc(soap, sizeof(char)*LARGE_INFO_LENGTH)))
+            strcpy(trt__GetStreamUriResponse->MediaUri->Uri,rtsp_server_addr);
+        trt__GetStreamUriResponse->MediaUri->InvalidAfterConnect = xsd__boolean__true_;
+        trt__GetStreamUriResponse->MediaUri->InvalidAfterReboot = xsd__boolean__true_;
+        trt__GetStreamUriResponse->MediaUri->Timeout = 0;
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+/** Web service operation '__trt__GetServiceCapabilities' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetServiceCapabilities(struct soap* soap, struct _trt__GetServiceCapabilities *trt__GetServiceCapabilities, struct _trt__GetServiceCapabilitiesResponse *trt__GetServiceCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+
+/** Web service operation '__trt__GetAudioSources' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioSources(struct soap* soap, struct _trt__GetAudioSources *trt__GetAudioSources, struct _trt__GetAudioSourcesResponse *trt__GetAudioSourcesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetAudioOutputs' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioOutputs(struct soap* soap, struct _trt__GetAudioOutputs *trt__GetAudioOutputs, struct _trt__GetAudioOutputsResponse *trt__GetAudioOutputsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__CreateProfile' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__CreateProfile(struct soap* soap, struct _trt__CreateProfile *trt__CreateProfile, struct _trt__CreateProfileResponse *trt__CreateProfileResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+
+/** Web service operation '__trt__AddVideoEncoderConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__AddVideoEncoderConfiguration(struct soap* soap, struct _trt__AddVideoEncoderConfiguration *trt__AddVideoEncoderConfiguration, struct _trt__AddVideoEncoderConfigurationResponse *trt__AddVideoEncoderConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__AddVideoSourceConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__AddVideoSourceConfiguration(struct soap* soap, struct _trt__AddVideoSourceConfiguration *trt__AddVideoSourceConfiguration, struct _trt__AddVideoSourceConfigurationResponse *trt__AddVideoSourceConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__AddAudioEncoderConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__AddAudioEncoderConfiguration(struct soap* soap, struct _trt__AddAudioEncoderConfiguration *trt__AddAudioEncoderConfiguration, struct _trt__AddAudioEncoderConfigurationResponse *trt__AddAudioEncoderConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__AddAudioSourceConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__AddAudioSourceConfiguration(struct soap* soap, struct _trt__AddAudioSourceConfiguration *trt__AddAudioSourceConfiguration, struct _trt__AddAudioSourceConfigurationResponse *trt__AddAudioSourceConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__AddPTZConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__AddPTZConfiguration(struct soap* soap, struct _trt__AddPTZConfiguration *trt__AddPTZConfiguration, struct _trt__AddPTZConfigurationResponse *trt__AddPTZConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__AddVideoAnalyticsConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__AddVideoAnalyticsConfiguration(struct soap* soap, struct _trt__AddVideoAnalyticsConfiguration *trt__AddVideoAnalyticsConfiguration, struct _trt__AddVideoAnalyticsConfigurationResponse *trt__AddVideoAnalyticsConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__AddMetadataConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__AddMetadataConfiguration(struct soap* soap, struct _trt__AddMetadataConfiguration *trt__AddMetadataConfiguration, struct _trt__AddMetadataConfigurationResponse *trt__AddMetadataConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__AddAudioOutputConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__AddAudioOutputConfiguration(struct soap* soap, struct _trt__AddAudioOutputConfiguration *trt__AddAudioOutputConfiguration, struct _trt__AddAudioOutputConfigurationResponse *trt__AddAudioOutputConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__AddAudioDecoderConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__AddAudioDecoderConfiguration(struct soap* soap, struct _trt__AddAudioDecoderConfiguration *trt__AddAudioDecoderConfiguration, struct _trt__AddAudioDecoderConfigurationResponse *trt__AddAudioDecoderConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__RemoveVideoEncoderConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveVideoEncoderConfiguration(struct soap* soap, struct _trt__RemoveVideoEncoderConfiguration *trt__RemoveVideoEncoderConfiguration, struct _trt__RemoveVideoEncoderConfigurationResponse *trt__RemoveVideoEncoderConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__RemoveVideoSourceConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveVideoSourceConfiguration(struct soap* soap, struct _trt__RemoveVideoSourceConfiguration *trt__RemoveVideoSourceConfiguration, struct _trt__RemoveVideoSourceConfigurationResponse *trt__RemoveVideoSourceConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__RemoveAudioEncoderConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveAudioEncoderConfiguration(struct soap* soap, struct _trt__RemoveAudioEncoderConfiguration *trt__RemoveAudioEncoderConfiguration, struct _trt__RemoveAudioEncoderConfigurationResponse *trt__RemoveAudioEncoderConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__RemoveAudioSourceConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveAudioSourceConfiguration(struct soap* soap, struct _trt__RemoveAudioSourceConfiguration *trt__RemoveAudioSourceConfiguration, struct _trt__RemoveAudioSourceConfigurationResponse *trt__RemoveAudioSourceConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__RemovePTZConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__RemovePTZConfiguration(struct soap* soap, struct _trt__RemovePTZConfiguration *trt__RemovePTZConfiguration, struct _trt__RemovePTZConfigurationResponse *trt__RemovePTZConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__RemoveVideoAnalyticsConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveVideoAnalyticsConfiguration(struct soap* soap, struct _trt__RemoveVideoAnalyticsConfiguration *trt__RemoveVideoAnalyticsConfiguration, struct _trt__RemoveVideoAnalyticsConfigurationResponse *trt__RemoveVideoAnalyticsConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__RemoveMetadataConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveMetadataConfiguration(struct soap* soap, struct _trt__RemoveMetadataConfiguration *trt__RemoveMetadataConfiguration, struct _trt__RemoveMetadataConfigurationResponse *trt__RemoveMetadataConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__RemoveAudioOutputConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveAudioOutputConfiguration(struct soap* soap, struct _trt__RemoveAudioOutputConfiguration *trt__RemoveAudioOutputConfiguration, struct _trt__RemoveAudioOutputConfigurationResponse *trt__RemoveAudioOutputConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__RemoveAudioDecoderConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveAudioDecoderConfiguration(struct soap* soap, struct _trt__RemoveAudioDecoderConfiguration *trt__RemoveAudioDecoderConfiguration, struct _trt__RemoveAudioDecoderConfigurationResponse *trt__RemoveAudioDecoderConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__DeleteProfile' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__DeleteProfile(struct soap* soap, struct _trt__DeleteProfile *trt__DeleteProfile, struct _trt__DeleteProfileResponse *trt__DeleteProfileResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetVideoSourceConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoSourceConfigurations(struct soap* soap, struct _trt__GetVideoSourceConfigurations *trt__GetVideoSourceConfigurations, struct _trt__GetVideoSourceConfigurationsResponse *trt__GetVideoSourceConfigurationsResponse)
+{
+    LOG(INFO,"start !\n");
+    trt__GetVideoSourceConfigurationsResponse->__sizeConfigurations = 1;
+    if((trt__GetVideoSourceConfigurationsResponse->Configurations = (struct tt__VideoSourceConfiguration*)soap_malloc(soap,sizeof(struct tt__VideoSourceConfiguration))))
+    {
+        if((trt__GetVideoSourceConfigurationsResponse->Configurations[0].Name = (char *)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoSourceConfigurationsResponse->Configurations[0].Name,"VS_Name");
+        if((trt__GetVideoSourceConfigurationsResponse->Configurations[0].token = (char *)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoSourceConfigurationsResponse->Configurations[0].token,"VS_Token");
+        trt__GetVideoSourceConfigurationsResponse->Configurations[0].UseCount = 1;
+        if((trt__GetVideoSourceConfigurationsResponse->Configurations[0].SourceToken = (char *)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoSourceConfigurationsResponse->Configurations[0].SourceToken,"VideoSource_token");
+        if((trt__GetVideoSourceConfigurationsResponse->Configurations[0].Bounds = (struct tt__IntRectangle*)soap_malloc(soap,sizeof(struct tt__IntRectangle))))
+        {
+            trt__GetVideoSourceConfigurationsResponse->Configurations[0].Bounds->x = 1;
+            trt__GetVideoSourceConfigurationsResponse->Configurations[0].Bounds->y = 1;
+            trt__GetVideoSourceConfigurationsResponse->Configurations[0].Bounds->width = 1920;
+            trt__GetVideoSourceConfigurationsResponse->Configurations[0].Bounds->height = 1080;
+        }
+        if((trt__GetVideoSourceConfigurationsResponse->Configurations[0].ViewMode = (char *)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoSourceConfigurationsResponse->Configurations[0].ViewMode,"VS_ViewMode");
+        trt__GetVideoSourceConfigurationsResponse->Configurations[0].Extension = NULL;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetVideoEncoderConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoEncoderConfigurations(struct soap* soap, struct _trt__GetVideoEncoderConfigurations *trt__GetVideoEncoderConfigurations, struct _trt__GetVideoEncoderConfigurationsResponse *trt__GetVideoEncoderConfigurationsResponse)
+{
+    LOG(INFO,"start !\n");
+    VideoEncoderConfiguration config = {"JPEG", "BR", '\0', '\0', '\0', '\0', '\0', '\0'};
+    int res_status = 0;
+    _get_videoenc_config(&config, &res_status);
+    if(res_status) {
+        return SOAP_ERR;
+    }
+
+    trt__GetVideoEncoderConfigurationsResponse->__sizeConfigurations = 1;
+    if((trt__GetVideoEncoderConfigurationsResponse->Configurations = (struct tt__VideoEncoderConfiguration*)soap_malloc(soap,sizeof(struct tt__VideoEncoderConfiguration)*(trt__GetVideoEncoderConfigurationsResponse->__sizeConfigurations))))
+    {
+        if((trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Name = (char *)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Name,"VE_Name1");
+        if((trt__GetVideoEncoderConfigurationsResponse->Configurations[0].token = (char *)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoEncoderConfigurationsResponse->Configurations[0].token,"VE_Token1");
+        trt__GetVideoEncoderConfigurationsResponse->Configurations[0].UseCount = 1;
+        trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Quality = 3;
+        if(!strcmp(config.Encoder,"JPEG"))
+        {
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Encoding = tt__VideoEncoding__JPEG;
+        }else if(!strcmp(config.Encoder,"MPEG4")){
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Encoding = tt__VideoEncoding__MPEG4;
+        }else if(!strcmp(config.Encoder,"H264")){
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Encoding = tt__VideoEncoding__H264;
+        }
+        if((trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Resolution = (struct tt__VideoResolution *)soap_malloc(soap,sizeof(struct tt__VideoResolution))))
+        {
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Resolution->Width = config.width;
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Resolution->Height = config.height;
+        }
+        if((trt__GetVideoEncoderConfigurationsResponse->Configurations[0].RateControl = (struct tt__VideoRateControl *)soap_malloc(soap,sizeof(struct tt__VideoRateControl))))
+        {
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].RateControl->FrameRateLimit = config.framerate;
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].RateControl->EncodingInterval = 1;
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].RateControl->BitrateLimit = config.bitrate;
+        }
+        if((trt__GetVideoEncoderConfigurationsResponse->Configurations[0].MPEG4 = (struct tt__Mpeg4Configuration *)soap_malloc(soap,sizeof(struct tt__Mpeg4Configuration))))
+        {
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].MPEG4->GovLength = config.govlen;
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].MPEG4->Mpeg4Profile = tt__Mpeg4Profile__ASP;
+        }
+        if((trt__GetVideoEncoderConfigurationsResponse->Configurations[0].H264 = (struct tt__H264Configuration*)soap_malloc(soap,sizeof(struct tt__H264Configuration))))
+        {
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].H264->GovLength = config.govlen;
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].H264->H264Profile = tt__H264Profile__Main;
+        }
+        if((trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Multicast = (struct tt__MulticastConfiguration *)soap_malloc(soap,sizeof(struct tt__MulticastConfiguration))))
+        {
+            if((trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Multicast->Address = (struct tt__IPAddress *)soap_malloc(soap,sizeof(struct tt__IPAddress))))
+            {
+                trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Multicast->Address->Type = tt__IPType__IPv4;
+                if((trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Multicast->Address->IPv4Address = (char *)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                    strcpy(trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Multicast->Address->IPv4Address,"224.1.0.0");
+                trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Multicast->Address->IPv6Address = NULL;
+            }
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Multicast->Port = 40000;
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Multicast->TTL = 64;
+            trt__GetVideoEncoderConfigurationsResponse->Configurations[0].Multicast->AutoStart = xsd__boolean__true_;
+        }
+        trt__GetVideoEncoderConfigurationsResponse->Configurations[0].SessionTimeout = 1000;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetAudioSourceConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioSourceConfigurations(struct soap* soap, struct _trt__GetAudioSourceConfigurations *trt__GetAudioSourceConfigurations, struct _trt__GetAudioSourceConfigurationsResponse *trt__GetAudioSourceConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetAudioEncoderConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioEncoderConfigurations(struct soap* soap, struct _trt__GetAudioEncoderConfigurations *trt__GetAudioEncoderConfigurations, struct _trt__GetAudioEncoderConfigurationsResponse *trt__GetAudioEncoderConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetVideoAnalyticsConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoAnalyticsConfigurations(struct soap* soap, struct _trt__GetVideoAnalyticsConfigurations *trt__GetVideoAnalyticsConfigurations, struct _trt__GetVideoAnalyticsConfigurationsResponse *trt__GetVideoAnalyticsConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetMetadataConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetMetadataConfigurations(struct soap* soap, struct _trt__GetMetadataConfigurations *trt__GetMetadataConfigurations, struct _trt__GetMetadataConfigurationsResponse *trt__GetMetadataConfigurationsResponse)
+{
+    LOG(INFO,"start !\n");
+    return SOAP_OK;
+}
+
+/** Web service operation '__trt__GetAudioOutputConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioOutputConfigurations(struct soap* soap, struct _trt__GetAudioOutputConfigurations *trt__GetAudioOutputConfigurations, struct _trt__GetAudioOutputConfigurationsResponse *trt__GetAudioOutputConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetAudioDecoderConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioDecoderConfigurations(struct soap* soap, struct _trt__GetAudioDecoderConfigurations *trt__GetAudioDecoderConfigurations, struct _trt__GetAudioDecoderConfigurationsResponse *trt__GetAudioDecoderConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetVideoSourceConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoSourceConfiguration(struct soap* soap, struct _trt__GetVideoSourceConfiguration *trt__GetVideoSourceConfiguration, struct _trt__GetVideoSourceConfigurationResponse *trt__GetVideoSourceConfigurationResponse)
+{
+    LOG(INFO,"start !\n");
+
+    if((trt__GetVideoSourceConfigurationResponse->Configuration = (struct tt__VideoSourceConfiguration*)soap_malloc(soap,sizeof(struct tt__VideoSourceConfiguration))))
+    {
+        if((trt__GetVideoSourceConfigurationResponse->Configuration->Name = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoSourceConfigurationResponse->Configuration->Name,"VS_Name");
+        trt__GetVideoSourceConfigurationResponse->Configuration->UseCount = 1;
+        if((trt__GetVideoSourceConfigurationResponse->Configuration->token =  (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoSourceConfigurationResponse->Configuration->token,"VS_Token");
+        if((trt__GetVideoSourceConfigurationResponse->Configuration->ViewMode=  (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoSourceConfigurationResponse->Configuration->ViewMode,"VS_ViewMode");
+        if((trt__GetVideoSourceConfigurationResponse->Configuration->SourceToken = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoSourceConfigurationResponse->Configuration->SourceToken,"VideoSource_token");
+        if((trt__GetVideoSourceConfigurationResponse->Configuration->Bounds = (struct tt__IntRectangle*)soap_malloc(soap,sizeof(struct tt__IntRectangle))))
+        {
+            trt__GetVideoSourceConfigurationResponse->Configuration->Bounds->x = 1;
+            trt__GetVideoSourceConfigurationResponse->Configuration->Bounds->y = 1;
+            trt__GetVideoSourceConfigurationResponse->Configuration->Bounds->width = 1920;
+            trt__GetVideoSourceConfigurationResponse->Configuration->Bounds->height = 1080;
+        }
+        trt__GetVideoSourceConfigurationResponse->Configuration->Extension = NULL;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetVideoEncoderConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoEncoderConfiguration(struct soap* soap, struct _trt__GetVideoEncoderConfiguration *trt__GetVideoEncoderConfiguration, struct _trt__GetVideoEncoderConfigurationResponse *trt__GetVideoEncoderConfigurationResponse)
+{
+    LOG(INFO,"start !\n");
+    VideoEncoderConfiguration config = {{'\0'}, {'\0'}, 0, 0, 0, 0, 0, 0};
+    int res_status = 0;
+    _get_videoenc_config(&config, &res_status);
+    if(res_status) {
+        return SOAP_ERR;
+    }
+
+    if((trt__GetVideoEncoderConfigurationResponse->Configuration = (struct tt__VideoEncoderConfiguration*)soap_malloc(soap,sizeof(struct tt__VideoEncoderConfiguration))))
+    {
+        if((trt__GetVideoEncoderConfigurationResponse->Configuration->Name = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoEncoderConfigurationResponse->Configuration->Name,"VE_Name1");
+        if((trt__GetVideoEncoderConfigurationResponse->Configuration->token = (tt__ReferenceToken)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoEncoderConfigurationResponse->Configuration->token,"VE_Token1");
+        trt__GetVideoEncoderConfigurationResponse->Configuration->UseCount = 1;
+        trt__GetVideoEncoderConfigurationResponse->Configuration->Quality = config.quality;
+        if(!strcmp(config.Encoder,"JPEG")||!strcmp(config.Encoder,"jpeg"))
+        {
+            trt__GetVideoEncoderConfigurationResponse->Configuration->Encoding = tt__VideoEncoding__JPEG;
+        }else if(!strcmp(config.Encoder,"MPEG4")||!strcmp(config.Encoder,"mpeg4")){
+            trt__GetVideoEncoderConfigurationResponse->Configuration->Encoding = tt__VideoEncoding__MPEG4;
+        }else if(!strcmp(config.Encoder,"H264")||!strcmp(config.Encoder,"h264")){
+            trt__GetVideoEncoderConfigurationResponse->Configuration->Encoding = tt__VideoEncoding__H264;
+        }
+        if((trt__GetVideoEncoderConfigurationResponse->Configuration->Resolution = (struct tt__VideoResolution*)soap_malloc(soap,sizeof(struct tt__VideoResolution))))
+        {
+            trt__GetVideoEncoderConfigurationResponse->Configuration->Resolution->Width = config.width;
+            trt__GetVideoEncoderConfigurationResponse->Configuration->Resolution->Height = config.height;
+        }
+        if((trt__GetVideoEncoderConfigurationResponse->Configuration->RateControl = (struct tt__VideoRateControl*)soap_malloc(soap,sizeof(struct tt__VideoRateControl))))
+        {
+            trt__GetVideoEncoderConfigurationResponse->Configuration->RateControl->FrameRateLimit = config.framerate;
+            trt__GetVideoEncoderConfigurationResponse->Configuration->RateControl->EncodingInterval = 1;
+            trt__GetVideoEncoderConfigurationResponse->Configuration->RateControl->BitrateLimit = config.bitrate;
+        }
+        if((trt__GetVideoEncoderConfigurationResponse->Configuration->MPEG4 = (struct tt__Mpeg4Configuration*)soap_malloc(soap,sizeof(struct tt__Mpeg4Configuration))))
+        {
+            trt__GetVideoEncoderConfigurationResponse->Configuration->MPEG4->GovLength = config.govlen;
+            trt__GetVideoEncoderConfigurationResponse->Configuration->MPEG4->Mpeg4Profile = tt__Mpeg4Profile__ASP;
+        }
+        if((trt__GetVideoEncoderConfigurationResponse->Configuration->H264 = (struct tt__H264Configuration *)soap_malloc(soap,sizeof(struct tt__H264Configuration))))
+        {
+            trt__GetVideoEncoderConfigurationResponse->Configuration->H264->GovLength = config.govlen;
+            trt__GetVideoEncoderConfigurationResponse->Configuration->H264->H264Profile = tt__H264Profile__Main;
+        }
+        if((trt__GetVideoEncoderConfigurationResponse->Configuration->Multicast = (struct tt__MulticastConfiguration*)soap_malloc(soap,sizeof(struct tt__MulticastConfiguration))))
+        {
+            if((trt__GetVideoEncoderConfigurationResponse->Configuration->Multicast->Address = (struct tt__IPAddress*)soap_malloc(soap,sizeof(struct tt__IPAddress))))
+            {
+                trt__GetVideoEncoderConfigurationResponse->Configuration->Multicast->Address->Type = tt__IPType__IPv4;
+                if((trt__GetVideoEncoderConfigurationResponse->Configuration->Multicast->Address->IPv4Address = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                    strcpy(trt__GetVideoEncoderConfigurationResponse->Configuration->Multicast->Address->IPv4Address,"224.1.0.0");
+                trt__GetVideoEncoderConfigurationResponse->Configuration->Multicast->Address->IPv6Address = NULL;
+            }
+            trt__GetVideoEncoderConfigurationResponse->Configuration->Multicast->Port = 40000;
+            trt__GetVideoEncoderConfigurationResponse->Configuration->Multicast->TTL = 64;
+            trt__GetVideoEncoderConfigurationResponse->Configuration->Multicast->AutoStart = xsd__boolean__true_;
+        }
+        trt__GetVideoEncoderConfigurationResponse->Configuration->SessionTimeout = 1000;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetAudioSourceConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioSourceConfiguration(struct soap* soap, struct _trt__GetAudioSourceConfiguration *trt__GetAudioSourceConfiguration, struct _trt__GetAudioSourceConfigurationResponse *trt__GetAudioSourceConfigurationResponse)
+{
+    LOG(INFO,"start !\n");
+#ifdef _DEBUG_
+    if(trt__GetAudioSourceConfiguration!=NULL&&trt__GetAudioSourceConfiguration->ConfigurationToken!=NULL)
+        LOG(DBG,"trt__GetAudioSourceConfiguration->ConfigurationToken is %s\r\n",trt__GetAudioSourceConfiguration->ConfigurationToken);
+#endif
+    if((trt__GetAudioSourceConfigurationResponse->Configuration = (struct tt__AudioSourceConfiguration*)soap_malloc(soap,sizeof(struct tt__AudioSourceConfiguration))))
+    {
+        if((trt__GetAudioSourceConfigurationResponse->Configuration->Name = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetAudioSourceConfigurationResponse->Configuration->Name,"AS_Name");
+        trt__GetAudioSourceConfigurationResponse->Configuration->UseCount = 2;
+        if((trt__GetAudioSourceConfigurationResponse->Configuration->token = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetAudioSourceConfigurationResponse->Configuration->token,"AS_Token");
+        if((trt__GetAudioSourceConfigurationResponse->Configuration->SourceToken = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetAudioSourceConfigurationResponse->Configuration->SourceToken,"AS_SToken");
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetAudioEncoderConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioEncoderConfiguration(struct soap* soap, struct _trt__GetAudioEncoderConfiguration *trt__GetAudioEncoderConfiguration, struct _trt__GetAudioEncoderConfigurationResponse *trt__GetAudioEncoderConfigurationResponse)
+{
+    LOG(INFO,"start !\n");
+#ifdef _DEBUG_
+    if(trt__GetAudioEncoderConfiguration!=NULL&&trt__GetAudioEncoderConfiguration->ConfigurationToken!=NULL)
+        LOG(DBG,"trt__GetAudioEncoderConfiguration->ConfigurationToken is %s\r\n",trt__GetAudioEncoderConfiguration->ConfigurationToken);
+#endif
+    if((trt__GetAudioEncoderConfigurationResponse->Configuration = (struct tt__AudioEncoderConfiguration*)soap_malloc(soap,sizeof(struct tt__AudioEncoderConfiguration))))
+    {
+        if((trt__GetAudioEncoderConfigurationResponse->Configuration->Name = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetAudioEncoderConfigurationResponse->Configuration->Name,"AE_Name");
+        if((trt__GetAudioEncoderConfigurationResponse->Configuration->token = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetAudioEncoderConfigurationResponse->Configuration->token,"AE_Token");
+        trt__GetAudioEncoderConfigurationResponse->Configuration->UseCount = 1;
+        trt__GetAudioEncoderConfigurationResponse->Configuration->Encoding = tt__AudioEncoding__G711;
+        trt__GetAudioEncoderConfigurationResponse->Configuration->Bitrate = 128;
+        trt__GetAudioEncoderConfigurationResponse->Configuration->SampleRate = 16;
+        if((trt__GetAudioEncoderConfigurationResponse->Configuration->Multicast = (struct tt__MulticastConfiguration*)soap_malloc(soap,sizeof(struct tt__MulticastConfiguration))))
+        {
+            if((trt__GetAudioEncoderConfigurationResponse->Configuration->Multicast->Address = (struct tt__IPAddress*)soap_malloc(soap,sizeof(struct tt__IPAddress))))
+            {
+                trt__GetAudioEncoderConfigurationResponse->Configuration->Multicast->Address->Type = tt__IPType__IPv4;
+                if((trt__GetAudioEncoderConfigurationResponse->Configuration->Multicast->Address->IPv4Address = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                    strcpy(trt__GetAudioEncoderConfigurationResponse->Configuration->Multicast->Address->IPv4Address,"24.1.0.0");
+                trt__GetAudioEncoderConfigurationResponse->Configuration->Multicast->Address->IPv6Address = NULL;
+            }
+            trt__GetAudioEncoderConfigurationResponse->Configuration->Multicast->Port = 40002;
+            trt__GetAudioEncoderConfigurationResponse->Configuration->Multicast->TTL = 64;
+            trt__GetAudioEncoderConfigurationResponse->Configuration->Multicast->AutoStart = xsd__boolean__false_;
+        }
+        trt__GetAudioEncoderConfigurationResponse->Configuration->SessionTimeout = 60000;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetVideoAnalyticsConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoAnalyticsConfiguration(struct soap* soap, struct _trt__GetVideoAnalyticsConfiguration *trt__GetVideoAnalyticsConfiguration, struct _trt__GetVideoAnalyticsConfigurationResponse *trt__GetVideoAnalyticsConfigurationResponse)
+{
+    LOG(INFO,"start !\n");
+    if((trt__GetVideoAnalyticsConfigurationResponse->Configuration = (struct tt__VideoAnalyticsConfiguration*)soap_malloc(soap,sizeof(struct tt__VideoAnalyticsConfiguration))))
+    {
+        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->Name = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->Name,"VideoAnalytics_Channel");
+        trt__GetVideoAnalyticsConfigurationResponse->Configuration->UseCount = 1;
+        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->token = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->token,"VA_Token");
+        //AnalyticsEngineConfiguration
+        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration = (struct tt__AnalyticsEngineConfiguration*)soap_malloc(soap,sizeof(struct tt__AnalyticsEngineConfiguration))))
+        {
+            trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->__sizeAnalyticsModule = 1;
+            if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule = (struct tt__Config*)soap_malloc(soap,sizeof(struct tt__Config)*(trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->__sizeAnalyticsModule))))
+            {
+                if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Name  = (char *)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                    strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Name,"MyCellMotion");
+                if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Type  = (char *)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                    strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Type,"CellMotionEngine");
+                if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Parameters  = (struct tt__ItemList*)soap_malloc(soap,sizeof(struct tt__ItemList))))
+                {
+                    trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Parameters->__sizeSimpleItem = 1;
+                    if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Parameters->SimpleItem = (struct _tt__ItemList_SimpleItem*)soap_malloc(soap,sizeof(struct _tt__ItemList_SimpleItem))))
+                    {
+                        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Parameters->SimpleItem->Name = (char *)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Parameters->SimpleItem->Name,"Sentivity");
+                        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Parameters->SimpleItem->
+                            Value = (char *)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Parameters->SimpleItem->Value,"60");
+                    }
+                    trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Parameters->__sizeElementItem = 1;
+                    if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Parameters->ElementItem = (struct _tt__ItemList_ElementItem*)soap_malloc(soap,sizeof(struct _tt__ItemList_ElementItem))))
+                    {
+                        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Parameters->ElementItem->Name = (char *)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule[0].Parameters->ElementItem->Name,"Layout");
+                    }
+                }
+
+            }
+        }
+        //RuleEngineConfiguration
+        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration = (struct tt__RuleEngineConfiguration*)soap_malloc(soap,sizeof(struct tt__RuleEngineConfiguration))))
+        {
+            trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->__sizeRule = 1;
+            if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule = (struct tt__Config*)soap_malloc(soap,sizeof(struct tt__Config)*(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->__sizeRule))))
+            {
+                if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Name=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                    strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Name,"Region1");
+                if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Type=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                    strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Type,"CellMotionDetector");
+
+                if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters = (struct tt__ItemList*)soap_malloc(soap,sizeof(struct tt__ItemList))))
+                {
+                    trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->__sizeSimpleItem = 4;
+                    if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem = (struct _tt__ItemList_SimpleItem*)soap_malloc(soap,sizeof(struct _tt__ItemList_SimpleItem)*(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->__sizeSimpleItem))))
+                    {
+                        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[0].Name=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[0].Name,"MinCount");
+                        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[0].Value=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[0].Value,"4");
+                        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[1].Name=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[1].Name,"AlarmOnDelay");
+                        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[1].Value=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[1].Value,"1000");
+                        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[2].Name=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[2].Name,"AlarmOffDelay");
+                        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[2].Value=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[2].Value,"1000");
+                        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[3].Name=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[3].Name,"AlarmCells");
+                        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[3].Value=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->SimpleItem[3].Value,"0P8A8A==");
+
+                    }
+                    trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->__sizeElementItem = 1;
+                    if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->ElementItem  = (struct _tt__ItemList_ElementItem*)soap_malloc(soap,sizeof(struct _tt__ItemList_ElementItem))))
+                    {
+                        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->ElementItem->Name=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[0].Parameters->ElementItem->Name,"Field");
+                    }
+
+                }
+                if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[1].Name=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                    strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[1].Name,"MyTamper");
+                if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[1].Type=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                    strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[1].Type,"MyTamper");
+                if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[1].Parameters = (struct tt__ItemList*)soap_malloc(soap,sizeof(struct tt__ItemList))))
+                {
+                    trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[1].Parameters->__sizeElementItem = 1;
+                    if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[1].Parameters->ElementItem  = (struct _tt__ItemList_ElementItem*)soap_malloc(soap,sizeof(struct _tt__ItemList_ElementItem))))
+                    {
+                        if((trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[1].Parameters->ElementItem->Name=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+                            strcpy(trt__GetVideoAnalyticsConfigurationResponse->Configuration->RuleEngineConfiguration->Rule[1].Parameters->ElementItem->Name,"Field");
+                    }
+
+                }
+
+            }
+        }
+    }
+    return SOAP_OK;
+}
+
+/** Web service operation '__trt__GetMetadataConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetMetadataConfiguration(struct soap* soap, struct _trt__GetMetadataConfiguration *trt__GetMetadataConfiguration, struct _trt__GetMetadataConfigurationResponse *trt__GetMetadataConfigurationResponse)
+{
+    LOG(INFO,"start !\n");
+    if((trt__GetMetadataConfigurationResponse->Configuration = (struct tt__MetadataConfiguration*)soap_malloc(soap,sizeof(struct tt__MetadataConfiguration))))
+    {
+        if((trt__GetMetadataConfigurationResponse->Configuration->Name = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetMetadataConfigurationResponse->Configuration->Name,"MetadataConfig_Channel1");
+        if((trt__GetMetadataConfigurationResponse->Configuration->token = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetMetadataConfigurationResponse->Configuration->token,"MetadataConfig_Token");
+        trt__GetMetadataConfigurationResponse->Configuration->UseCount = 1;
+        trt__GetMetadataConfigurationResponse->Configuration->PTZStatus = NULL;
+        trt__GetMetadataConfigurationResponse->Configuration->Events = NULL;
+        if((trt__GetMetadataConfigurationResponse->Configuration->Analytics = (enum xsd__boolean*)soap_malloc(soap,sizeof(enum xsd__boolean))))
+            *trt__GetMetadataConfigurationResponse->Configuration->Analytics = xsd__boolean__true_;
+        if((trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration = (struct tt__AnalyticsEngineConfiguration*)soap_malloc(soap,sizeof(struct tt__AnalyticsEngineConfiguration))))
+        {
+            trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->__sizeAnalyticsModule = 1;
+            if((trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule = (struct tt__Config*)soap_malloc(soap,sizeof(struct tt__Config))))
+            {
+                if((trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule->Parameters = (struct tt__ItemList*)soap_malloc(soap,sizeof(struct tt__ItemList))))
+                {
+                    trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule->Parameters->__sizeSimpleItem = 1;
+                    if((trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule->Parameters->SimpleItem= (struct _tt__ItemList_SimpleItem*)soap_malloc(soap,sizeof(struct _tt__ItemList_SimpleItem))))
+                    {
+                        trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule->Parameters->SimpleItem->Name=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH);
+                        trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule->Parameters->SimpleItem->Value=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH);
+                    }
+                    trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule->Parameters->__sizeElementItem = 1;
+                    if((trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule->Parameters->ElementItem= (struct _tt__ItemList_ElementItem*)soap_malloc(soap,sizeof(struct _tt__ItemList_ElementItem))))
+                    {
+                        trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule->Parameters->ElementItem->Name=(char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH);
+                    }
+                    if((trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule->Parameters->Extension= (struct tt__ItemListExtension*)soap_malloc(soap,sizeof(struct tt__ItemListExtension))))
+                    {
+                        trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule->Parameters->Extension=NULL;
+                    }
+                }
+                trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule->Name = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH);
+                trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->AnalyticsModule->Type = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH);
+            }
+
+            trt__GetMetadataConfigurationResponse->Configuration->AnalyticsEngineConfiguration->Extension = NULL;
+        }
+        if((trt__GetMetadataConfigurationResponse->Configuration->Multicast = (struct tt__MulticastConfiguration*)soap_malloc(soap,sizeof(struct tt__MulticastConfiguration))))
+        {
+            if((trt__GetMetadataConfigurationResponse->Configuration->Multicast->Address = (struct tt__IPAddress*)soap_malloc(soap,sizeof(struct tt__IPAddress))))
+            {
+                trt__GetMetadataConfigurationResponse->Configuration->Multicast->Address->Type = tt__IPType__IPv4;
+                if((trt__GetMetadataConfigurationResponse->Configuration->Multicast->Address->IPv4Address = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                    strcpy(trt__GetMetadataConfigurationResponse->Configuration->Multicast->Address->IPv4Address,"224.2.0.0");
+                if((trt__GetMetadataConfigurationResponse->Configuration->Multicast->Address->IPv6Address = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+                    strcpy(trt__GetMetadataConfigurationResponse->Configuration->Multicast->Address->IPv6Address,"224.2.0.0");
+            }
+            trt__GetMetadataConfigurationResponse->Configuration->Multicast->Port = 40020;
+            trt__GetMetadataConfigurationResponse->Configuration->Multicast->TTL = 64;
+            trt__GetMetadataConfigurationResponse->Configuration->Multicast->AutoStart = xsd__boolean__false_;
+        }
+        trt__GetMetadataConfigurationResponse->Configuration->SessionTimeout = 60000;
+        trt__GetMetadataConfigurationResponse->Configuration->CompressionType = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH);
+        trt__GetMetadataConfigurationResponse->Configuration->GeoLocation =xsd__boolean__false_;
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetAudioOutputConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioOutputConfiguration(struct soap* soap, struct _trt__GetAudioOutputConfiguration *trt__GetAudioOutputConfiguration, struct _trt__GetAudioOutputConfigurationResponse *trt__GetAudioOutputConfigurationResponse)
+{
+    LOG(INFO,"start !\n");
+#ifdef _DEBUG_
+    if(trt__GetAudioOutputConfiguration!=NULL&&trt__GetAudioOutputConfiguration->ConfigurationToken!=NULL)
+        LOG(DBG,"trt__GetAudioOutputConfiguration->ConfigurationToken is %s\r\n",trt__GetAudioOutputConfiguration->ConfigurationToken);
+#endif
+    if((trt__GetAudioOutputConfigurationResponse->Configuration = (struct tt__AudioOutputConfiguration*)soap_malloc(soap,sizeof(struct tt__AudioOutputConfiguration))))
+    {
+        if((trt__GetAudioOutputConfigurationResponse->Configuration->Name = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetAudioOutputConfigurationResponse->Configuration->Name,"AudioOutputConfig_Name");
+        if((trt__GetAudioOutputConfigurationResponse->Configuration->token = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetAudioOutputConfigurationResponse->Configuration->token,"AudisOutputConfig_Token");
+        if((trt__GetAudioOutputConfigurationResponse->Configuration->OutputToken = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetAudioOutputConfigurationResponse->Configuration->OutputToken,"AudisOutputConfig_OutputToken");
+        trt__GetAudioOutputConfigurationResponse->Configuration->UseCount = 2;
+        if((trt__GetAudioOutputConfigurationResponse->Configuration->SendPrimacy = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            strcpy(trt__GetAudioOutputConfigurationResponse->Configuration->SendPrimacy,"www.onvif.org/ver20/HalfDuplex/Auto");
+        trt__GetAudioOutputConfigurationResponse->Configuration->OutputLevel = 50;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetAudioDecoderConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioDecoderConfiguration(struct soap* soap, struct _trt__GetAudioDecoderConfiguration *trt__GetAudioDecoderConfiguration, struct _trt__GetAudioDecoderConfigurationResponse *trt__GetAudioDecoderConfigurationResponse)
+{
+    LOG(INFO,"start !\n");
+#ifdef _DEBUG_
+    if(trt__GetAudioDecoderConfiguration!=NULL&&trt__GetAudioDecoderConfiguration->ConfigurationToken)
+        LOG(DBG,"trt__GetAudioDecoderConfiguration->ConfigurationToken is %s\r\n",trt__GetAudioDecoderConfiguration->ConfigurationToken);
+#endif
+    if((trt__GetAudioDecoderConfigurationResponse->Configuration = (struct tt__AudioDecoderConfiguration*)soap_malloc(soap,sizeof(struct tt__AudioDecoderConfiguration))))
+    {
+        if((trt__GetAudioDecoderConfigurationResponse->Configuration->Name = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetAudioDecoderConfigurationResponse->Configuration->Name,"AudioDecoderConfig_Channel1");
+        if((trt__GetAudioDecoderConfigurationResponse->Configuration->token  = (char*)soap_malloc(soap,sizeof(char)*SHORT_LENGTH)))
+            strcpy(trt__GetAudioDecoderConfigurationResponse->Configuration->token,"AudioDecoderConfig_Channel1");
+        trt__GetAudioDecoderConfigurationResponse->Configuration->UseCount = 1;
+
+        return SOAP_OK;
+    }
+
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetCompatibleVideoEncoderConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleVideoEncoderConfigurations(struct soap* soap, struct _trt__GetCompatibleVideoEncoderConfigurations *trt__GetCompatibleVideoEncoderConfigurations, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *trt__GetCompatibleVideoEncoderConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetCompatibleVideoSourceConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleVideoSourceConfigurations(struct soap* soap, struct _trt__GetCompatibleVideoSourceConfigurations *trt__GetCompatibleVideoSourceConfigurations, struct _trt__GetCompatibleVideoSourceConfigurationsResponse *trt__GetCompatibleVideoSourceConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetCompatibleAudioEncoderConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleAudioEncoderConfigurations(struct soap* soap, struct _trt__GetCompatibleAudioEncoderConfigurations *trt__GetCompatibleAudioEncoderConfigurations, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *trt__GetCompatibleAudioEncoderConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetCompatibleAudioSourceConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleAudioSourceConfigurations(struct soap* soap, struct _trt__GetCompatibleAudioSourceConfigurations *trt__GetCompatibleAudioSourceConfigurations, struct _trt__GetCompatibleAudioSourceConfigurationsResponse *trt__GetCompatibleAudioSourceConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetCompatibleVideoAnalyticsConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleVideoAnalyticsConfigurations(struct soap* soap, struct _trt__GetCompatibleVideoAnalyticsConfigurations *trt__GetCompatibleVideoAnalyticsConfigurations, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *trt__GetCompatibleVideoAnalyticsConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetCompatibleMetadataConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleMetadataConfigurations(struct soap* soap, struct _trt__GetCompatibleMetadataConfigurations *trt__GetCompatibleMetadataConfigurations, struct _trt__GetCompatibleMetadataConfigurationsResponse *trt__GetCompatibleMetadataConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetCompatibleAudioOutputConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleAudioOutputConfigurations(struct soap* soap, struct _trt__GetCompatibleAudioOutputConfigurations *trt__GetCompatibleAudioOutputConfigurations, struct _trt__GetCompatibleAudioOutputConfigurationsResponse *trt__GetCompatibleAudioOutputConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetCompatibleAudioDecoderConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleAudioDecoderConfigurations(struct soap* soap, struct _trt__GetCompatibleAudioDecoderConfigurations *trt__GetCompatibleAudioDecoderConfigurations, struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *trt__GetCompatibleAudioDecoderConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__SetVideoSourceConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__SetVideoSourceConfiguration(struct soap* soap, struct _trt__SetVideoSourceConfiguration *trt__SetVideoSourceConfiguration, struct _trt__SetVideoSourceConfigurationResponse *trt__SetVideoSourceConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__SetVideoEncoderConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__SetVideoEncoderConfiguration(struct soap* soap, struct _trt__SetVideoEncoderConfiguration *trt__SetVideoEncoderConfiguration, struct _trt__SetVideoEncoderConfigurationResponse *trt__SetVideoEncoderConfigurationResponse)
+{
+    LOG(INFO,"start !\n");
+    VideoEncoderConfiguration config = {{'\0'}, {'\0'}, '\0', '\0', '\0', '\0', '\0', '\0'};
+    int res_status = 0;
+
+    if(trt__SetVideoEncoderConfiguration!=NULL)
+    {
+        LOG(INFO,"trt__SetVideoEncoderConfiguration->ForcePersistence = %d\n",trt__SetVideoEncoderConfiguration->ForcePersistence);
+        if(trt__SetVideoEncoderConfiguration->ForcePersistence&&(trt__SetVideoEncoderConfiguration->Configuration!=NULL))
+        {
+            if(trt__SetVideoEncoderConfiguration->Configuration->Name!=NULL)
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->Name is %s\r\n",trt__SetVideoEncoderConfiguration->Configuration->Name);
+            LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->UseCount is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->UseCount);
+            if(trt__SetVideoEncoderConfiguration->Configuration->token!=NULL)
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->token is %s\r\n",trt__SetVideoEncoderConfiguration->Configuration->token);
+            if(trt__SetVideoEncoderConfiguration->Configuration->Encoding == 0)
+            {
+                strcpy(config.Encoder,"JPEG");
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->Encoding is JPEG\r\n");
+            }else if(trt__SetVideoEncoderConfiguration->Configuration->Encoding == 1){
+                strcpy(config.Encoder,"MPEG");
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->Encoding is MPEG\r\n");
+            }else if(trt__SetVideoEncoderConfiguration->Configuration->Encoding == 2){
+                strcpy(config.Encoder,"H264");
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->Encoding is H264\r\n");
+            }
+            if(trt__SetVideoEncoderConfiguration->Configuration->Resolution!=NULL)
+            {
+                config.width = trt__SetVideoEncoderConfiguration->Configuration->Resolution->Width;
+                config.height = trt__SetVideoEncoderConfiguration->Configuration->Resolution->Height;
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->Resolution->Width is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->Resolution->Width);
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->Resolution->Heigiht is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->Resolution->Height);
+            }
+            config.quality = trt__SetVideoEncoderConfiguration->Configuration->Quality;
+            LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->Quality is %f\r\n",trt__SetVideoEncoderConfiguration->Configuration->Quality);
+            if(trt__SetVideoEncoderConfiguration->Configuration->RateControl!=NULL)
+            {
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->RateControl->framerateLimit is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->RateControl->FrameRateLimit);
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->RateControl->EncodingInterval is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->RateControl->EncodingInterval);
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->RateControl->bitrateLimit is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->RateControl->BitrateLimit);
+
+                if(strcmp(config.Encoder,"JPEG"))
+                    config.framerate = trt__SetVideoEncoderConfiguration->Configuration->RateControl->FrameRateLimit;
+                else
+                    config.framerate = 30;
+                config.bitrate = trt__SetVideoEncoderConfiguration->Configuration->RateControl->BitrateLimit;
+            }
+            if(trt__SetVideoEncoderConfiguration->Configuration->MPEG4!=NULL)
+            {
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->MPEG4->GovLength is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->MPEG4->GovLength);
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->MPEG4->Mpeg4Profile is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->MPEG4->Mpeg4Profile);
+            }
+            if(trt__SetVideoEncoderConfiguration->Configuration->H264!=NULL)
+            {
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->H264->GovLength is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->H264->GovLength);
+                config.govlen = trt__SetVideoEncoderConfiguration->Configuration->H264->GovLength;
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->H264->H264Profile is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->H264->H264Profile);
+            }
+            if(trt__SetVideoEncoderConfiguration->Configuration->Multicast!=NULL)
+            {
+                if(trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address!=NULL)
+                {
+                    LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address->Type is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address->Type);
+                    if(trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address->IPv4Address!=NULL)
+                        LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address->IPv4Address is %s\r\n",trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address->IPv4Address);
+                    if(trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address->IPv6Address!=NULL)
+                        LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address->IPv6Address is %s\r\n",trt__SetVideoEncoderConfiguration->Configuration->Multicast->Address->IPv6Address);
+                }
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->Multicast->Port is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->Multicast->Port);
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->Multicast->TTL is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->Multicast->TTL);
+                LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->Multicast->AutoStart is %d\r\n",trt__SetVideoEncoderConfiguration->Configuration->Multicast->AutoStart);
+            }
+            LOG(INFO,"trt__SetVideoEncoderConfiguration->Configuration->SessionTimeout is %ld\r\n",trt__SetVideoEncoderConfiguration->Configuration->SessionTimeout);
+        }
+        LOG(INFO,"trt__SetVideoEncoderConfiguration->ForcePersistence is %d\r\n",trt__SetVideoEncoderConfiguration->ForcePersistence);
+
+        _set_videoenc_config(&config, &res_status);
+        if(!res_status)
+            return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__SetAudioSourceConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__SetAudioSourceConfiguration(struct soap* soap, struct _trt__SetAudioSourceConfiguration *trt__SetAudioSourceConfiguration, struct _trt__SetAudioSourceConfigurationResponse *trt__SetAudioSourceConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__SetAudioEncoderConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__SetAudioEncoderConfiguration(struct soap* soap, struct _trt__SetAudioEncoderConfiguration *trt__SetAudioEncoderConfiguration, struct _trt__SetAudioEncoderConfigurationResponse *trt__SetAudioEncoderConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__SetVideoAnalyticsConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__SetVideoAnalyticsConfiguration(struct soap* soap, struct _trt__SetVideoAnalyticsConfiguration *trt__SetVideoAnalyticsConfiguration, struct _trt__SetVideoAnalyticsConfigurationResponse *trt__SetVideoAnalyticsConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__SetMetadataConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__SetMetadataConfiguration(struct soap* soap, struct _trt__SetMetadataConfiguration *trt__SetMetadataConfiguration, struct _trt__SetMetadataConfigurationResponse *trt__SetMetadataConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__SetAudioOutputConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__SetAudioOutputConfiguration(struct soap* soap, struct _trt__SetAudioOutputConfiguration *trt__SetAudioOutputConfiguration, struct _trt__SetAudioOutputConfigurationResponse *trt__SetAudioOutputConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__SetAudioDecoderConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__SetAudioDecoderConfiguration(struct soap* soap, struct _trt__SetAudioDecoderConfiguration *trt__SetAudioDecoderConfiguration, struct _trt__SetAudioDecoderConfigurationResponse *trt__SetAudioDecoderConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetVideoSourceConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoSourceConfigurationOptions(struct soap* soap, struct _trt__GetVideoSourceConfigurationOptions *trt__GetVideoSourceConfigurationOptions, struct _trt__GetVideoSourceConfigurationOptionsResponse *trt__GetVideoSourceConfigurationOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetVideoEncoderConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoEncoderConfigurationOptions(struct soap* soap, struct _trt__GetVideoEncoderConfigurationOptions *trt__GetVideoEncoderConfigurationOptions, struct _trt__GetVideoEncoderConfigurationOptionsResponse *trt__GetVideoEncoderConfigurationOptionsResponse)
+{
+    LOG(INFO,"start !\n");
+
+    if((trt__GetVideoEncoderConfigurationOptionsResponse->Options = (struct tt__VideoEncoderConfigurationOptions*)soap_malloc(soap,sizeof(struct tt__VideoEncoderConfigurationOptions))))
+    {
+        if((trt__GetVideoEncoderConfigurationOptionsResponse->Options->QualityRange = (struct tt__IntRange*)soap_malloc(soap,sizeof(struct tt__IntRange))))
+        {
+            trt__GetVideoEncoderConfigurationOptionsResponse->Options->QualityRange->Min = 1;
+            trt__GetVideoEncoderConfigurationOptionsResponse->Options->QualityRange->Max = 6;
+        }
+        if((trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG = (struct tt__JpegOptions*)soap_malloc(soap,sizeof(struct tt__JpegOptions))))
+        {
+            trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->__sizeResolutionsAvailable = 4;
+            if((trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->ResolutionsAvailable = (struct tt__VideoResolution*)soap_malloc(soap,sizeof(struct tt__VideoResolution)*(trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->__sizeResolutionsAvailable))))
+            {
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->ResolutionsAvailable[0].Width = 1920;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->ResolutionsAvailable[0].Height = 1080;
+
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->ResolutionsAvailable[1].Width = 1280;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->ResolutionsAvailable[1].Height = 720;
+
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->ResolutionsAvailable[2].Width = 720;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->ResolutionsAvailable[2].Height = 576;
+
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->ResolutionsAvailable[3].Width = 328;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->ResolutionsAvailable[3].Height = 288;
+            }
+            if((trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->FrameRateRange = (struct tt__IntRange*)soap_malloc(soap,sizeof(struct tt__IntRange))))
+            {
+                int min = 0;
+                int max = 0;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->FrameRateRange->Min = min;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->FrameRateRange->Max = max;
+            }
+            if((trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->EncodingIntervalRange = (struct tt__IntRange*)soap_malloc(soap,sizeof(struct tt__IntRange))))
+            {
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->EncodingIntervalRange->Min = -1;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->JPEG->EncodingIntervalRange->Max = 1;
+            }
+        }
+        trt__GetVideoEncoderConfigurationOptionsResponse->Options->MPEG4 = NULL;
+        if((trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264 = (struct tt__H264Options*)soap_malloc(soap,sizeof(struct tt__H264Options))))
+        {
+            trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->__sizeResolutionsAvailable = 4;
+            if((trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->ResolutionsAvailable = (struct tt__VideoResolution*)soap_malloc(soap,sizeof(struct tt__VideoResolution)*(trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->__sizeResolutionsAvailable))))
+            {
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->ResolutionsAvailable[0].Width = 1920;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->ResolutionsAvailable[0].Height = 1080;
+
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->ResolutionsAvailable[1].Width = 1280;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->ResolutionsAvailable[1].Height = 720;
+
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->ResolutionsAvailable[2].Width = 720;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->ResolutionsAvailable[2].Height = 576;
+
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->ResolutionsAvailable[3].Width = 352;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->ResolutionsAvailable[3].Height = 288;
+            }
+            if((trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->GovLengthRange = (struct tt__IntRange*)soap_malloc(soap,sizeof(struct tt__IntRange))))
+            {
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->GovLengthRange->Min = 1;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->GovLengthRange->Max = 150;
+            }
+            if((trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->FrameRateRange = (struct tt__IntRange*)soap_malloc(soap,sizeof(struct tt__IntRange))))
+            {
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->FrameRateRange->Min = 1;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->FrameRateRange->Max = 30;
+            }
+            if((trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->EncodingIntervalRange = (struct tt__IntRange*)soap_malloc(soap,sizeof(struct tt__IntRange))))
+            {
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->EncodingIntervalRange->Min = 1;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->EncodingIntervalRange->Max = 1;
+            }
+            trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->__sizeH264ProfilesSupported = 3;
+            if((trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->H264ProfilesSupported = (enum tt__H264Profile*)soap_malloc(soap,sizeof(enum tt__H264Profile))))
+            {
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->H264ProfilesSupported[0] = tt__H264Profile__Baseline;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->H264ProfilesSupported[1] = tt__H264Profile__Main;
+                trt__GetVideoEncoderConfigurationOptionsResponse->Options->H264->H264ProfilesSupported[2] = tt__H264Profile__High;
+            }
+        }
+        trt__GetVideoEncoderConfigurationOptionsResponse->Options->Extension = NULL;
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetAudioSourceConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioSourceConfigurationOptions(struct soap* soap, struct _trt__GetAudioSourceConfigurationOptions *trt__GetAudioSourceConfigurationOptions, struct _trt__GetAudioSourceConfigurationOptionsResponse *trt__GetAudioSourceConfigurationOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetAudioEncoderConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioEncoderConfigurationOptions(struct soap* soap, struct _trt__GetAudioEncoderConfigurationOptions *trt__GetAudioEncoderConfigurationOptions, struct _trt__GetAudioEncoderConfigurationOptionsResponse *trt__GetAudioEncoderConfigurationOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetMetadataConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetMetadataConfigurationOptions(struct soap* soap, struct _trt__GetMetadataConfigurationOptions *trt__GetMetadataConfigurationOptions, struct _trt__GetMetadataConfigurationOptionsResponse *trt__GetMetadataConfigurationOptionsResponse)
+{
+    LOG(INFO,"start !\n");
+#ifdef _DEBUG_
+    if(trt__GetMetadataConfigurationOptions!=NULL&&trt__GetMetadataConfigurationOptions->ConfigurationToken!=NULL)
+        LOG(DBG,"trt__GetMetadataConfigurationOptions->ConfigurationToken is %s \r\n",trt__GetMetadataConfigurationOptions->ConfigurationToken);
+#endif
+    if( trt__GetMetadataConfigurationOptions!=NULL&&trt__GetMetadataConfigurationOptions->ProfileToken!=NULL)
+    {
+#ifdef _DEBUG_
+        LOG(DBG,"trt__GetMetadataConfigurationOptions->ProfileToken is %s\r\n",trt__GetMetadataConfigurationOptions->ProfileToken);
+#endif
+        if((trt__GetMetadataConfigurationOptionsResponse->Options = (struct tt__MetadataConfigurationOptions*)soap_malloc(soap,sizeof(struct tt__MetadataConfigurationOptions))))
+        {
+            if((trt__GetMetadataConfigurationOptionsResponse->Options->PTZStatusFilterOptions = (struct tt__PTZStatusFilterOptions*)soap_malloc(soap,sizeof(struct tt__PTZStatusFilterOptions))))
+            {
+                trt__GetMetadataConfigurationOptionsResponse->Options->PTZStatusFilterOptions->PanTiltStatusSupported = xsd__boolean__false_;
+                trt__GetMetadataConfigurationOptionsResponse->Options->PTZStatusFilterOptions->ZoomStatusSupported = xsd__boolean__false_;
+                if((trt__GetMetadataConfigurationOptionsResponse->Options->PTZStatusFilterOptions->PanTiltPositionSupported = (enum xsd__boolean*)soap_malloc(soap,sizeof(enum xsd__boolean))))
+                    *trt__GetMetadataConfigurationOptionsResponse->Options->PTZStatusFilterOptions->PanTiltPositionSupported = xsd__boolean__false_;
+                if((trt__GetMetadataConfigurationOptionsResponse->Options->PTZStatusFilterOptions->ZoomPositionSupported = (enum xsd__boolean*)soap_malloc(soap,sizeof(enum xsd__boolean))))
+                    *trt__GetMetadataConfigurationOptionsResponse->Options->PTZStatusFilterOptions->ZoomPositionSupported = xsd__boolean__false_;
+                trt__GetMetadataConfigurationOptionsResponse->Options->PTZStatusFilterOptions->Extension = NULL;
+            }
+            trt__GetMetadataConfigurationOptionsResponse->Options->Extension = NULL;
+            if((trt__GetMetadataConfigurationOptionsResponse->Options->GeoLocation = (enum xsd__boolean*)soap_malloc(soap,sizeof(enum xsd__boolean))))
+                *trt__GetMetadataConfigurationOptionsResponse->Options->GeoLocation = xsd__boolean__false_;
+        }
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetAudioOutputConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioOutputConfigurationOptions(struct soap* soap, struct _trt__GetAudioOutputConfigurationOptions *trt__GetAudioOutputConfigurationOptions, struct _trt__GetAudioOutputConfigurationOptionsResponse *trt__GetAudioOutputConfigurationOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetAudioDecoderConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioDecoderConfigurationOptions(struct soap* soap, struct _trt__GetAudioDecoderConfigurationOptions *trt__GetAudioDecoderConfigurationOptions, struct _trt__GetAudioDecoderConfigurationOptionsResponse *trt__GetAudioDecoderConfigurationOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetGuaranteedNumberOfVideoEncoderInstances' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap* soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *trt__GetGuaranteedNumberOfVideoEncoderInstances, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+
+/** Web service operation '__trt__StartMulticastStreaming' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__StartMulticastStreaming(struct soap* soap, struct _trt__StartMulticastStreaming *trt__StartMulticastStreaming, struct _trt__StartMulticastStreamingResponse *trt__StartMulticastStreamingResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__StopMulticastStreaming' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__StopMulticastStreaming(struct soap* soap, struct _trt__StopMulticastStreaming *trt__StopMulticastStreaming, struct _trt__StopMulticastStreamingResponse *trt__StopMulticastStreamingResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__SetSynchronizationPoint' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__SetSynchronizationPoint(struct soap* soap, struct _trt__SetSynchronizationPoint *trt__SetSynchronizationPoint, struct _trt__SetSynchronizationPointResponse *trt__SetSynchronizationPointResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetSnapshotUri' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetSnapshotUri(struct soap* soap, struct _trt__GetSnapshotUri *trt__GetSnapshotUri, struct _trt__GetSnapshotUriResponse *trt__GetSnapshotUriResponse)
+{
+    LOG(INFO,"start !\n");
+    if (szLocalIp[0] == 0)
+    {
+        strncpy(szLocalIp, get_local_ip(), 128);
+    }
+    if((trt__GetSnapshotUriResponse->MediaUri = (struct tt__MediaUri*)soap_malloc(soap,sizeof(struct tt__MediaUri))))
+    {
+        if((trt__GetSnapshotUriResponse->MediaUri->Uri = (char*)soap_malloc(soap,sizeof(char)*INFO_LENGTH)))
+            //          strcpy(trt__GetSnapshotUriResponse->MediaUri->Uri,"http://avatar.csdn.net/7/E/1/1_ghostyu.jpg");
+            sprintf(trt__GetSnapshotUriResponse->MediaUri->Uri,"http://%s/onvifsnapshot/media_service/snapshot",pLocalIp);
+        trt__GetSnapshotUriResponse->MediaUri->InvalidAfterConnect = xsd__boolean__true_;
+        trt__GetSnapshotUriResponse->MediaUri->InvalidAfterReboot = xsd__boolean__true_;
+        trt__GetSnapshotUriResponse->MediaUri->Timeout = 0; //seconds
+
+        return SOAP_OK;
+    }
+    return SOAP_ERR;
+}
+
+/** Web service operation '__trt__GetVideoSourceModes' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoSourceModes(struct soap* soap, struct _trt__GetVideoSourceModes *trt__GetVideoSourceModes, struct _trt__GetVideoSourceModesResponse *trt__GetVideoSourceModesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__SetVideoSourceMode' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__SetVideoSourceMode(struct soap* soap, struct _trt__SetVideoSourceMode *trt__SetVideoSourceMode, struct _trt__SetVideoSourceModeResponse *trt__SetVideoSourceModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetOSDs' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetOSDs(struct soap* soap, struct _trt__GetOSDs *trt__GetOSDs, struct _trt__GetOSDsResponse *trt__GetOSDsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetOSD' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetOSD(struct soap* soap, struct _trt__GetOSD *trt__GetOSD, struct _trt__GetOSDResponse *trt__GetOSDResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__GetOSDOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__GetOSDOptions(struct soap* soap, struct _trt__GetOSDOptions *trt__GetOSDOptions, struct _trt__GetOSDOptionsResponse *trt__GetOSDOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__SetOSD' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__SetOSD(struct soap* soap, struct _trt__SetOSD *trt__SetOSD, struct _trt__SetOSDResponse *trt__SetOSDResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__CreateOSD' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__CreateOSD(struct soap* soap, struct _trt__CreateOSD *trt__CreateOSD, struct _trt__CreateOSDResponse *trt__CreateOSDResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trt__DeleteOSD' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trt__DeleteOSD(struct soap* soap, struct _trt__DeleteOSD *trt__DeleteOSD, struct _trt__DeleteOSDResponse *trt__DeleteOSDResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+
diff --git a/server_interface/ptz.c b/server_interface/ptz.c
new file mode 100644
index 0000000..0858331
--- /dev/null
+++ b/server_interface/ptz.c
@@ -0,0 +1,99 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include "../utils/mpapi.h"
+
+/** Web service operation '__tptz__GetServiceCapabilities' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetServiceCapabilities(struct soap* soap, struct _tptz__GetServiceCapabilities *tptz__GetServiceCapabilities, struct _tptz__GetServiceCapabilitiesResponse *tptz__GetServiceCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GetConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetConfigurations(struct soap* soap, struct _tptz__GetConfigurations *tptz__GetConfigurations, struct _tptz__GetConfigurationsResponse *tptz__GetConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GetPresets' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetPresets(struct soap* soap, struct _tptz__GetPresets *tptz__GetPresets, struct _tptz__GetPresetsResponse *tptz__GetPresetsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__SetPreset' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__SetPreset(struct soap* soap, struct _tptz__SetPreset *tptz__SetPreset, struct _tptz__SetPresetResponse *tptz__SetPresetResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__RemovePreset' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__RemovePreset(struct soap* soap, struct _tptz__RemovePreset *tptz__RemovePreset, struct _tptz__RemovePresetResponse *tptz__RemovePresetResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GotoPreset' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GotoPreset(struct soap* soap, struct _tptz__GotoPreset *tptz__GotoPreset, struct _tptz__GotoPresetResponse *tptz__GotoPresetResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GetStatus' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetStatus(struct soap* soap, struct _tptz__GetStatus *tptz__GetStatus, struct _tptz__GetStatusResponse *tptz__GetStatusResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GetConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetConfiguration(struct soap* soap, struct _tptz__GetConfiguration *tptz__GetConfiguration, struct _tptz__GetConfigurationResponse *tptz__GetConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GetNodes' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetNodes(struct soap* soap, struct _tptz__GetNodes *tptz__GetNodes, struct _tptz__GetNodesResponse *tptz__GetNodesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GetNode' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetNode(struct soap* soap, struct _tptz__GetNode *tptz__GetNode, struct _tptz__GetNodeResponse *tptz__GetNodeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__SetConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__SetConfiguration(struct soap* soap, struct _tptz__SetConfiguration *tptz__SetConfiguration, struct _tptz__SetConfigurationResponse *tptz__SetConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GetConfigurationOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetConfigurationOptions(struct soap* soap, struct _tptz__GetConfigurationOptions *tptz__GetConfigurationOptions, struct _tptz__GetConfigurationOptionsResponse *tptz__GetConfigurationOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GotoHomePosition' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GotoHomePosition(struct soap* soap, struct _tptz__GotoHomePosition *tptz__GotoHomePosition, struct _tptz__GotoHomePositionResponse *tptz__GotoHomePositionResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__SetHomePosition' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__SetHomePosition(struct soap* soap, struct _tptz__SetHomePosition *tptz__SetHomePosition, struct _tptz__SetHomePositionResponse *tptz__SetHomePositionResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__ContinuousMove' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__ContinuousMove(struct soap* soap, struct _tptz__ContinuousMove *tptz__ContinuousMove, struct _tptz__ContinuousMoveResponse *tptz__ContinuousMoveResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__RelativeMove' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__RelativeMove(struct soap* soap, struct _tptz__RelativeMove *tptz__RelativeMove, struct _tptz__RelativeMoveResponse *tptz__RelativeMoveResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__SendAuxiliaryCommand' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__SendAuxiliaryCommand(struct soap* soap, struct _tptz__SendAuxiliaryCommand *tptz__SendAuxiliaryCommand, struct _tptz__SendAuxiliaryCommandResponse *tptz__SendAuxiliaryCommandResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__AbsoluteMove' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__AbsoluteMove(struct soap* soap, struct _tptz__AbsoluteMove *tptz__AbsoluteMove, struct _tptz__AbsoluteMoveResponse *tptz__AbsoluteMoveResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GeoMove' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GeoMove(struct soap* soap, struct _tptz__GeoMove *tptz__GeoMove, struct _tptz__GeoMoveResponse *tptz__GeoMoveResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__Stop' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__Stop(struct soap* soap, struct _tptz__Stop *tptz__Stop, struct _tptz__StopResponse *tptz__StopResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GetPresetTours' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetPresetTours(struct soap* soap, struct _tptz__GetPresetTours *tptz__GetPresetTours, struct _tptz__GetPresetToursResponse *tptz__GetPresetToursResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GetPresetTour' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetPresetTour(struct soap* soap, struct _tptz__GetPresetTour *tptz__GetPresetTour, struct _tptz__GetPresetTourResponse *tptz__GetPresetTourResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GetPresetTourOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetPresetTourOptions(struct soap* soap, struct _tptz__GetPresetTourOptions *tptz__GetPresetTourOptions, struct _tptz__GetPresetTourOptionsResponse *tptz__GetPresetTourOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__CreatePresetTour' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__CreatePresetTour(struct soap* soap, struct _tptz__CreatePresetTour *tptz__CreatePresetTour, struct _tptz__CreatePresetTourResponse *tptz__CreatePresetTourResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__ModifyPresetTour' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__ModifyPresetTour(struct soap* soap, struct _tptz__ModifyPresetTour *tptz__ModifyPresetTour, struct _tptz__ModifyPresetTourResponse *tptz__ModifyPresetTourResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__OperatePresetTour' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__OperatePresetTour(struct soap* soap, struct _tptz__OperatePresetTour *tptz__OperatePresetTour, struct _tptz__OperatePresetTourResponse *tptz__OperatePresetTourResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__RemovePresetTour' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__RemovePresetTour(struct soap* soap, struct _tptz__RemovePresetTour *tptz__RemovePresetTour, struct _tptz__RemovePresetTourResponse *tptz__RemovePresetTourResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tptz__GetCompatibleConfigurations' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetCompatibleConfigurations(struct soap* soap, struct _tptz__GetCompatibleConfigurations *tptz__GetCompatibleConfigurations, struct _tptz__GetCompatibleConfigurationsResponse *tptz__GetCompatibleConfigurationsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
diff --git a/server_interface/receiver.c b/server_interface/receiver.c
new file mode 100644
index 0000000..8a3a983
--- /dev/null
+++ b/server_interface/receiver.c
@@ -0,0 +1,58 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include "../utils/mpapi.h"
+/** Web service operation '__trv__GetServiceCapabilities' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trv__GetServiceCapabilities(struct soap* soap, struct _trv__GetServiceCapabilities *trv__GetServiceCapabilities, struct _trv__GetServiceCapabilitiesResponse *trv__GetServiceCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trv__GetReceivers' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trv__GetReceivers(struct soap* soap, struct _trv__GetReceivers *trv__GetReceivers, struct _trv__GetReceiversResponse *trv__GetReceiversResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trv__GetReceiver' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trv__GetReceiver(struct soap* soap, struct _trv__GetReceiver *trv__GetReceiver, struct _trv__GetReceiverResponse *trv__GetReceiverResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trv__CreateReceiver' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trv__CreateReceiver(struct soap* soap, struct _trv__CreateReceiver *trv__CreateReceiver, struct _trv__CreateReceiverResponse *trv__CreateReceiverResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trv__DeleteReceiver' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trv__DeleteReceiver(struct soap* soap, struct _trv__DeleteReceiver *trv__DeleteReceiver, struct _trv__DeleteReceiverResponse *trv__DeleteReceiverResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trv__ConfigureReceiver' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trv__ConfigureReceiver(struct soap* soap, struct _trv__ConfigureReceiver *trv__ConfigureReceiver, struct _trv__ConfigureReceiverResponse *trv__ConfigureReceiverResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trv__SetReceiverMode' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trv__SetReceiverMode(struct soap* soap, struct _trv__SetReceiverMode *trv__SetReceiverMode, struct _trv__SetReceiverModeResponse *trv__SetReceiverModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trv__GetReceiverState' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trv__GetReceiverState(struct soap* soap, struct _trv__GetReceiverState *trv__GetReceiverState, struct _trv__GetReceiverStateResponse *trv__GetReceiverStateResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
diff --git a/server_interface/recording.c b/server_interface/recording.c
new file mode 100644
index 0000000..ecf7b31
--- /dev/null
+++ b/server_interface/recording.c
@@ -0,0 +1,84 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include "../utils/mpapi.h"
+/** Web service operation '__trc__GetServiceCapabilities' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__GetServiceCapabilities(struct soap* soap, struct _trc__GetServiceCapabilities *trc__GetServiceCapabilities, struct _trc__GetServiceCapabilitiesResponse *trc__GetServiceCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__CreateRecording' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__CreateRecording(struct soap* soap, struct _trc__CreateRecording *trc__CreateRecording, struct _trc__CreateRecordingResponse *trc__CreateRecordingResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__DeleteRecording' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__DeleteRecording(struct soap* soap, struct _trc__DeleteRecording *trc__DeleteRecording, struct _trc__DeleteRecordingResponse *trc__DeleteRecordingResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__GetRecordings' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__GetRecordings(struct soap* soap, struct _trc__GetRecordings *trc__GetRecordings, struct _trc__GetRecordingsResponse *trc__GetRecordingsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__SetRecordingConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__SetRecordingConfiguration(struct soap* soap, struct _trc__SetRecordingConfiguration *trc__SetRecordingConfiguration, struct _trc__SetRecordingConfigurationResponse *trc__SetRecordingConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__GetRecordingConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__GetRecordingConfiguration(struct soap* soap, struct _trc__GetRecordingConfiguration *trc__GetRecordingConfiguration, struct _trc__GetRecordingConfigurationResponse *trc__GetRecordingConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__GetRecordingOptions' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__GetRecordingOptions(struct soap* soap, struct _trc__GetRecordingOptions *trc__GetRecordingOptions, struct _trc__GetRecordingOptionsResponse *trc__GetRecordingOptionsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__CreateTrack' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__CreateTrack(struct soap* soap, struct _trc__CreateTrack *trc__CreateTrack, struct _trc__CreateTrackResponse *trc__CreateTrackResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__DeleteTrack' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__DeleteTrack(struct soap* soap, struct _trc__DeleteTrack *trc__DeleteTrack, struct _trc__DeleteTrackResponse *trc__DeleteTrackResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__GetTrackConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__GetTrackConfiguration(struct soap* soap, struct _trc__GetTrackConfiguration *trc__GetTrackConfiguration, struct _trc__GetTrackConfigurationResponse *trc__GetTrackConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__SetTrackConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__SetTrackConfiguration(struct soap* soap, struct _trc__SetTrackConfiguration *trc__SetTrackConfiguration, struct _trc__SetTrackConfigurationResponse *trc__SetTrackConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__CreateRecordingJob' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__CreateRecordingJob(struct soap* soap, struct _trc__CreateRecordingJob *trc__CreateRecordingJob, struct _trc__CreateRecordingJobResponse *trc__CreateRecordingJobResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__DeleteRecordingJob' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__DeleteRecordingJob(struct soap* soap, struct _trc__DeleteRecordingJob *trc__DeleteRecordingJob, struct _trc__DeleteRecordingJobResponse *trc__DeleteRecordingJobResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__GetRecordingJobs' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__GetRecordingJobs(struct soap* soap, struct _trc__GetRecordingJobs *trc__GetRecordingJobs, struct _trc__GetRecordingJobsResponse *trc__GetRecordingJobsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__SetRecordingJobConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__SetRecordingJobConfiguration(struct soap* soap, struct _trc__SetRecordingJobConfiguration *trc__SetRecordingJobConfiguration, struct _trc__SetRecordingJobConfigurationResponse *trc__SetRecordingJobConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__GetRecordingJobConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__GetRecordingJobConfiguration(struct soap* soap, struct _trc__GetRecordingJobConfiguration *trc__GetRecordingJobConfiguration, struct _trc__GetRecordingJobConfigurationResponse *trc__GetRecordingJobConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__SetRecordingJobMode' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__SetRecordingJobMode(struct soap* soap, struct _trc__SetRecordingJobMode *trc__SetRecordingJobMode, struct _trc__SetRecordingJobModeResponse *trc__SetRecordingJobModeResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__GetRecordingJobState' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__GetRecordingJobState(struct soap* soap, struct _trc__GetRecordingJobState *trc__GetRecordingJobState, struct _trc__GetRecordingJobStateResponse *trc__GetRecordingJobStateResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__ExportRecordedData' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__ExportRecordedData(struct soap* soap, struct _trc__ExportRecordedData *trc__ExportRecordedData, struct _trc__ExportRecordedDataResponse *trc__ExportRecordedDataResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__StopExportRecordedData' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__StopExportRecordedData(struct soap* soap, struct _trc__StopExportRecordedData *trc__StopExportRecordedData, struct _trc__StopExportRecordedDataResponse *trc__StopExportRecordedDataResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trc__GetExportRecordedDataState' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trc__GetExportRecordedDataState(struct soap* soap, struct _trc__GetExportRecordedDataState *trc__GetExportRecordedDataState, struct _trc__GetExportRecordedDataStateResponse *trc__GetExportRecordedDataStateResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
diff --git a/server_interface/replay.c b/server_interface/replay.c
new file mode 100644
index 0000000..67a7764
--- /dev/null
+++ b/server_interface/replay.c
@@ -0,0 +1,50 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include "../utils/mpapi.h"
+/** Web service operation '__trp__GetServiceCapabilities' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trp__GetServiceCapabilities(struct soap* soap, struct _trp__GetServiceCapabilities *trp__GetServiceCapabilities, struct _trp__GetServiceCapabilitiesResponse *trp__GetServiceCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trp__GetReplayUri' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trp__GetReplayUri(struct soap* soap, struct _trp__GetReplayUri *trp__GetReplayUri, struct _trp__GetReplayUriResponse *trp__GetReplayUriResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trp__GetReplayConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trp__GetReplayConfiguration(struct soap* soap, struct _trp__GetReplayConfiguration *trp__GetReplayConfiguration, struct _trp__GetReplayConfigurationResponse *trp__GetReplayConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__trp__SetReplayConfiguration' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __trp__SetReplayConfiguration(struct soap* soap, struct _trp__SetReplayConfiguration *trp__SetReplayConfiguration, struct _trp__SetReplayConfigurationResponse *trp__SetReplayConfigurationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
diff --git a/server_interface/search.c b/server_interface/search.c
new file mode 100644
index 0000000..f162e5b
--- /dev/null
+++ b/server_interface/search.c
@@ -0,0 +1,70 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include "../utils/mpapi.h"
+/** Web service operation '__tse__GetServiceCapabilities' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__GetServiceCapabilities(struct soap* soap, struct _tse__GetServiceCapabilities *tse__GetServiceCapabilities, struct _tse__GetServiceCapabilitiesResponse *tse__GetServiceCapabilitiesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tse__GetRecordingSummary' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__GetRecordingSummary(struct soap* soap, struct _tse__GetRecordingSummary *tse__GetRecordingSummary, struct _tse__GetRecordingSummaryResponse *tse__GetRecordingSummaryResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tse__GetRecordingInformation' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__GetRecordingInformation(struct soap* soap, struct _tse__GetRecordingInformation *tse__GetRecordingInformation, struct _tse__GetRecordingInformationResponse *tse__GetRecordingInformationResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tse__GetMediaAttributes' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__GetMediaAttributes(struct soap* soap, struct _tse__GetMediaAttributes *tse__GetMediaAttributes, struct _tse__GetMediaAttributesResponse *tse__GetMediaAttributesResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tse__FindRecordings' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__FindRecordings(struct soap* soap, struct _tse__FindRecordings *tse__FindRecordings, struct _tse__FindRecordingsResponse *tse__FindRecordingsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tse__GetRecordingSearchResults' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__GetRecordingSearchResults(struct soap* soap, struct _tse__GetRecordingSearchResults *tse__GetRecordingSearchResults, struct _tse__GetRecordingSearchResultsResponse *tse__GetRecordingSearchResultsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tse__FindEvents' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__FindEvents(struct soap* soap, struct _tse__FindEvents *tse__FindEvents, struct _tse__FindEventsResponse *tse__FindEventsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tse__GetEventSearchResults' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__GetEventSearchResults(struct soap* soap, struct _tse__GetEventSearchResults *tse__GetEventSearchResults, struct _tse__GetEventSearchResultsResponse *tse__GetEventSearchResultsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tse__FindPTZPosition' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__FindPTZPosition(struct soap* soap, struct _tse__FindPTZPosition *tse__FindPTZPosition, struct _tse__FindPTZPositionResponse *tse__FindPTZPositionResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tse__GetPTZPositionSearchResults' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__GetPTZPositionSearchResults(struct soap* soap, struct _tse__GetPTZPositionSearchResults *tse__GetPTZPositionSearchResults, struct _tse__GetPTZPositionSearchResultsResponse *tse__GetPTZPositionSearchResultsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tse__GetSearchState' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__GetSearchState(struct soap* soap, struct _tse__GetSearchState *tse__GetSearchState, struct _tse__GetSearchStateResponse *tse__GetSearchStateResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tse__EndSearch' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__EndSearch(struct soap* soap, struct _tse__EndSearch *tse__EndSearch, struct _tse__EndSearchResponse *tse__EndSearchResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tse__FindMetadata' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__FindMetadata(struct soap* soap, struct _tse__FindMetadata *tse__FindMetadata, struct _tse__FindMetadataResponse *tse__FindMetadataResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
+/** Web service operation '__tse__GetMetadataSearchResults' (returns SOAP_OK or error code) */
+SOAP_FMAC5 int SOAP_FMAC6 __tse__GetMetadataSearchResults(struct soap* soap, struct _tse__GetMetadataSearchResults *tse__GetMetadataSearchResults, struct _tse__GetMetadataSearchResultsResponse *tse__GetMetadataSearchResultsResponse){ONVIF_NOTSUPPORTED_FUNC(soap, NULL);}
diff --git a/utils/mpapi.c b/utils/mpapi.c
new file mode 100644
index 0000000..dbfd968
--- /dev/null
+++ b/utils/mpapi.c
@@ -0,0 +1,523 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#include<sys/un.h>
+#include "mpapi.h"
+
+enum ERRNUM
+{
+    LENTH_TOOLONG = -1,
+    COMMAND_NOTFOUND = -2,
+    JSON_TRANS_ERROR = -3,
+    SETVALUE_FAILED = -4
+};
+#define SERVERNAME "/tmp/onvif"
+
+static int socket_client(char* request);
+static int parseErr(const char *s, recvErrMsg *recvErr);
+static int parseNormal(const char *s, char *ope, struct json_object **param);
+static int parse(const char *s, char *ope, struct json_object **param);
+
+//The communication between onvif and mediapipe through socket , and this is the client socket.
+static int socket_client(char* request)
+{
+    assert(NULL != request);
+    int sockfd = -1;
+    struct sockaddr_un ser_address;
+    sockfd = socket(PF_UNIX, SOCK_STREAM, 0);
+    ser_address.sun_family = AF_UNIX;
+    strncpy(ser_address.sun_path, SERVERNAME, sizeof(ser_address.sun_path)-1);
+    if(-1 == connect(sockfd, (struct sockaddr*)&ser_address, sizeof(ser_address)))
+    {
+        perror("[ERROR]ops:client\n");
+        close(sockfd);
+        return RET_FAILED;
+    }
+    LOG(INFO,"send request = %s\n",request);
+    int len = 0;
+    int sentLen = 0;
+    const char *sendPtr = request;
+    while(1)
+    {
+        len = send(sockfd, sendPtr, strlen(request) - sentLen, 0);
+        if (len == -1)
+        {
+            LOG(ERROR, "socketerror:%s\n", strerror(errno));
+            close(sockfd);
+            return RET_FAILED;
+        }
+        sentLen += len;
+        if ( sentLen == strlen(request))
+            break;
+        sendPtr += len;
+        LOG(INFO, "already sent %d total %d\n", sentLen, strlen(request));
+    }
+    memset(request,'\0',LARGE_INFO_LENGTH);
+    int recLen=0;
+    char* recPtr = request;
+    while(1) {
+        len = recv(sockfd,recPtr, LARGE_INFO_LENGTH - recLen, 0);
+        if(len == -1)
+        {
+            LOG(ERROR, "socketerror:%d\n", strerror(errno));
+            close(sockfd);
+            return RET_FAILED;
+        }
+        recLen += len;
+        if (request[recLen - 1] == '\n')
+        {
+            break;
+        } else if (recLen == LARGE_INFO_LENGTH) {
+            LOG(ERROR, "Recieve error message\n");
+            close(sockfd);
+            return RET_FAILED;
+        }
+        recPtr += len;
+        LOG(INFO, "receive again\n");
+    }
+    LOG(INFO,"recv request = %s\n",request);
+    close(sockfd);
+    return RET_SUCESS;
+}
+
+static int parseErr(const char *s, recvErrMsg *recvErr)
+{
+    assert(NULL != s);
+    assert(NULL != recvErr);
+    char *c;
+    char tmps[LARGE_INFO_LENGTH];
+    strcpy(tmps, s);
+    strtok(tmps, " @");
+    int num = 0;
+    recvErrMsg *pmsg = recvErr;
+    int isSetFault = 0;
+    while ((c = strtok(NULL, "@"))) {
+            if(num == 0)
+            {
+                pmsg->errorno = atoi(c);
+                switch(pmsg->errorno)
+                {
+                    case LENTH_TOOLONG:
+                    case COMMAND_NOTFOUND:
+                    case JSON_TRANS_ERROR:
+                        return RET_FAILED;
+                    case SETVALUE_FAILED:
+                        LOG(WARN,"can not set value correct\n");
+                        isSetFault = 1;
+                        break;
+                    default:
+                        return RET_FAILED;
+                }
+            }else if(num == 1) {
+                pmsg->msglen = atoi(c);
+            } else if (num == 2) {
+                snprintf(pmsg->msg, strlen(c), "%s", c);
+            } else if (num ==3) {
+                snprintf(pmsg->detail, strlen(c), "%s", c);
+            } else if (num == 4) {
+                snprintf(pmsg->setresult, strlen(c), "%s", c);
+            }
+            num ++;
+    }
+    //The expected num value should be 4 and 5
+    if (((isSetFault == 1) && (num == 5)) || ((isSetFault == 0) && (num == 4)))
+    {
+        return RET_SUCESS;
+    } else {
+        return RET_FAILED;
+    }
+}
+
+static int parseNormal(const char *s, char *ope, struct json_object **param)
+{
+    assert(NULL != s);
+    assert(NULL != ope);
+    assert(NULL != param);
+    const char *needle = "@";
+    char *p = strstr(s, needle);
+    if (p == NULL) {
+        return RET_FAILED;
+    }
+    memcpy(ope, s, p - s);
+    *(ope + (p - s)) = '\0';
+    p++;
+    *param = json_tokener_parse(p);
+    if (*param == NULL) {
+        return RET_FAILED;
+    }
+    return RET_SUCESS;
+}
+
+static int parse(const char *s, char *ope, struct json_object **param)
+{
+    assert(NULL != s);
+    assert(NULL != ope);
+    assert(NULL != param);
+    const char *needle = "error@";
+    const char *needleSucess = "success@";
+    char *pSucess = strstr(s, needleSucess);
+    if (pSucess != NULL)
+    {
+        return RET_SUCESS;
+    }
+    char *p = strstr(s, needle);
+    if (p != NULL)
+    {
+        recvErrMsg msg;
+        msg.errorno = 0;
+        msg.msglen = 0;
+        memset(msg.msg, '\0', LARGE_INFO_LENGTH);
+        memset(msg.detail, '\0', LARGE_INFO_LENGTH);
+        memset(msg.setresult, '\0', LARGE_INFO_LENGTH);
+        int rlt = parseErr(s, &msg);
+        if (RET_FAILED == rlt)
+            LOG(INFO,"Incorrect error message parsing in:%s or unexpect result\n", s);
+        else
+            LOG(INFO, "Recieve err is:(errno)%d  (msglen)%d  (msg)%s (dettail)%s (not set sucess):%s\n", msg.errorno, msg.msglen, msg.msg, msg.detail, msg.setresult);
+        return rlt;
+    } else {
+        return parseNormal(s, ope, param);
+    }
+}
+
+
+void _get_stream_uri(char *uri,int* res_status)
+{
+    assert(NULL != res_status);
+    assert(NULL != uri);
+
+    char req[LARGE_INFO_LENGTH] = {'\0'};
+    char operation[100] = {'\0'};
+    struct json_object *obj = NULL;
+    *res_status = RET_SUCESS;
+
+    strcpy(req,"get_stream_uri@{}\n");
+    if(!socket_client(req))
+    {
+        if (parse(req, operation, &obj) == 0) {
+            json_object *streamuri = NULL;
+            if (json_object_object_get_ex(obj, "streamuri", &streamuri)) {
+                snprintf(uri, SHORT_LENGTH - 1, "%s", json_object_get_string(streamuri));
+
+            }
+        } else {
+            LOG(WARN, "Parse fail!\n");
+            *res_status = RET_FAILED;
+        }
+    } else {
+        LOG(ERROR, "socket_client fail!\n");
+        *res_status = -1;
+    }
+    if(obj != NULL)
+        json_object_put(obj);
+    return;
+}
+void _get_range(Options *opt, int* res_status)
+{
+    assert(NULL != opt);
+    assert(NULL != res_status);
+    char req[LARGE_INFO_LENGTH] = {'\0'};
+    char operation[100] = {'\0'};
+    struct json_object *obj;
+    *res_status = RET_SUCESS;
+
+    strcpy(req,"get_range@{}\n");
+
+    if(!socket_client(req))
+    {
+        if (parse(req, operation, &obj) == 0)
+        {
+            json_object *brightness_min = NULL;
+            json_object *brightness_max = NULL;
+            json_object *colorsaturation_max = NULL;
+            json_object *colorsaturation_min = NULL;
+            json_object *contrast_min = NULL;
+            json_object *contrast_max = NULL;
+            json_object *sharpness_min = NULL;
+            json_object *sharpness_max = NULL;
+            json_object *exposuretime_min = NULL;
+            json_object *exposuretime_max = NULL;
+            json_object *iris_min = NULL;
+            json_object *iris_max = NULL;
+
+            if (json_object_object_get_ex(obj, "brightness_min", &brightness_min)) {
+                const char *_brightness_min = json_object_get_string(brightness_min);
+                opt->brightness_min = atoi(_brightness_min);
+            }
+            if (json_object_object_get_ex(obj, "brightness_max", &brightness_max)) {
+                const char *_brightness_max = json_object_get_string(brightness_max);
+                opt->brightness_max = atoi(_brightness_max);
+            }
+            if (json_object_object_get_ex(obj, "contrast_min", &contrast_min)) {
+                const char *_contrast_min = json_object_get_string(contrast_min);
+                opt->contrast_min = atoi(_contrast_min);
+            }
+            if (json_object_object_get_ex(obj, "contrast_max", &contrast_max)) {
+                const char *_contrast_max = json_object_get_string(contrast_max);
+                opt->contrast_max = atoi(_contrast_max);
+            }
+            if (json_object_object_get_ex(obj, "colorsaturation_min", &colorsaturation_min)) {
+                const char *_colorsaturation_min = json_object_get_string(colorsaturation_min);
+                opt->colorsaturation_min = atoi(_colorsaturation_min);
+            }
+            if (json_object_object_get_ex(obj, "colorsaturation_max", &colorsaturation_max)) {
+                const char *_colorsaturation_max = json_object_get_string(colorsaturation_max);
+                opt->colorsaturation_max = atoi(_colorsaturation_max);
+            }
+            if (json_object_object_get_ex(obj, "sharpness_min", &sharpness_min)) {
+                const char *_sharpness_min = json_object_get_string(sharpness_min);
+                opt->sharpness_min = atoi(_sharpness_min);
+            }
+            if (json_object_object_get_ex(obj, "sharpness_max", &sharpness_max)) {
+                const char *_sharpness_max = json_object_get_string(sharpness_max);
+                opt->sharpness_max = atoi(_sharpness_max);
+            }
+            if (json_object_object_get_ex(obj, "exposuretime_min", &exposuretime_min)) {
+                const char *_exposuretime_min = json_object_get_string(exposuretime_min);
+                opt->exposuretime_min = atoi(_exposuretime_min);
+            }
+            if (json_object_object_get_ex(obj, "exposuretime_max", &exposuretime_max)) {
+                const char *_exposuretime_max = json_object_get_string(exposuretime_max);
+                opt->exposuretime_max = atoi(_exposuretime_max);
+            }
+            if (json_object_object_get_ex(obj, "iris_min", &iris_min)) {
+                const char *_iris_min = json_object_get_string(iris_min);
+                opt->iris_min = atoi(_iris_min);
+            }
+            if (json_object_object_get_ex(obj, "iris_max", &iris_max)) {
+                const char *_iris_max = json_object_get_string(iris_max);
+                opt->iris_max = atoi(_iris_max);
+            }
+            return;
+        }
+    }
+
+    *res_status = RET_FAILED;
+}
+
+void _get_image_config(ImagingSetting *img,int* res_status)
+{
+    assert(NULL != res_status);
+    assert(NULL != img);
+
+    char req[LARGE_INFO_LENGTH] = {'\0'};
+    char operation[100] = {'\0'};
+    struct json_object *obj;
+
+    *res_status = RET_SUCESS;
+
+    strcpy(req,"get_image_config@{}\n");
+    if(!socket_client(req))
+    {
+        if (parse(req, operation, &obj) == 0)
+        {
+            json_object *brightness = NULL;
+            json_object *contrast = NULL;
+            json_object *colorsaturation = NULL;
+            json_object *sharpness = NULL;
+            json_object *exposuretime = NULL;
+            json_object *exposuremode = NULL;
+            json_object *irismode = NULL;
+            json_object *irislevel = NULL;
+
+            if (json_object_object_get_ex(obj, "brightness", &brightness)) {
+                const char *_brightness = json_object_get_string(brightness);
+                img->brightness = atoi(_brightness);
+            }
+            if (json_object_object_get_ex(obj, "contrast", &contrast)) {
+                const char *_contrast = json_object_get_string(contrast);
+                img->contrast = atoi(_contrast);
+            }
+            if (json_object_object_get_ex(obj, "colorsaturation", &colorsaturation)) {
+                const char *_colorsaturation = json_object_get_string(colorsaturation);
+                img->colorsaturation = atoi(_colorsaturation);
+            }
+            if (json_object_object_get_ex(obj, "sharpness", &sharpness)) {
+                const char *_sharpness = json_object_get_string(sharpness);
+                img->sharpness = atoi(_sharpness);
+            }
+            if (json_object_object_get_ex(obj, "exposuretime", &exposuretime)) {
+                const char *_exposuretime = json_object_get_string(exposuretime);
+                img->exposuretime = atoi(_exposuretime);
+            }
+            if (json_object_object_get_ex(obj, "exposuremode", &exposuremode)) {
+                const char *_exposuremode = json_object_get_string(exposuremode);
+                img->exposuremode = atoi(_exposuremode);
+            }
+            if (json_object_object_get_ex(obj, "irismode", &irismode)) {
+                const char *_irismode = json_object_get_string(irismode);
+                img->irismode = atoi(_irismode);
+            }
+            if (json_object_object_get_ex(obj, "irislevel", &irislevel)) {
+                const char *_irislevel = json_object_get_string(irislevel);
+                img->irislevel = atoi(_irislevel);
+            }
+
+            LOG(INFO,"\n__timg__GetImagingSettings result is  brightness=%d,colorsaturation=%d,contrast=%d,sharpness=%d,exposuretime=%d \n", \
+                img->brightness,img->colorsaturation,img->contrast,img->sharpness,img->exposuretime);
+            return;
+        }
+    }
+
+    *res_status = RET_FAILED;
+}
+
+void _get_videoenc_config(VideoEncoderConfiguration *videoenc,int* res_status)
+{
+    assert(NULL != videoenc);
+    assert(NULL != res_status);
+
+    char req[LARGE_INFO_LENGTH] = {'\0'};
+    char operation[100] = {'\0'};
+    struct json_object *obj;
+    *res_status = RET_SUCESS;
+
+    strcpy(req,"get_videoenc_config@{}\n");
+    if(!socket_client(req))
+    {
+        if (parse(req, operation, &obj) == 0)
+        {
+            json_object *encoder = NULL;
+            json_object *bitratemode = NULL;
+            json_object *bitrate = NULL;
+            json_object *framerate = NULL;
+            json_object *width = NULL;
+            json_object *height = NULL;
+            json_object *quality = NULL;
+            json_object *govlen = NULL;
+
+            if (json_object_object_get_ex(obj, "encoder", &encoder)) {
+                const char *_encoder = json_object_get_string(encoder);
+                strcpy(videoenc->Encoder,_encoder);
+            }
+            if (json_object_object_get_ex(obj, "bitratemode", &bitratemode)) {
+                const char *_bitratemode = json_object_get_string(bitratemode);
+                strcpy(videoenc->bitratemode,_bitratemode);
+            }
+            if (json_object_object_get_ex(obj, "bitrate", &bitrate)) {
+                const char *_bitrate = json_object_get_string(bitrate);
+                videoenc->bitrate = atoi(_bitrate);
+            }
+            if (json_object_object_get_ex(obj, "framerate", &framerate)) {
+                const char *_framerate = json_object_get_string(framerate);
+                videoenc->framerate = atoi(_framerate);
+            }
+            if (json_object_object_get_ex(obj, "width", &width)) {
+                const char *_width = json_object_get_string(width);
+                videoenc->width = atoi(_width);
+            }
+            if (json_object_object_get_ex(obj, "height", &height)) {
+                const char *_height = json_object_get_string(height);
+                videoenc->height = atoi(_height);
+            }
+            if (json_object_object_get_ex(obj, "quality", &quality)) {
+//              const char *_quality = json_object_get_string(quality);
+                char *pEnd;
+                float qualityf = strtof(json_object_get_string(quality),&pEnd);
+                videoenc->quality = qualityf/10;
+            }
+            if (json_object_object_get_ex(obj, "govlen", &govlen)) {
+                const char *_govlen = json_object_get_string(govlen);
+                videoenc->govlen = atoi(_govlen);
+            }
+
+            LOG(INFO,"[Set To Class]:videoenc->encoder=%s\tvideoenc-bitratemode=%s\tvideoenc->bitrate=%d\tvideoenc->framerate=%d\tvideoenc->width=%d\tvideoenc->height=%d\tvideoenc->quality=%f\tvideoenc->govlen=%d\n", \
+                videoenc->Encoder,videoenc->bitratemode,videoenc->bitrate,videoenc->framerate,videoenc->width,videoenc->height,videoenc->quality, videoenc->govlen);
+            return;
+
+        }
+    }
+    *res_status = RET_FAILED;
+}
+
+void _set_image_config(ImagingSetting *img,int* res_status)
+{
+    assert(NULL != img);
+    assert(NULL != res_status);
+
+    char req[LARGE_INFO_LENGTH] = {'\0'};
+    struct json_object *obj;
+
+    obj = json_object_new_object();
+    json_object_object_add(obj, "brightness", json_object_new_int(img->brightness));
+    json_object_object_add(obj, "contrast", json_object_new_int(img->contrast));
+    json_object_object_add(obj, "colorsaturation", json_object_new_int(img->colorsaturation));
+    json_object_object_add(obj, "sharpness", json_object_new_int(img->sharpness));
+    json_object_object_add(obj, "exposuretime", json_object_new_int(img->exposuretime));
+    json_object_object_add(obj, "exposuremode", json_object_new_int(img->exposuremode));
+    json_object_object_add(obj, "irismode", json_object_new_int(img->irismode));
+    json_object_object_add(obj, "irislevel", json_object_new_int(img->irislevel));
+    LOG(INFO,"obj.to_string()=%s\n", json_object_to_json_string(obj));
+    strcpy(req,"set_image_config@");
+    strcat(req,json_object_to_json_string(obj));
+    strcat(req,"\n");
+    if(socket_client(req))
+        *res_status = RET_FAILED;
+    *res_status = RET_SUCESS;
+}
+
+void _set_videoenc_config(VideoEncoderConfiguration *videoenc,int* res_status)
+{
+    assert(NULL != res_status);
+    assert(NULL != videoenc);
+
+    char req[LARGE_INFO_LENGTH] = {'\0'};
+    struct json_object *obj;
+
+    obj = json_object_new_object();
+    json_object_object_add(obj, "encoder", json_object_new_string(videoenc->Encoder));
+    json_object_object_add(obj, "bitratemode", json_object_new_string(videoenc->bitratemode));
+    json_object_object_add(obj, "bitrate", json_object_new_int(videoenc->bitrate));
+    json_object_object_add(obj, "framerate", json_object_new_int(videoenc->framerate));
+    json_object_object_add(obj, "width", json_object_new_int(videoenc->width));
+    json_object_object_add(obj, "height", json_object_new_int(videoenc->height));
+    json_object_object_add(obj, "quality", json_object_new_int((int)(videoenc->quality*10)));
+    json_object_object_add(obj, "govlen", json_object_new_int(videoenc->govlen));
+    LOG(INFO,"obj.to_string()=%s\n", json_object_to_json_string(obj));
+    strcpy(req,"set_videoenc_config@");
+    strcat(req,json_object_to_json_string(obj));
+    strcat(req,"\n");
+    if(socket_client(req))
+        *res_status = RET_FAILED;
+    *res_status = RET_SUCESS;
+
+}
+
diff --git a/utils/mpapi.h b/utils/mpapi.h
new file mode 100644
index 0000000..412cfa8
--- /dev/null
+++ b/utils/mpapi.h
@@ -0,0 +1,63 @@
+/*
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+*/
+#ifndef MPAPI_H_
+#define MPAPI_H_
+#include <assert.h>
+#include "../commonfunc/commonfunc.h"
+
+typedef struct recvErrMsg
+{
+    int errorno;
+    int msglen;
+    char msg[LARGE_INFO_LENGTH];
+    char detail[LARGE_INFO_LENGTH];
+    char setresult[LARGE_INFO_LENGTH];
+}recvErrMsg;
+
+//The communication between onvif and mediapipe through socket , and this is the client socket.
+void _get_stream_uri(char *uri,int* res_status);
+void _get_range(Options *opt, int* res_status);
+void _get_image_config(ImagingSetting *img,int* res_status);
+void _get_videoenc_config(VideoEncoderConfiguration *videoenc,int* res_status);
+void _set_image_config(ImagingSetting *img,int* res_status);
+void _set_videoenc_config(VideoEncoderConfiguration *videoenc,int* res_status);
+#endif
-- 
1.9.1

