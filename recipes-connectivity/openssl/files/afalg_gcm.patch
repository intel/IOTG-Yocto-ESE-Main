commit 16044001c7b42f37249b040687673b1fe8395e78
Author: Hemanthkumar Sm <hemanthkumar.sm@intel.com>
Date:   Tue Sep 17 12:43:47 2019 +0530

    AF_ALG support gcm

diff --git a/engines/e_afalg.c b/engines/e_afalg.c
index f09c396..8d9c4c4 100644
--- a/engines/e_afalg.c
+++ b/engines/e_afalg.c
@@ -16,6 +16,7 @@
 #include <unistd.h>
 
 #include <openssl/engine.h>
+#include <openssl/crypto.h>
 #include <openssl/async.h>
 #include <openssl/err.h>
 #include "internal/nelem.h"
@@ -72,15 +73,16 @@ void engine_load_afalg_int(void);
 
 /* Local Linkage Functions */
 static int afalg_init_aio(afalg_aio *aio);
-static int afalg_fin_cipher_aio(afalg_aio *ptr, int sfd,
+static int afalg_fin_cipher_aio(EVP_CIPHER_CTX *ctx, int sfd,
                                 unsigned char *buf, size_t len);
 static int afalg_create_sk(afalg_ctx *actx, const char *ciphertype,
                                 const char *ciphername);
 static int afalg_destroy(ENGINE *e);
 static int afalg_init(ENGINE *e);
 static int afalg_finish(ENGINE *e);
-static const EVP_CIPHER *afalg_aes_cbc(int nid);
-static cbc_handles *get_cipher_handle(int nid);
+static int afalg_cipher_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
+static const EVP_CIPHER *afalg_aes_cipher(int nid);
+static aes_handles *get_cipher_handle(int nid);
 static int afalg_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
                          const int **nids, int nid);
 static int afalg_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
@@ -98,11 +100,17 @@ static int afalg_cipher_nids[] = {
     NID_aes_128_cbc,
     NID_aes_192_cbc,
     NID_aes_256_cbc,
+    NID_aes_128_gcm,
+    NID_aes_192_gcm,
+    NID_aes_256_gcm,
 };
 
-static cbc_handles cbc_handle[] = {{AES_KEY_SIZE_128, NULL},
-                                    {AES_KEY_SIZE_192, NULL},
-                                    {AES_KEY_SIZE_256, NULL}};
+static aes_handles cipher_handle[] = {{AES_KEY_SIZE_128, NULL},
+                                      {AES_KEY_SIZE_192, NULL},
+                                      {AES_KEY_SIZE_256, NULL},
+                                      {AES_KEY_SIZE_128, NULL},
+                                      {AES_KEY_SIZE_192, NULL},
+                                      {AES_KEY_SIZE_256, NULL}};
 
 static ossl_inline int io_setup(unsigned n, aio_context_t *ctx)
 {
@@ -216,7 +224,7 @@ static int afalg_init_aio(afalg_aio *aio)
     return 1;
 }
 
-static int afalg_fin_cipher_aio(afalg_aio *aio, int sfd, unsigned char *buf,
+static int afalg_fin_cipher_aio(EVP_CIPHER_CTX *ctx, int sfd, unsigned char *buf,
                                 size_t len)
 {
     int r;
@@ -226,6 +234,14 @@ static int afalg_fin_cipher_aio(afalg_aio *aio, int sfd, unsigned char *buf,
     struct timespec timeout;
     struct io_event events[MAX_INFLIGHTS];
     u_int64_t eval = 0;
+    struct iovec iov[3];
+    afalg_cipher_ctx *ectx = (afalg_cipher_ctx *)
+                           EVP_CIPHER_CTX_get_cipher_data(ctx);
+    afalg_ctx *actx  = (afalg_ctx *) EVP_CIPHER_CTX_get_cipher_data(ctx);
+    afalg_aio *aio = &actx->aio;
+    int nid;
+
+    nid = EVP_CIPHER_CTX_nid(ctx);
 
     timeout.tv_sec = 0;
     timeout.tv_nsec = 0;
@@ -239,16 +255,44 @@ static int afalg_fin_cipher_aio(afalg_aio *aio, int sfd, unsigned char *buf,
 
     cb = &(aio->cbt[0 % MAX_INFLIGHTS]);
     memset(cb, '\0', sizeof(*cb));
+
+    switch (nid) {
+    case NID_aes_128_cbc:
+    case NID_aes_192_cbc:
+    case NID_aes_256_cbc:
+        iov[0].iov_base = (unsigned char *)buf;
+        iov[0].iov_len = len;
+        cb->aio_nbytes = 1;
+        break;
+    case NID_aes_128_gcm:
+    case NID_aes_192_gcm:
+    case NID_aes_256_gcm:
+        iov[0].iov_base = (void *)ectx->aad;
+        iov[0].iov_len = ectx->aad_len;
+        iov[1].iov_base = (unsigned char *)buf;
+        iov[1].iov_len = len;
+
+        if (EVP_CIPHER_CTX_encrypting(ctx)) {
+           iov[2].iov_base = (unsigned char *)EVP_CIPHER_CTX_buf_noconst(ctx);
+           iov[2].iov_len = EVP_GCM_TLS_TAG_LEN;
+           cb->aio_nbytes = 3;
+        } else {
+           cb->aio_nbytes = 2;
+        }
+        break;
+    default:
+        return 0;
+    }
+
     cb->aio_fildes = sfd;
-    cb->aio_lio_opcode = IOCB_CMD_PREAD;
+    cb->aio_lio_opcode = IOCB_CMD_PREADV;
     /*
      * The pointer has to be converted to unsigned value first to avoid
      * sign extension on cast to 64 bit value in 32-bit builds
      */
-    cb->aio_buf = (size_t)buf;
+    cb->aio_buf = (size_t)iov;
     cb->aio_offset = 0;
     cb->aio_data = 0;
-    cb->aio_nbytes = len;
     cb->aio_flags = IOCB_FLAG_RESFD;
     cb->aio_resfd = aio->efd;
 
@@ -323,7 +367,28 @@ static int afalg_fin_cipher_aio(afalg_aio *aio, int sfd, unsigned char *buf,
         }
     } while (!done);
 
-    return 1;
+    switch (nid) {
+    case NID_aes_128_cbc:
+    case NID_aes_192_cbc:
+    case NID_aes_256_cbc:
+        if (EVP_CIPHER_CTX_encrypting(ctx)) {
+            memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), buf + (len - ALG_AES_IV_LEN),
+                   ALG_AES_IV_LEN);
+        } else {
+            memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), EVP_CIPHER_CTX_buf_noconst(ctx), ALG_AES_IV_LEN);
+        }
+        r = 1;
+        break;
+    case NID_aes_128_gcm:
+    case NID_aes_192_gcm:
+    case NID_aes_256_gcm:
+        r = len;
+        break;
+    default:
+        return 0;
+    }
+
+    return r;
 }
 
 static ossl_inline void afalg_set_op_sk(struct cmsghdr *cmsg,
@@ -348,6 +413,14 @@ static void afalg_set_iv_sk(struct cmsghdr *cmsg, const unsigned char *iv,
     memcpy(aiv->iv, iv, len);
 }
 
+static void afalg_set_aad_sk(struct cmsghdr *cmsg, const unsigned int len)
+{
+    cmsg->cmsg_level = SOL_ALG;
+    cmsg->cmsg_type = ALG_SET_AEAD_ASSOCLEN;
+    cmsg->cmsg_len = CMSG_LEN(sizeof(unsigned int));
+    memcpy(CMSG_DATA(cmsg), &len, sizeof(unsigned int));
+}
+
 static ossl_inline int afalg_set_key(afalg_ctx *actx, const unsigned char *key,
                                 const int klen)
 {
@@ -361,6 +434,20 @@ static ossl_inline int afalg_set_key(afalg_ctx *actx, const unsigned char *key,
     return 1;
 }
 
+static ossl_inline int afalg_set_aad(EVP_CIPHER_CTX *ctx)
+{
+    afalg_ctx *actx = (afalg_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
+    int ret;
+    ret = setsockopt(actx->bfd, SOL_ALG, ALG_SET_AEAD_AUTHSIZE, NULL,
+                     EVP_GCM_TLS_TAG_LEN);
+    if (ret < 0) {
+        ALG_PERR("%s(%d): Failed to set socket option : ", __FILE__, __LINE__);
+        AFALGerr(AFALG_F_AFALG_SET_AAD, AFALG_R_SOCKET_SET_AAD_FAILED);
+        return 0;
+    }
+    return 1;
+}
+
 static int afalg_create_sk(afalg_ctx *actx, const char *ciphertype,
                                 const char *ciphername)
 {
@@ -408,36 +495,111 @@ static int afalg_create_sk(afalg_ctx *actx, const char *ciphertype,
     return 0;
 }
 
-static int afalg_start_cipher_sk(afalg_ctx *actx, const unsigned char *in,
+static int afalg_start_cipher_sk(EVP_CIPHER_CTX *ctx, const unsigned char *in,
                                  size_t inl, const unsigned char *iv,
                                  unsigned int enc)
 {
     struct msghdr msg = { 0 };
     struct cmsghdr *cmsg;
-    struct iovec iov;
-    ssize_t sbytes;
+    struct iovec iov[3];
+    ssize_t sbytes, expected_sbytes;
 # ifdef ALG_ZERO_COPY
-    int ret;
+    int ret, iovlen, copy_len;
 # endif
-    char cbuf[CMSG_SPACE(ALG_IV_LEN(ALG_AES_IV_LEN)) + CMSG_SPACE(ALG_OP_LEN)];
-
-    memset(cbuf, 0, sizeof(cbuf));
-    msg.msg_control = cbuf;
-    msg.msg_controllen = sizeof(cbuf);
+    char *cbuf;
+    afalg_cipher_ctx *ectx = (afalg_cipher_ctx *)
+                           EVP_CIPHER_CTX_get_cipher_data(ctx);
+    afalg_ctx *actx  = (afalg_ctx *) EVP_CIPHER_CTX_get_cipher_data(ctx);
+    int nid;
 
     /*
      * cipher direction (i.e. encrypt or decrypt) and iv are sent to the
      * kernel as part of sendmsg()'s ancillary data
      */
-    cmsg = CMSG_FIRSTHDR(&msg);
-    afalg_set_op_sk(cmsg, enc);
-    cmsg = CMSG_NXTHDR(&msg, cmsg);
-    afalg_set_iv_sk(cmsg, iv, ALG_AES_IV_LEN);
-
-    /* iov that describes input data */
-    iov.iov_base = (unsigned char *)in;
-    iov.iov_len = inl;
 
+    nid = EVP_CIPHER_CTX_nid(ctx);
+    switch (nid) {
+    case NID_aes_128_cbc:
+    case NID_aes_192_cbc:
+    case NID_aes_256_cbc:
+        msg.msg_controllen = (size_t)(CMSG_SPACE(ALG_IV_LEN(ALG_AES_IV_LEN)) + CMSG_SPACE(ALG_OP_LEN));
+        cbuf = OPENSSL_zalloc(msg.msg_controllen);
+        if(cbuf == NULL){
+            ALG_PERR("%s(%d): OPENSSL_zalloc failed : ", __FILE__, __LINE__);
+            goto err;
+        }
+        msg.msg_control = cbuf;
+        cmsg = CMSG_FIRSTHDR(&msg);
+        afalg_set_op_sk(cmsg, enc);
+        cmsg = CMSG_NXTHDR(&msg, cmsg);
+        afalg_set_iv_sk(cmsg, iv, ALG_AES_IV_LEN);
+
+        /* iov that describes input data */
+        iov[0].iov_base = (unsigned char *)in;
+        iov[0].iov_len = inl;
+        if(enc)
+        {
+            memcpy(EVP_CIPHER_CTX_buf_noconst(ctx), in + (inl - ALG_AES_IV_LEN), ALG_AES_IV_LEN);
+        }
+        #ifdef ALG_ZERO_COPY
+            /* Input data is not sent as part of call to sendmsg() */
+            msg.msg_iovlen = 0;
+            msg.msg_iov = NULL;
+            iovlen = 1;
+            copy_len = inl;
+        #else
+            msg.msg_iovlen = 1;
+            msg.msg_iov = iov;
+            expected_sbytes = (ssize_t) inl;
+        #endif
+        break;
+    case NID_aes_128_gcm:
+    case NID_aes_192_gcm:
+    case NID_aes_256_gcm:
+        msg.msg_controllen = (size_t)(CMSG_SPACE(ALG_IV_LEN(EVP_CIPHER_CTX_iv_length(ctx))) + CMSG_SPACE(ALG_OP_LEN) + CMSG_SPACE(AES_GCM_IV_LEN));
+        cbuf = OPENSSL_zalloc(msg.msg_controllen);
+        if(cbuf == NULL){
+            ALG_PERR("%s(%d): OPENSSL_zalloc failed : ", __FILE__, __LINE__);
+            goto err;
+        }
+        msg.msg_control = cbuf;
+        cmsg = CMSG_FIRSTHDR(&msg);
+        afalg_set_op_sk(cmsg, enc);
+        cmsg = CMSG_NXTHDR(&msg, cmsg);
+        afalg_set_iv_sk(cmsg, iv, EVP_CIPHER_CTX_iv_length(ctx));
+        cmsg = CMSG_NXTHDR(&msg, cmsg);
+        afalg_set_aad_sk(cmsg, ectx->aad_len);
+
+        /* iov that describes input data */
+        iov[0].iov_base = (void *)ectx->aad;
+        iov[0].iov_len = ectx->aad_len;
+        iov[1].iov_base = (unsigned char *)in;
+        iov[1].iov_len = inl;
+        #ifdef ALG_ZERO_COPY
+            iov[2].iov_base = (void *)EVP_CIPHER_CTX_buf_noconst(ctx);
+            iov[2].iov_len = EVP_GCM_TLS_TAG_LEN;
+            msg.msg_iovlen = 0;
+            msg.msg_iov = NULL;
+            iovlen = 3;
+            copy_len = ectx->aad_len + inl + EVP_GCM_TLS_TAG_LEN;
+        #else
+            if (enc)
+            {
+              msg.msg_iovlen = 2;
+              expected_sbytes = (ssize_t)(inl + ectx->aad_len);
+            } else {
+              iov[2].iov_base = (void *)EVP_CIPHER_CTX_buf_noconst(ctx);
+              iov[2].iov_len = EVP_GCM_TLS_TAG_LEN;
+              msg.msg_iovlen = 3;
+              expected_sbytes = (ssize_t)(inl + ectx->aad_len + EVP_GCM_TLS_TAG_LEN);
+            }
+            msg.msg_iov = iov;
+        #endif
+        break;
+    default:
+        goto err;
+        break;
+    }
     msg.msg_flags = MSG_MORE;
 
 # ifdef ALG_ZERO_COPY
@@ -447,53 +609,51 @@ static int afalg_start_cipher_sk(afalg_ctx *actx, const unsigned char *in,
      * OPENS: out of place processing (i.e. out != in)
      */
 
-    /* Input data is not sent as part of call to sendmsg() */
-    msg.msg_iovlen = 0;
-    msg.msg_iov = NULL;
-
     /* Sendmsg() sends iv and cipher direction to the kernel */
     sbytes = sendmsg(actx->sfd, &msg, 0);
     if (sbytes < 0) {
         ALG_PERR("%s(%d): sendmsg failed for zero copy cipher operation : ",
                  __FILE__, __LINE__);
-        return 0;
+        goto err;
     }
 
     /*
      * vmsplice and splice are used to pin the user space input buffer for
      * kernel space processing avoiding copys from user to kernel space
      */
-    ret = vmsplice(actx->zc_pipe[1], &iov, 1, SPLICE_F_GIFT);
+    ret = vmsplice(actx->zc_pipe[1], &iov, iovlen, SPLICE_F_GIFT);
     if (ret < 0) {
         ALG_PERR("%s(%d): vmsplice failed : ", __FILE__, __LINE__);
-        return 0;
+        goto err;
     }
 
-    ret = splice(actx->zc_pipe[0], NULL, actx->sfd, NULL, inl, 0);
+    ret = splice(actx->zc_pipe[0], NULL, actx->sfd, NULL, copy_len, 0);
     if (ret < 0) {
         ALG_PERR("%s(%d): splice failed : ", __FILE__, __LINE__);
-        return 0;
+        goto err;
     }
 # else
-    msg.msg_iovlen = 1;
-    msg.msg_iov = &iov;
-
     /* Sendmsg() sends iv, cipher direction and input data to the kernel */
     sbytes = sendmsg(actx->sfd, &msg, 0);
     if (sbytes < 0) {
         ALG_PERR("%s(%d): sendmsg failed for cipher operation : ", __FILE__,
                  __LINE__);
-        return 0;
+        goto err;
     }
 
-    if (sbytes != (ssize_t) inl) {
+    if (sbytes != expected_sbytes) {
         ALG_WARN("Cipher operation send bytes %zd != inlen %zd\n", sbytes,
-                inl);
-        return 0;
+                expected_sbytes);
+        goto err;
     }
 # endif
 
+    OPENSSL_free(cbuf);
     return 1;
+
+err:
+    OPENSSL_free(cbuf);
+    return 0;
 }
 
 static int afalg_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
@@ -501,10 +661,14 @@ static int afalg_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 {
     int ciphertype;
     int ret;
+    int ivlen = 0;
     afalg_ctx *actx;
     char ciphername[ALG_MAX_SALG_NAME];
+    char algtype[ALG_MAX_SALG_NAME];
+    int aad_required = 0;
+    afalg_cipher_ctx *ectx;
 
-    if (ctx == NULL || key == NULL) {
+    if (ctx == NULL) {
         ALG_WARN("%s(%d): Null Parameter\n", __FILE__, __LINE__);
         return 0;
     }
@@ -514,6 +678,7 @@ static int afalg_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
         return 0;
     }
 
+    ectx = (afalg_cipher_ctx *) EVP_CIPHER_CTX_get_cipher_data(ctx);
     actx = EVP_CIPHER_CTX_get_cipher_data(ctx);
     if (actx == NULL) {
         ALG_WARN("%s(%d): Cipher data NULL\n", __FILE__, __LINE__);
@@ -525,7 +690,29 @@ static int afalg_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     case NID_aes_128_cbc:
     case NID_aes_192_cbc:
     case NID_aes_256_cbc:
+        if (key == NULL) {
+            ALG_WARN("%s(%d): Null Parameter\n", __FILE__, __LINE__);
+            return 0;
+        }
         strncpy(ciphername, "cbc(aes)", ALG_MAX_SALG_NAME);
+        strncpy(algtype, "skcipher", ALG_MAX_SALG_NAME);
+        ivlen = ALG_AES_IV_LEN;
+        if (ivlen != EVP_CIPHER_CTX_iv_length(ctx)) {
+            ALG_WARN("%s(%d): Unsupported IV length :%d\n", __FILE__, __LINE__,
+                     EVP_CIPHER_CTX_iv_length(ctx));
+            return 0;
+        }
+        break;
+    case NID_aes_128_gcm:
+    case NID_aes_192_gcm:
+    case NID_aes_256_gcm:
+        if (key == NULL || iv == NULL) {
+            return 1;
+        }
+        strncpy(ciphername, "gcm(aes)", ALG_MAX_SALG_NAME);
+        strncpy(algtype, "aead", ALG_MAX_SALG_NAME);
+        ectx->iv = iv;
+        aad_required = 1;
         break;
     default:
         ALG_WARN("%s(%d): Unsupported Cipher type %d\n", __FILE__, __LINE__,
@@ -533,15 +720,10 @@ static int afalg_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
         return 0;
     }
     ciphername[ALG_MAX_SALG_NAME-1]='\0';
-
-    if (ALG_AES_IV_LEN != EVP_CIPHER_CTX_iv_length(ctx)) {
-        ALG_WARN("%s(%d): Unsupported IV length :%d\n", __FILE__, __LINE__,
-                 EVP_CIPHER_CTX_iv_length(ctx));
-        return 0;
-    }
+    algtype[ALG_MAX_SALG_NAME-1]='\0';
 
     /* Setup AFALG socket for crypto processing */
-    ret = afalg_create_sk(actx, "skcipher", ciphername);
+    ret = afalg_create_sk(actx, algtype, ciphername);
     if (ret < 1)
         return 0;
 
@@ -550,6 +732,13 @@ static int afalg_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     if (ret < 1)
         goto err;
 
+    if(aad_required)
+    {
+        ret = afalg_set_aad(ctx);
+        if (ret < 1)
+            goto err;
+    }
+
     /* Setup AIO ctx to allow async AFALG crypto processing */
     if (afalg_init_aio(&actx->aio) == 0)
         goto err;
@@ -572,15 +761,41 @@ static int afalg_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                            const unsigned char *in, size_t inl)
 {
     afalg_ctx *actx;
-    int ret;
-    char nxtiv[ALG_AES_IV_LEN] = { 0 };
+    int ret, nid;
+    afalg_cipher_ctx *ectx;
+    unsigned char *iv;
 
-    if (ctx == NULL || out == NULL || in == NULL) {
+    if (ctx == NULL || in == NULL) {
         ALG_WARN("NULL parameter passed to function %s(%d)\n", __FILE__,
                  __LINE__);
         return 0;
     }
 
+    ectx = (afalg_cipher_ctx *) EVP_CIPHER_CTX_get_cipher_data(ctx);
+    nid = EVP_CIPHER_CTX_nid(ctx);
+    switch (nid) {
+    case NID_aes_128_cbc:
+    case NID_aes_192_cbc:
+    case NID_aes_256_cbc:
+        if (out == NULL) {
+            ALG_WARN("NULL parameter passed to function %s(%d)\n", __FILE__,
+                     __LINE__);
+            return 0;
+        }
+        iv = EVP_CIPHER_CTX_iv(ctx);
+        break;
+    case NID_aes_128_gcm:
+    case NID_aes_192_gcm:
+    case NID_aes_256_gcm:
+        if (out == NULL) {
+           return afalg_cipher_ctrl(ctx, EVP_CTRL_AEAD_TLS1_AAD, inl, in);
+        }
+        iv = ectx->iv;
+        break;
+    default:
+        return 0;
+    }
+
     actx = (afalg_ctx *) EVP_CIPHER_CTX_get_cipher_data(ctx);
     if (actx == NULL || actx->init_done != MAGIC_INIT_NUM) {
         ALG_WARN("%s afalg ctx passed\n",
@@ -588,35 +803,19 @@ static int afalg_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         return 0;
     }
 
-    /*
-     * set iv now for decrypt operation as the input buffer can be
-     * overwritten for inplace operation where in = out.
-     */
-    if (EVP_CIPHER_CTX_encrypting(ctx) == 0) {
-        memcpy(nxtiv, in + (inl - ALG_AES_IV_LEN), ALG_AES_IV_LEN);
-    }
-
     /* Send input data to kernel space */
-    ret = afalg_start_cipher_sk(actx, (unsigned char *)in, inl,
-                                EVP_CIPHER_CTX_iv(ctx),
+    ret = afalg_start_cipher_sk(ctx, (unsigned char *)in, inl, iv,
                                 EVP_CIPHER_CTX_encrypting(ctx));
     if (ret < 1) {
         return 0;
     }
 
     /* Perform async crypto operation in kernel space */
-    ret = afalg_fin_cipher_aio(&actx->aio, actx->sfd, out, inl);
+    ret = afalg_fin_cipher_aio(ctx, actx->sfd, out, inl);
     if (ret < 1)
         return 0;
 
-    if (EVP_CIPHER_CTX_encrypting(ctx)) {
-        memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), out + (inl - ALG_AES_IV_LEN),
-               ALG_AES_IV_LEN);
-    } else {
-        memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), nxtiv, ALG_AES_IV_LEN);
-    }
-
-    return 1;
+    return ret;
 }
 
 static int afalg_cipher_cleanup(EVP_CIPHER_CTX *ctx)
@@ -650,33 +849,34 @@ static int afalg_cipher_cleanup(EVP_CIPHER_CTX *ctx)
     return 1;
 }
 
-static cbc_handles *get_cipher_handle(int nid)
+static aes_handles *get_cipher_handle(int nid)
 {
     switch (nid) {
     case NID_aes_128_cbc:
-        return &cbc_handle[AES_CBC_128];
+        return &cipher_handle[AES_CBC_128];
     case NID_aes_192_cbc:
-        return &cbc_handle[AES_CBC_192];
+        return &cipher_handle[AES_CBC_192];
     case NID_aes_256_cbc:
-        return &cbc_handle[AES_CBC_256];
+        return &cipher_handle[AES_CBC_256];
+    case NID_aes_128_gcm:
+        return &cipher_handle[AES_GCM_128];
+    case NID_aes_192_gcm:
+        return &cipher_handle[AES_GCM_192];
+    case NID_aes_256_gcm:
+        return &cipher_handle[AES_GCM_256];
     default:
         return NULL;
     }
 }
 
-static const EVP_CIPHER *afalg_aes_cbc(int nid)
+static const EVP_CIPHER *afalg_aes_cipher(int nid)
 {
-    cbc_handles *cipher_handle = get_cipher_handle(nid);
+    aes_handles *cipher_handle = get_cipher_handle(nid);
     if (cipher_handle->_hidden == NULL
         && ((cipher_handle->_hidden =
          EVP_CIPHER_meth_new(nid,
                              AES_BLOCK_SIZE,
                              cipher_handle->key_size)) == NULL
-        || !EVP_CIPHER_meth_set_iv_length(cipher_handle->_hidden,
-                                          AES_IV_LEN)
-        || !EVP_CIPHER_meth_set_flags(cipher_handle->_hidden,
-                                      EVP_CIPH_CBC_MODE |
-                                      EVP_CIPH_FLAG_DEFAULT_ASN1)
         || !EVP_CIPHER_meth_set_init(cipher_handle->_hidden,
                                      afalg_cipher_init)
         || !EVP_CIPHER_meth_set_do_cipher(cipher_handle->_hidden,
@@ -684,13 +884,111 @@ static const EVP_CIPHER *afalg_aes_cbc(int nid)
         || !EVP_CIPHER_meth_set_cleanup(cipher_handle->_hidden,
                                         afalg_cipher_cleanup)
         || !EVP_CIPHER_meth_set_impl_ctx_size(cipher_handle->_hidden,
-                                              sizeof(afalg_ctx)))) {
+                                              sizeof(afalg_cipher_ctx)))) {
         EVP_CIPHER_meth_free(cipher_handle->_hidden);
         cipher_handle->_hidden= NULL;
     }
+
+    switch (nid) {
+    case NID_aes_128_cbc:
+    case NID_aes_192_cbc:
+    case NID_aes_256_cbc:
+        if(!EVP_CIPHER_meth_set_iv_length(cipher_handle->_hidden,
+                                          AES_IV_LEN)
+           || !EVP_CIPHER_meth_set_flags(cipher_handle->_hidden,
+                                      EVP_CIPH_CBC_MODE |
+                                      EVP_CIPH_FLAG_DEFAULT_ASN1)){
+            EVP_CIPHER_meth_free(cipher_handle->_hidden);
+            cipher_handle->_hidden= NULL;
+        }
+        break;
+    case NID_aes_128_gcm:
+    case NID_aes_192_gcm:
+    case NID_aes_256_gcm:
+        if(!EVP_CIPHER_meth_set_iv_length(cipher_handle->_hidden,
+                                          AES_GCM_IV_LEN)
+           || !EVP_CIPHER_meth_set_ctrl(cipher_handle->_hidden,
+                                     afalg_cipher_ctrl)
+           || !EVP_CIPHER_meth_set_flags(cipher_handle->_hidden,
+                                      EVP_CIPH_GCM_MODE |
+                                      GCM_FLAGS |
+                                      EVP_CIPH_FLAG_AEAD_CIPHER)){
+            EVP_CIPHER_meth_free(cipher_handle->_hidden);
+            cipher_handle->_hidden= NULL;
+        }
+        break;
+    default:
+        break;
+    }
+
     return cipher_handle->_hidden;
 }
 
+static int afalg_cipher_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
+{
+    afalg_cipher_ctx *ectx = (afalg_cipher_ctx *)
+                            EVP_CIPHER_CTX_get_cipher_data(ctx);
+    unsigned int len;
+    int ret = 1;
+
+    switch (type) {
+    case EVP_CTRL_INIT:
+        ectx->aad_len = -1;
+        break;
+    case EVP_CTRL_GCM_SET_TAG:
+        if (arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting(ctx)) {
+            ret = 0;
+            break;
+        }
+        memcpy(EVP_CIPHER_CTX_buf_noconst(ctx), ptr, arg);
+        ectx->taglen = arg;
+        break;
+    case EVP_CTRL_GCM_GET_TAG:
+        if (arg <= 0 || arg > 16) {
+            ret = 0;
+            break;
+        }
+        memcpy(ptr, EVP_CIPHER_CTX_buf_noconst(ctx), arg);
+        break;
+    case EVP_CTRL_AEAD_SET_IVLEN:
+        if (arg <= 0) {
+            ret = 0;
+            break;
+	       }
+        EVP_CIPHER_meth_set_iv_length(EVP_CIPHER_CTX_cipher(ctx), arg);
+        break;
+     case EVP_CTRL_AEAD_TLS1_AAD:
+        ectx->aad = ptr;
+        ectx->aad_len = arg;
+        break;
+      default:
+            ret = -1;
+            break;
+   }
+   return ret;
+}
+
+static int afalg_init_ciphers(int nid)
+{
+    int r = 1;
+
+    switch (nid) {
+    case NID_aes_128_cbc:
+    case NID_aes_192_cbc:
+    case NID_aes_256_cbc:
+    case NID_aes_128_gcm:
+    case NID_aes_192_gcm:
+    case NID_aes_256_gcm:
+        if (afalg_aes_cipher(nid) == NULL)
+            r = 0;
+        break;
+    default:
+        r = 0;
+        break;
+    }
+    return r;
+}
+
 static int afalg_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
                          const int **nids, int nid)
 {
@@ -705,7 +1003,10 @@ static int afalg_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
     case NID_aes_128_cbc:
     case NID_aes_192_cbc:
     case NID_aes_256_cbc:
-        *cipher = afalg_aes_cbc(nid);
+    case NID_aes_128_gcm:
+    case NID_aes_192_gcm:
+    case NID_aes_256_gcm:
+        *cipher = afalg_aes_cipher(nid);
         break;
     default:
         *cipher = NULL;
@@ -735,7 +1036,7 @@ static int bind_afalg(ENGINE *e)
      * time.
      */
     for(i = 0; i < OSSL_NELEM(afalg_cipher_nids); i++) {
-        if (afalg_aes_cbc(afalg_cipher_nids[i]) == NULL) {
+        if (!afalg_init_ciphers(afalg_cipher_nids[i])) {
             AFALGerr(AFALG_F_BIND_AFALG, AFALG_R_INIT_FAILED);
             return 0;
         }
@@ -850,12 +1151,12 @@ static int afalg_finish(ENGINE *e)
     return 1;
 }
 
-static int free_cbc(void)
+static int free_cipher(void)
 {
     short unsigned int i;
     for(i = 0; i < OSSL_NELEM(afalg_cipher_nids); i++) {
-        EVP_CIPHER_meth_free(cbc_handle[i]._hidden);
-        cbc_handle[i]._hidden = NULL;
+        EVP_CIPHER_meth_free(cipher_handle[i]._hidden);
+        cipher_handle[i]._hidden = NULL;
     }
     return 1;
 }
@@ -863,7 +1164,7 @@ static int free_cbc(void)
 static int afalg_destroy(ENGINE *e)
 {
     ERR_unload_AFALG_strings();
-    free_cbc();
+    free_cipher();
     return 1;
 }
 
diff --git a/engines/e_afalg.h b/engines/e_afalg.h
index 2c03c44..890fad3 100644
--- a/engines/e_afalg.h
+++ b/engines/e_afalg.h
@@ -44,8 +44,13 @@
 # define AES_KEY_SIZE_192 24
 # define AES_KEY_SIZE_256 32
 # define AES_IV_LEN       16
+# define AES_GCM_IV_LEN   12
 
 # define MAX_INFLIGHTS 1
+# define GCM_FLAGS (EVP_CIPH_FLAG_DEFAULT_ASN1 \
+                | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \
+                | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \
+                | EVP_CIPH_CUSTOM_COPY)
 
 typedef enum {
     MODE_UNINIT = 0,
@@ -56,15 +61,18 @@ typedef enum {
 enum {
     AES_CBC_128 = 0,
     AES_CBC_192,
-    AES_CBC_256
+    AES_CBC_256,
+    AES_GCM_128,
+    AES_GCM_192,
+    AES_GCM_256
 };
 
-struct cbc_cipher_handles {
+struct aes_cipher_handles {
     int key_size;
     EVP_CIPHER *_hidden;
 };
 
-typedef struct cbc_cipher_handles cbc_handles;
+typedef struct aes_cipher_handles aes_handles;
 
 struct afalg_aio_st {
     int efd;
@@ -80,7 +88,7 @@ typedef struct afalg_aio_st afalg_aio;
  * of afalg_ctx.
  */
 # define MAGIC_INIT_NUM 0x1890671
-
+# define ALG_ZERO_COPY
 struct afalg_ctx_st {
     int init_done;
     int sfd;
@@ -92,4 +100,14 @@ struct afalg_ctx_st {
 };
 
 typedef struct afalg_ctx_st afalg_ctx;
+
+struct afalg_cipher_ctx_st {
+    afalg_ctx ctx;
+    int taglen;
+    int aad_len;
+    unsigned char* aad;
+    unsigned char* iv;
+};
+
+typedef struct afalg_cipher_ctx_st afalg_cipher_ctx;
 #endif
diff --git a/engines/e_afalg.txt b/engines/e_afalg.txt
index 3b79305..4492da8 100644
--- a/engines/e_afalg.txt
+++ b/engines/e_afalg.txt
@@ -13,6 +13,7 @@ AFALG_F_AFALG_SETUP_ASYNC_EVENT_NOTIFICATION:103:\
 	afalg_setup_async_event_notification
 AFALG_F_AFALG_SET_KEY:104:afalg_set_key
 AFALG_F_BIND_AFALG:105:bind_afalg
+AFALG_F_AFALG_SET_AAD:106:afalg_set_aad
 
 #Reason codes
 AFALG_R_EVENTFD_FAILED:108:eventfd failed
@@ -28,3 +29,4 @@ AFALG_R_SOCKET_BIND_FAILED:103:socket bind failed
 AFALG_R_SOCKET_CREATE_FAILED:109:socket create failed
 AFALG_R_SOCKET_OPERATION_FAILED:104:socket operation failed
 AFALG_R_SOCKET_SET_KEY_FAILED:106:socket set key failed
+AFALG_R_SOCKET_SET_AAD_FAILED:112:socket set aad failed
diff --git a/engines/e_afalg_err.h b/engines/e_afalg_err.h
index 3eb1332..e433019 100644
--- a/engines/e_afalg_err.h
+++ b/engines/e_afalg_err.h
@@ -23,6 +23,7 @@
 # define AFALG_F_AFALG_SETUP_ASYNC_EVENT_NOTIFICATION     103
 # define AFALG_F_AFALG_SET_KEY                            104
 # define AFALG_F_BIND_AFALG                               105
+# define AFALG_F_AFALG_SET_AAD                            106
 
 /*
  * AFALG reason codes.
@@ -39,5 +40,6 @@
 # define AFALG_R_SOCKET_CREATE_FAILED                     109
 # define AFALG_R_SOCKET_OPERATION_FAILED                  104
 # define AFALG_R_SOCKET_SET_KEY_FAILED                    106
+# define AFALG_R_SOCKET_SET_AAD_FAILED                    112
 
 #endif
