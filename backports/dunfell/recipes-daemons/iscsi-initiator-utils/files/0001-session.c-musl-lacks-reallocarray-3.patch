From 0646a6aea0405fcfef8795e2e7f40247f77b6db5 Mon Sep 17 00:00:00 2001
From: "Yong, Jonathan" <jonathan.yong@intel.com>
Date: Tue, 27 Apr 2021 06:54:58 +0000
Subject: [PATCH] session.c: musl lacks reallocarray(3)

Do as much as possible to emulate reallocarray for musl,
the original code may already leak memory in ENOMEM conditions.

There is no __MUSL__ macro or configuration feature check available.

Upstream-Status: Inappropriate [musl specific]

Signed-off-by: Yong, Jonathan <jonathan.yong@intel.com>
---
 libopeniscsiusr/session.c | 24 ++++++++++++++++++++++--
 1 file changed, 22 insertions(+), 2 deletions(-)

diff --git a/libopeniscsiusr/session.c b/libopeniscsiusr/session.c
index 6b06241..e8285cd 100644
--- a/libopeniscsiusr/session.c
+++ b/libopeniscsiusr/session.c
@@ -284,14 +284,34 @@ int iscsi_sessions_get(struct iscsi_context *ctx,
 			/* if not, just ignore the issue and keep trying with the next session ID,
 			 * there's always going to be an inherent race against session removal when collecting
 			 * attribute data from sysfs
-			 */
+		 */
 			_debug(ctx, "Problem reading session %" PRIu32 ", skipping.", sids[i]);
 			rc = LIBISCSI_OK;
 		}
 	}
 	/* reset session count and sessions array length to what we were able to read from sysfs */
 	*session_count = j;
-	*sessions = reallocarray(*sessions, *session_count, sizeof(struct iscsi_session *));
+
+	/* The reallocarray() function changes the size of the memory block
+	 * pointed to by ptr to be large enough for an array of nmemb
+	 * elements, each of which is size bytes.  It is equivalent to the
+	 * call
+	 *
+	 *	realloc(ptr, nmemb * size);
+	 *
+	 * However, unlike that realloc() call, reallocarray() fails safely
+	 * in the case where the multiplication would overflow.  If such an
+	 * overflow occurs, reallocarray() returns NULL, sets errno to
+	 * ENOMEM, and leaves the original block of memory unchanged.
+	 */
+
+	size_t session_size_result;
+	if (__builtin_umull_overflow(*session_count, sizeof(struct iscsi_session *), &session_size_result)) {
+		errno = ENOMEM;
+		rc = LIBISCSI_ERR_NOMEM;
+	} else {
+		*sessions = realloc(*sessions, session_size_result);
+	}
 
 out:
 	free(sids);
-- 
2.26.3

